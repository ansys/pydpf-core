"""
prepare_mechanical_native_mapping
=================================
Autogenerated DPF operator classes.
"""
from warnings import warn
from ansys.dpf.core.dpf_operator import Operator
from ansys.dpf.core.inputs import Input, _Inputs
from ansys.dpf.core.outputs import Output, _Outputs
from ansys.dpf.core.operators.specification import PinSpecification, Specification


class prepare_mechanical_native_mapping(Operator):
    """Prepare mapping of source data from source mesh to target mesh by
    operating the source_mesh/target_mesh weights computation. This
    operator needs to be used with the apply mechanical native mapping
    associated one. At least one of the optional DataTree inputs need
    to be set, in order to chose the mapping algorithm and set the
    mapping options.

    Parameters
    ----------
    source_mesh : MeshedRegion
        Source mesh
    target_mesh : MeshedRegion or Field
        Target mesh. can be a meshed region or a node
        coordinates field depending on the
        algorithm that is used. refer to the
        dedicated algorithm operator
        documentation.
    target_mesh_scoping : Scoping, optional
        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.
    html_report_path : str, optional
        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.
    shape_function_volumes_mapping : DataTree, optional
        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with shape function algorithm.
        another 'data_definition' subtree
        needs to be contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: scale (int),
        edge_tolerance (double), conservative
        (bool), ignore_outside_nodes (bool).
        corresponding operator definition can
        be checked to know the default values
        of the mapping options.
    shape_function_surfaces_mapping : DataTree, optional
        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with shape function algorithm.
        another 'data_definition' subtree
        needs to be contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: scale (int),
        edge_tolerance (double), conservative
        (bool), ignore_outside_nodes (bool),
        key (string), normal_distance_check
        (bool), normal_tolerance (double),
        pinball_controll (bool), pinball_key
        (string),
        exclude_elements_outside_pinball
        (bool), pinball_value (double).
        corresponding operator definition can
        be checked to know the default values
        of the mapping options.
    point_cloud_mapping : DataTree, optional
        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with point cloud algorithm. another
        'data_definition' subtree needs to be
        contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: weighting_type
        (string), outside_option (string),
        num_outside_nodes (int),
        max_outside_distance (double),
        search_limit (int), bouding_box_range
        (double), geometry_type
        (string),shell_thickness_factor
        (double). corresponding operator
        definition can be checked to know the
        default values of the mapping
        options.
    kriging_mapping : DataTree, optional
        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with kriging algorithm. another
        'data_definition' subtree needs to be
        contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: samples_limit
        (int), correlation_function_type
        (string), polynomial_type (string),
        outside_distance_checking (bool),
        bouding_box_tolerance (double),
        adaptive_tolerance_percent (double),
        geometry_type (string). corresponding
        operator definition can be checked to
        know the default values of the
        mapping options.


    Examples
    --------
    >>> from ansys.dpf import core as dpf

    >>> # Instantiate operator
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()

    >>> # Make input connections
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_shape_function_volumes_mapping = dpf.DataTree()
    >>> op.inputs.shape_function_volumes_mapping.connect(my_shape_function_volumes_mapping)
    >>> my_shape_function_surfaces_mapping = dpf.DataTree()
    >>> op.inputs.shape_function_surfaces_mapping.connect(my_shape_function_surfaces_mapping)
    >>> my_point_cloud_mapping = dpf.DataTree()
    >>> op.inputs.point_cloud_mapping.connect(my_point_cloud_mapping)
    >>> my_kriging_mapping = dpf.DataTree()
    >>> op.inputs.kriging_mapping.connect(my_kriging_mapping)

    >>> # Instantiate operator and connect inputs in one line
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping(
    ...     source_mesh=my_source_mesh,
    ...     target_mesh=my_target_mesh,
    ...     target_mesh_scoping=my_target_mesh_scoping,
    ...     html_report_path=my_html_report_path,
    ...     shape_function_volumes_mapping=my_shape_function_volumes_mapping,
    ...     shape_function_surfaces_mapping=my_shape_function_surfaces_mapping,
    ...     point_cloud_mapping=my_point_cloud_mapping,
    ...     kriging_mapping=my_kriging_mapping,
    ... )

    >>> # Get output data
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(
        self,
        source_mesh=None,
        target_mesh=None,
        target_mesh_scoping=None,
        html_report_path=None,
        shape_function_volumes_mapping=None,
        shape_function_surfaces_mapping=None,
        point_cloud_mapping=None,
        kriging_mapping=None,
        config=None,
        server=None,
    ):
        super().__init__(
            name="mechanical_native_mapping::prepare", config=config, server=server
        )
        self._inputs = InputsPrepareMechanicalNativeMapping(self)
        self._outputs = OutputsPrepareMechanicalNativeMapping(self)
        if source_mesh is not None:
            self.inputs.source_mesh.connect(source_mesh)
        if target_mesh is not None:
            self.inputs.target_mesh.connect(target_mesh)
        if target_mesh_scoping is not None:
            self.inputs.target_mesh_scoping.connect(target_mesh_scoping)
        if html_report_path is not None:
            self.inputs.html_report_path.connect(html_report_path)
        if shape_function_volumes_mapping is not None:
            self.inputs.shape_function_volumes_mapping.connect(
                shape_function_volumes_mapping
            )
        if shape_function_surfaces_mapping is not None:
            self.inputs.shape_function_surfaces_mapping.connect(
                shape_function_surfaces_mapping
            )
        if point_cloud_mapping is not None:
            self.inputs.point_cloud_mapping.connect(point_cloud_mapping)
        if kriging_mapping is not None:
            self.inputs.kriging_mapping.connect(kriging_mapping)

    @staticmethod
    def _spec():
        description = """Prepare mapping of source data from source mesh to target mesh by
            operating the source_mesh/target_mesh weights computation.
            This operator needs to be used with the apply mechanical
            native mapping associated one. At least one of the
            optional DataTree inputs need to be set, in order to chose
            the mapping algorithm and set the mapping options."""
        spec = Specification(
            description=description,
            map_input_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region", "field"],
                    optional=False,
                    document="""Target mesh. can be a meshed region or a node
        coordinates field depending on the
        algorithm that is used. refer to the
        dedicated algorithm operator
        documentation.""",
                ),
                3: PinSpecification(
                    name="target_mesh_scoping",
                    type_names=["scoping"],
                    optional=True,
                    document="""Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.""",
                ),
                8: PinSpecification(
                    name="html_report_path",
                    type_names=["string"],
                    optional=True,
                    document="""Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.""",
                ),
                30: PinSpecification(
                    name="shape_function_volumes_mapping",
                    type_names=["data_tree"],
                    optional=True,
                    document="""Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with shape function algorithm.
        another 'data_definition' subtree
        needs to be contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: scale (int),
        edge_tolerance (double), conservative
        (bool), ignore_outside_nodes (bool).
        corresponding operator definition can
        be checked to know the default values
        of the mapping options.""",
                ),
                31: PinSpecification(
                    name="shape_function_surfaces_mapping",
                    type_names=["data_tree"],
                    optional=True,
                    document="""Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with shape function algorithm.
        another 'data_definition' subtree
        needs to be contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: scale (int),
        edge_tolerance (double), conservative
        (bool), ignore_outside_nodes (bool),
        key (string), normal_distance_check
        (bool), normal_tolerance (double),
        pinball_controll (bool), pinball_key
        (string),
        exclude_elements_outside_pinball
        (bool), pinball_value (double).
        corresponding operator definition can
        be checked to know the default values
        of the mapping options.""",
                ),
                32: PinSpecification(
                    name="point_cloud_mapping",
                    type_names=["data_tree"],
                    optional=True,
                    document="""Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with point cloud algorithm. another
        'data_definition' subtree needs to be
        contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: weighting_type
        (string), outside_option (string),
        num_outside_nodes (int),
        max_outside_distance (double),
        search_limit (int), bouding_box_range
        (double), geometry_type
        (string),shell_thickness_factor
        (double). corresponding operator
        definition can be checked to know the
        default values of the mapping
        options.""",
                ),
                33: PinSpecification(
                    name="kriging_mapping",
                    type_names=["data_tree"],
                    optional=True,
                    document="""Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with kriging algorithm. another
        'data_definition' subtree needs to be
        contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: samples_limit
        (int), correlation_function_type
        (string), polynomial_type (string),
        outside_distance_checking (bool),
        bouding_box_tolerance (double),
        adaptive_tolerance_percent (double),
        geometry_type (string). corresponding
        operator definition can be checked to
        know the default values of the
        mapping options.""",
                ),
            },
            map_output_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="source_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Source mesh id""",
                ),
                2: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Target mesh""",
                ),
                3: PinSpecification(
                    name="target_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Target mesh id""",
                ),
                4: PinSpecification(
                    name="mapping_manager_data",
                    optional=False,
                    document="""""",
                ),
                6: PinSpecification(
                    name="target_scoping",
                    type_names=["scoping"],
                    optional=False,
                    document="""Target scoping""",
                ),
            },
        )
        return spec

    @staticmethod
    def default_config(server=None):
        """Returns the default config of the operator.

        This config can then be changed to the user needs and be used to
        instantiate the operator. The Configuration allows to customize
        how the operation will be processed by the operator.

        Parameters
        ----------
        server : server.DPFServer, optional
            Server with channel connected to the remote or local instance. When
            ``None``, attempts to use the global server.
        """
        return Operator.default_config(
            name="mechanical_native_mapping::prepare", server=server
        )

    @property
    def inputs(self):
        """Enables to connect inputs to the operator

        Returns
        --------
        inputs : InputsPrepareMechanicalNativeMapping
        """
        return super().inputs

    @property
    def outputs(self):
        """Enables to get outputs of the operator by evaluating it

        Returns
        --------
        outputs : OutputsPrepareMechanicalNativeMapping
        """
        return super().outputs


class InputsPrepareMechanicalNativeMapping(_Inputs):
    """Intermediate class used to connect user inputs to
    prepare_mechanical_native_mapping operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_shape_function_volumes_mapping = dpf.DataTree()
    >>> op.inputs.shape_function_volumes_mapping.connect(my_shape_function_volumes_mapping)
    >>> my_shape_function_surfaces_mapping = dpf.DataTree()
    >>> op.inputs.shape_function_surfaces_mapping.connect(my_shape_function_surfaces_mapping)
    >>> my_point_cloud_mapping = dpf.DataTree()
    >>> op.inputs.point_cloud_mapping.connect(my_point_cloud_mapping)
    >>> my_kriging_mapping = dpf.DataTree()
    >>> op.inputs.kriging_mapping.connect(my_kriging_mapping)
    """

    def __init__(self, op: Operator):
        super().__init__(prepare_mechanical_native_mapping._spec().inputs, op)
        self._source_mesh = Input(
            prepare_mechanical_native_mapping._spec().input_pin(0), 0, op, -1
        )
        self._inputs.append(self._source_mesh)
        self._target_mesh = Input(
            prepare_mechanical_native_mapping._spec().input_pin(1), 1, op, -1
        )
        self._inputs.append(self._target_mesh)
        self._target_mesh_scoping = Input(
            prepare_mechanical_native_mapping._spec().input_pin(3), 3, op, -1
        )
        self._inputs.append(self._target_mesh_scoping)
        self._html_report_path = Input(
            prepare_mechanical_native_mapping._spec().input_pin(8), 8, op, -1
        )
        self._inputs.append(self._html_report_path)
        self._shape_function_volumes_mapping = Input(
            prepare_mechanical_native_mapping._spec().input_pin(30), 30, op, -1
        )
        self._inputs.append(self._shape_function_volumes_mapping)
        self._shape_function_surfaces_mapping = Input(
            prepare_mechanical_native_mapping._spec().input_pin(31), 31, op, -1
        )
        self._inputs.append(self._shape_function_surfaces_mapping)
        self._point_cloud_mapping = Input(
            prepare_mechanical_native_mapping._spec().input_pin(32), 32, op, -1
        )
        self._inputs.append(self._point_cloud_mapping)
        self._kriging_mapping = Input(
            prepare_mechanical_native_mapping._spec().input_pin(33), 33, op, -1
        )
        self._inputs.append(self._kriging_mapping)

    @property
    def source_mesh(self):
        """Allows to connect source_mesh input to the operator.

        Source mesh

        Parameters
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.source_mesh.connect(my_source_mesh)
        >>> # or
        >>> op.inputs.source_mesh(my_source_mesh)
        """
        return self._source_mesh

    @property
    def target_mesh(self):
        """Allows to connect target_mesh input to the operator.

        Target mesh. can be a meshed region or a node
        coordinates field depending on the
        algorithm that is used. refer to the
        dedicated algorithm operator
        documentation.

        Parameters
        ----------
        my_target_mesh : MeshedRegion or Field

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.target_mesh.connect(my_target_mesh)
        >>> # or
        >>> op.inputs.target_mesh(my_target_mesh)
        """
        return self._target_mesh

    @property
    def target_mesh_scoping(self):
        """Allows to connect target_mesh_scoping input to the operator.

        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.

        Parameters
        ----------
        my_target_mesh_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
        >>> # or
        >>> op.inputs.target_mesh_scoping(my_target_mesh_scoping)
        """
        return self._target_mesh_scoping

    @property
    def html_report_path(self):
        """Allows to connect html_report_path input to the operator.

        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.

        Parameters
        ----------
        my_html_report_path : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.html_report_path.connect(my_html_report_path)
        >>> # or
        >>> op.inputs.html_report_path(my_html_report_path)
        """
        return self._html_report_path

    @property
    def shape_function_volumes_mapping(self):
        """Allows to connect shape_function_volumes_mapping input to the operator.

        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with shape function algorithm.
        another 'data_definition' subtree
        needs to be contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: scale (int),
        edge_tolerance (double), conservative
        (bool), ignore_outside_nodes (bool).
        corresponding operator definition can
        be checked to know the default values
        of the mapping options.

        Parameters
        ----------
        my_shape_function_volumes_mapping : DataTree

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.shape_function_volumes_mapping.connect(my_shape_function_volumes_mapping)
        >>> # or
        >>> op.inputs.shape_function_volumes_mapping(my_shape_function_volumes_mapping)
        """
        return self._shape_function_volumes_mapping

    @property
    def shape_function_surfaces_mapping(self):
        """Allows to connect shape_function_surfaces_mapping input to the operator.

        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with shape function algorithm.
        another 'data_definition' subtree
        needs to be contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: scale (int),
        edge_tolerance (double), conservative
        (bool), ignore_outside_nodes (bool),
        key (string), normal_distance_check
        (bool), normal_tolerance (double),
        pinball_controll (bool), pinball_key
        (string),
        exclude_elements_outside_pinball
        (bool), pinball_value (double).
        corresponding operator definition can
        be checked to know the default values
        of the mapping options.

        Parameters
        ----------
        my_shape_function_surfaces_mapping : DataTree

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.shape_function_surfaces_mapping.connect(my_shape_function_surfaces_mapping)
        >>> # or
        >>> op.inputs.shape_function_surfaces_mapping(my_shape_function_surfaces_mapping)
        """
        return self._shape_function_surfaces_mapping

    @property
    def point_cloud_mapping(self):
        """Allows to connect point_cloud_mapping input to the operator.

        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with point cloud algorithm. another
        'data_definition' subtree needs to be
        contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: weighting_type
        (string), outside_option (string),
        num_outside_nodes (int),
        max_outside_distance (double),
        search_limit (int), bouding_box_range
        (double), geometry_type
        (string),shell_thickness_factor
        (double). corresponding operator
        definition can be checked to know the
        default values of the mapping
        options.

        Parameters
        ----------
        my_point_cloud_mapping : DataTree

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.point_cloud_mapping.connect(my_point_cloud_mapping)
        >>> # or
        >>> op.inputs.point_cloud_mapping(my_point_cloud_mapping)
        """
        return self._point_cloud_mapping

    @property
    def kriging_mapping(self):
        """Allows to connect kriging_mapping input to the operator.

        Mapping options as datatree object with
        'mapping_options' subtree for mapping
        with kriging algorithm. another
        'data_definition' subtree needs to be
        contained, with at least
        'dimensionality' int and 'location'
        string attributes. the other
        'data_definition' and
        'mapping_options' attributes can be
        found looking at the corresponding
        operator definition. the available
        mapping_options are: samples_limit
        (int), correlation_function_type
        (string), polynomial_type (string),
        outside_distance_checking (bool),
        bouding_box_tolerance (double),
        adaptive_tolerance_percent (double),
        geometry_type (string). corresponding
        operator definition can be checked to
        know the default values of the
        mapping options.

        Parameters
        ----------
        my_kriging_mapping : DataTree

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> op.inputs.kriging_mapping.connect(my_kriging_mapping)
        >>> # or
        >>> op.inputs.kriging_mapping(my_kriging_mapping)
        """
        return self._kriging_mapping


class OutputsPrepareMechanicalNativeMapping(_Outputs):
    """Intermediate class used to get outputs from
    prepare_mechanical_native_mapping operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
    >>> # Connect inputs : op.inputs. ...
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(self, op: Operator):
        super().__init__(prepare_mechanical_native_mapping._spec().outputs, op)
        self._source_mesh = Output(
            prepare_mechanical_native_mapping._spec().output_pin(0), 0, op
        )
        self._outputs.append(self._source_mesh)
        self._source_mesh_id = Output(
            prepare_mechanical_native_mapping._spec().output_pin(1), 1, op
        )
        self._outputs.append(self._source_mesh_id)
        self._target_mesh = Output(
            prepare_mechanical_native_mapping._spec().output_pin(2), 2, op
        )
        self._outputs.append(self._target_mesh)
        self._target_mesh_id = Output(
            prepare_mechanical_native_mapping._spec().output_pin(3), 3, op
        )
        self._outputs.append(self._target_mesh_id)
        self._mapping_manager_data = Output(
            prepare_mechanical_native_mapping._spec().output_pin(4), 4, op
        )
        self._outputs.append(self._mapping_manager_data)
        self._target_scoping = Output(
            prepare_mechanical_native_mapping._spec().output_pin(6), 6, op
        )
        self._outputs.append(self._target_scoping)

    @property
    def source_mesh(self):
        """Allows to get source_mesh output of the operator

        Returns
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh = op.outputs.source_mesh()
        """  # noqa: E501
        return self._source_mesh

    @property
    def source_mesh_id(self):
        """Allows to get source_mesh_id output of the operator

        Returns
        ----------
        my_source_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh_id = op.outputs.source_mesh_id()
        """  # noqa: E501
        return self._source_mesh_id

    @property
    def target_mesh(self):
        """Allows to get target_mesh output of the operator

        Returns
        ----------
        my_target_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh = op.outputs.target_mesh()
        """  # noqa: E501
        return self._target_mesh

    @property
    def target_mesh_id(self):
        """Allows to get target_mesh_id output of the operator

        Returns
        ----------
        my_target_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh_id = op.outputs.target_mesh_id()
        """  # noqa: E501
        return self._target_mesh_id

    @property
    def mapping_manager_data(self):
        """Allows to get mapping_manager_data output of the operator

        Returns
        ----------
        my_mapping_manager_data :

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> # Connect inputs : op.inputs. ...
        >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
        """  # noqa: E501
        return self._mapping_manager_data

    @property
    def target_scoping(self):
        """Allows to get target_scoping output of the operator

        Returns
        ----------
        my_target_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_scoping = op.outputs.target_scoping()
        """  # noqa: E501
        return self._target_scoping

"""
prepare_mechanical_native_mapping_point_cloud
=============================================
Autogenerated DPF operator classes.
"""
from warnings import warn
from ansys.dpf.core.dpf_operator import Operator
from ansys.dpf.core.inputs import Input, _Inputs
from ansys.dpf.core.outputs import Output, _Outputs
from ansys.dpf.core.operators.specification import PinSpecification, Specification


class prepare_mechanical_native_mapping_point_cloud(Operator):
    """Prepare mapping of source data from source mesh to target mesh by
    operating the source_mesh/target_mesh weights computation. This
    operator will use a point cloud based algorithm. This operator
    needs to be used with the apply mechanical native mapping
    associated one.

    Parameters
    ----------
    source_mesh : MeshedRegion or Field
        Source mesh. can be a meshed region or a node
        coordinates field.
    target_mesh : MeshedRegion or Field
        Target mesh. can be a meshed region or a node
        coordinates field.
    target_mesh_scoping : Scoping, optional
        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.
    unit : str, optional
        Unit of the result to map
    location : str, optional
        Location of the result to map. if elemental,
        this input needs to be specified.
    dimensionality : int
        Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).
    e_shell_layers : int, optional
        Eshelllayers enum value if field has shell
        layers
    html_report_path : str, optional
        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.
    weighting_type : str, optional
        Default 'triangulation'. can also be
        'weighted_average'.
    outside_option : str, optional
        Default is 'weighted_average'. can also be
        'ignore', 'projection',
        'nearest_node'.
    num_outside_points : int, optional
        Default is 3
    max_outside_distance : float, optional
        Default is 0.0
    search_limit : int, optional
        Default is 20
    bounding_box_sizing : float, optional
        Pinball area. default is 0.0.
    geometry_type : str, optional
        Default is 'volume'. can also be 'surface'.
    shell_thickness_factor : float, optional
        Default is '0.0'


    Examples
    --------
    >>> from ansys.dpf import core as dpf

    >>> # Instantiate operator
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()

    >>> # Make input connections
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_unit = str()
    >>> op.inputs.unit.connect(my_unit)
    >>> my_location = str()
    >>> op.inputs.location.connect(my_location)
    >>> my_dimensionality = int()
    >>> op.inputs.dimensionality.connect(my_dimensionality)
    >>> my_e_shell_layers = int()
    >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_weighting_type = str()
    >>> op.inputs.weighting_type.connect(my_weighting_type)
    >>> my_outside_option = str()
    >>> op.inputs.outside_option.connect(my_outside_option)
    >>> my_num_outside_points = int()
    >>> op.inputs.num_outside_points.connect(my_num_outside_points)
    >>> my_max_outside_distance = float()
    >>> op.inputs.max_outside_distance.connect(my_max_outside_distance)
    >>> my_search_limit = int()
    >>> op.inputs.search_limit.connect(my_search_limit)
    >>> my_bounding_box_sizing = float()
    >>> op.inputs.bounding_box_sizing.connect(my_bounding_box_sizing)
    >>> my_geometry_type = str()
    >>> op.inputs.geometry_type.connect(my_geometry_type)
    >>> my_shell_thickness_factor = float()
    >>> op.inputs.shell_thickness_factor.connect(my_shell_thickness_factor)

    >>> # Instantiate operator and connect inputs in one line
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud(
    ...     source_mesh=my_source_mesh,
    ...     target_mesh=my_target_mesh,
    ...     target_mesh_scoping=my_target_mesh_scoping,
    ...     unit=my_unit,
    ...     location=my_location,
    ...     dimensionality=my_dimensionality,
    ...     e_shell_layers=my_e_shell_layers,
    ...     html_report_path=my_html_report_path,
    ...     weighting_type=my_weighting_type,
    ...     outside_option=my_outside_option,
    ...     num_outside_points=my_num_outside_points,
    ...     max_outside_distance=my_max_outside_distance,
    ...     search_limit=my_search_limit,
    ...     bounding_box_sizing=my_bounding_box_sizing,
    ...     geometry_type=my_geometry_type,
    ...     shell_thickness_factor=my_shell_thickness_factor,
    ... )

    >>> # Get output data
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(
        self,
        source_mesh=None,
        target_mesh=None,
        target_mesh_scoping=None,
        unit=None,
        location=None,
        dimensionality=None,
        e_shell_layers=None,
        html_report_path=None,
        weighting_type=None,
        outside_option=None,
        num_outside_points=None,
        max_outside_distance=None,
        search_limit=None,
        bounding_box_sizing=None,
        geometry_type=None,
        shell_thickness_factor=None,
        config=None,
        server=None,
    ):
        super().__init__(
            name="mechanical_native_mapping::prepare::point_cloud",
            config=config,
            server=server,
        )
        self._inputs = InputsPrepareMechanicalNativeMappingPointCloud(self)
        self._outputs = OutputsPrepareMechanicalNativeMappingPointCloud(self)
        if source_mesh is not None:
            self.inputs.source_mesh.connect(source_mesh)
        if target_mesh is not None:
            self.inputs.target_mesh.connect(target_mesh)
        if target_mesh_scoping is not None:
            self.inputs.target_mesh_scoping.connect(target_mesh_scoping)
        if unit is not None:
            self.inputs.unit.connect(unit)
        if location is not None:
            self.inputs.location.connect(location)
        if dimensionality is not None:
            self.inputs.dimensionality.connect(dimensionality)
        if e_shell_layers is not None:
            self.inputs.e_shell_layers.connect(e_shell_layers)
        if html_report_path is not None:
            self.inputs.html_report_path.connect(html_report_path)
        if weighting_type is not None:
            self.inputs.weighting_type.connect(weighting_type)
        if outside_option is not None:
            self.inputs.outside_option.connect(outside_option)
        if num_outside_points is not None:
            self.inputs.num_outside_points.connect(num_outside_points)
        if max_outside_distance is not None:
            self.inputs.max_outside_distance.connect(max_outside_distance)
        if search_limit is not None:
            self.inputs.search_limit.connect(search_limit)
        if bounding_box_sizing is not None:
            self.inputs.bounding_box_sizing.connect(bounding_box_sizing)
        if geometry_type is not None:
            self.inputs.geometry_type.connect(geometry_type)
        if shell_thickness_factor is not None:
            self.inputs.shell_thickness_factor.connect(shell_thickness_factor)

    @staticmethod
    def _spec():
        description = """Prepare mapping of source data from source mesh to target mesh by
            operating the source_mesh/target_mesh weights computation.
            This operator will use a point cloud based algorithm. This
            operator needs to be used with the apply mechanical native
            mapping associated one."""
        spec = Specification(
            description=description,
            map_input_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region", "field"],
                    optional=False,
                    document="""Source mesh. can be a meshed region or a node
        coordinates field.""",
                ),
                1: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region", "field"],
                    optional=False,
                    document="""Target mesh. can be a meshed region or a node
        coordinates field.""",
                ),
                3: PinSpecification(
                    name="target_mesh_scoping",
                    type_names=["scoping"],
                    optional=True,
                    document="""Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.""",
                ),
                4: PinSpecification(
                    name="unit",
                    type_names=["string"],
                    optional=True,
                    document="""Unit of the result to map""",
                ),
                5: PinSpecification(
                    name="location",
                    type_names=["string"],
                    optional=True,
                    document="""Location of the result to map. if elemental,
        this input needs to be specified.""",
                ),
                6: PinSpecification(
                    name="dimensionality",
                    type_names=["int32"],
                    optional=False,
                    document="""Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).""",
                ),
                7: PinSpecification(
                    name="e_shell_layers",
                    type_names=["int32"],
                    optional=True,
                    document="""Eshelllayers enum value if field has shell
        layers""",
                ),
                8: PinSpecification(
                    name="html_report_path",
                    type_names=["string"],
                    optional=True,
                    document="""Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.""",
                ),
                10: PinSpecification(
                    name="weighting_type",
                    type_names=["string"],
                    optional=True,
                    document="""Default 'triangulation'. can also be
        'weighted_average'.""",
                ),
                11: PinSpecification(
                    name="outside_option",
                    type_names=["string"],
                    optional=True,
                    document="""Default is 'weighted_average'. can also be
        'ignore', 'projection',
        'nearest_node'.""",
                ),
                12: PinSpecification(
                    name="num_outside_points",
                    type_names=["int32"],
                    optional=True,
                    document="""Default is 3""",
                ),
                13: PinSpecification(
                    name="max_outside_distance",
                    type_names=["double"],
                    optional=True,
                    document="""Default is 0.0""",
                ),
                14: PinSpecification(
                    name="search_limit",
                    type_names=["int32"],
                    optional=True,
                    document="""Default is 20""",
                ),
                15: PinSpecification(
                    name="bounding_box_sizing",
                    type_names=["double"],
                    optional=True,
                    document="""Pinball area. default is 0.0.""",
                ),
                16: PinSpecification(
                    name="geometry_type",
                    type_names=["string"],
                    optional=True,
                    document="""Default is 'volume'. can also be 'surface'.""",
                ),
                17: PinSpecification(
                    name="shell_thickness_factor",
                    type_names=["double"],
                    optional=True,
                    document="""Default is '0.0'""",
                ),
            },
            map_output_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="source_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Source mesh id""",
                ),
                2: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Target mesh""",
                ),
                3: PinSpecification(
                    name="target_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Target mesh id""",
                ),
                4: PinSpecification(
                    name="mapping_manager_data",
                    optional=False,
                    document="""""",
                ),
                6: PinSpecification(
                    name="target_scoping",
                    type_names=["scoping"],
                    optional=False,
                    document="""Target scoping""",
                ),
            },
        )
        return spec

    @staticmethod
    def default_config(server=None):
        """Returns the default config of the operator.

        This config can then be changed to the user needs and be used to
        instantiate the operator. The Configuration allows to customize
        how the operation will be processed by the operator.

        Parameters
        ----------
        server : server.DPFServer, optional
            Server with channel connected to the remote or local instance. When
            ``None``, attempts to use the global server.
        """
        return Operator.default_config(
            name="mechanical_native_mapping::prepare::point_cloud", server=server
        )

    @property
    def inputs(self):
        """Enables to connect inputs to the operator

        Returns
        --------
        inputs : InputsPrepareMechanicalNativeMappingPointCloud
        """
        return super().inputs

    @property
    def outputs(self):
        """Enables to get outputs of the operator by evaluating it

        Returns
        --------
        outputs : OutputsPrepareMechanicalNativeMappingPointCloud
        """
        return super().outputs


class InputsPrepareMechanicalNativeMappingPointCloud(_Inputs):
    """Intermediate class used to connect user inputs to
    prepare_mechanical_native_mapping_point_cloud operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_unit = str()
    >>> op.inputs.unit.connect(my_unit)
    >>> my_location = str()
    >>> op.inputs.location.connect(my_location)
    >>> my_dimensionality = int()
    >>> op.inputs.dimensionality.connect(my_dimensionality)
    >>> my_e_shell_layers = int()
    >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_weighting_type = str()
    >>> op.inputs.weighting_type.connect(my_weighting_type)
    >>> my_outside_option = str()
    >>> op.inputs.outside_option.connect(my_outside_option)
    >>> my_num_outside_points = int()
    >>> op.inputs.num_outside_points.connect(my_num_outside_points)
    >>> my_max_outside_distance = float()
    >>> op.inputs.max_outside_distance.connect(my_max_outside_distance)
    >>> my_search_limit = int()
    >>> op.inputs.search_limit.connect(my_search_limit)
    >>> my_bounding_box_sizing = float()
    >>> op.inputs.bounding_box_sizing.connect(my_bounding_box_sizing)
    >>> my_geometry_type = str()
    >>> op.inputs.geometry_type.connect(my_geometry_type)
    >>> my_shell_thickness_factor = float()
    >>> op.inputs.shell_thickness_factor.connect(my_shell_thickness_factor)
    """

    def __init__(self, op: Operator):
        super().__init__(
            prepare_mechanical_native_mapping_point_cloud._spec().inputs, op
        )
        self._source_mesh = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(0),
            0,
            op,
            -1,
        )
        self._inputs.append(self._source_mesh)
        self._target_mesh = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(1),
            1,
            op,
            -1,
        )
        self._inputs.append(self._target_mesh)
        self._target_mesh_scoping = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(3),
            3,
            op,
            -1,
        )
        self._inputs.append(self._target_mesh_scoping)
        self._unit = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(4),
            4,
            op,
            -1,
        )
        self._inputs.append(self._unit)
        self._location = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(5),
            5,
            op,
            -1,
        )
        self._inputs.append(self._location)
        self._dimensionality = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(6),
            6,
            op,
            -1,
        )
        self._inputs.append(self._dimensionality)
        self._e_shell_layers = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(7),
            7,
            op,
            -1,
        )
        self._inputs.append(self._e_shell_layers)
        self._html_report_path = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(8),
            8,
            op,
            -1,
        )
        self._inputs.append(self._html_report_path)
        self._weighting_type = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(10),
            10,
            op,
            -1,
        )
        self._inputs.append(self._weighting_type)
        self._outside_option = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(11),
            11,
            op,
            -1,
        )
        self._inputs.append(self._outside_option)
        self._num_outside_points = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(12),
            12,
            op,
            -1,
        )
        self._inputs.append(self._num_outside_points)
        self._max_outside_distance = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(13),
            13,
            op,
            -1,
        )
        self._inputs.append(self._max_outside_distance)
        self._search_limit = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(14),
            14,
            op,
            -1,
        )
        self._inputs.append(self._search_limit)
        self._bounding_box_sizing = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(15),
            15,
            op,
            -1,
        )
        self._inputs.append(self._bounding_box_sizing)
        self._geometry_type = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(16),
            16,
            op,
            -1,
        )
        self._inputs.append(self._geometry_type)
        self._shell_thickness_factor = Input(
            prepare_mechanical_native_mapping_point_cloud._spec().input_pin(17),
            17,
            op,
            -1,
        )
        self._inputs.append(self._shell_thickness_factor)

    @property
    def source_mesh(self):
        """Allows to connect source_mesh input to the operator.

        Source mesh. can be a meshed region or a node
        coordinates field.

        Parameters
        ----------
        my_source_mesh : MeshedRegion or Field

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.source_mesh.connect(my_source_mesh)
        >>> # or
        >>> op.inputs.source_mesh(my_source_mesh)
        """
        return self._source_mesh

    @property
    def target_mesh(self):
        """Allows to connect target_mesh input to the operator.

        Target mesh. can be a meshed region or a node
        coordinates field.

        Parameters
        ----------
        my_target_mesh : MeshedRegion or Field

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.target_mesh.connect(my_target_mesh)
        >>> # or
        >>> op.inputs.target_mesh(my_target_mesh)
        """
        return self._target_mesh

    @property
    def target_mesh_scoping(self):
        """Allows to connect target_mesh_scoping input to the operator.

        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.

        Parameters
        ----------
        my_target_mesh_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
        >>> # or
        >>> op.inputs.target_mesh_scoping(my_target_mesh_scoping)
        """
        return self._target_mesh_scoping

    @property
    def unit(self):
        """Allows to connect unit input to the operator.

        Unit of the result to map

        Parameters
        ----------
        my_unit : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.unit.connect(my_unit)
        >>> # or
        >>> op.inputs.unit(my_unit)
        """
        return self._unit

    @property
    def location(self):
        """Allows to connect location input to the operator.

        Location of the result to map. if elemental,
        this input needs to be specified.

        Parameters
        ----------
        my_location : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.location.connect(my_location)
        >>> # or
        >>> op.inputs.location(my_location)
        """
        return self._location

    @property
    def dimensionality(self):
        """Allows to connect dimensionality input to the operator.

        Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).

        Parameters
        ----------
        my_dimensionality : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.dimensionality.connect(my_dimensionality)
        >>> # or
        >>> op.inputs.dimensionality(my_dimensionality)
        """
        return self._dimensionality

    @property
    def e_shell_layers(self):
        """Allows to connect e_shell_layers input to the operator.

        Eshelllayers enum value if field has shell
        layers

        Parameters
        ----------
        my_e_shell_layers : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
        >>> # or
        >>> op.inputs.e_shell_layers(my_e_shell_layers)
        """
        return self._e_shell_layers

    @property
    def html_report_path(self):
        """Allows to connect html_report_path input to the operator.

        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.

        Parameters
        ----------
        my_html_report_path : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.html_report_path.connect(my_html_report_path)
        >>> # or
        >>> op.inputs.html_report_path(my_html_report_path)
        """
        return self._html_report_path

    @property
    def weighting_type(self):
        """Allows to connect weighting_type input to the operator.

        Default 'triangulation'. can also be
        'weighted_average'.

        Parameters
        ----------
        my_weighting_type : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.weighting_type.connect(my_weighting_type)
        >>> # or
        >>> op.inputs.weighting_type(my_weighting_type)
        """
        return self._weighting_type

    @property
    def outside_option(self):
        """Allows to connect outside_option input to the operator.

        Default is 'weighted_average'. can also be
        'ignore', 'projection',
        'nearest_node'.

        Parameters
        ----------
        my_outside_option : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.outside_option.connect(my_outside_option)
        >>> # or
        >>> op.inputs.outside_option(my_outside_option)
        """
        return self._outside_option

    @property
    def num_outside_points(self):
        """Allows to connect num_outside_points input to the operator.

        Default is 3

        Parameters
        ----------
        my_num_outside_points : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.num_outside_points.connect(my_num_outside_points)
        >>> # or
        >>> op.inputs.num_outside_points(my_num_outside_points)
        """
        return self._num_outside_points

    @property
    def max_outside_distance(self):
        """Allows to connect max_outside_distance input to the operator.

        Default is 0.0

        Parameters
        ----------
        my_max_outside_distance : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.max_outside_distance.connect(my_max_outside_distance)
        >>> # or
        >>> op.inputs.max_outside_distance(my_max_outside_distance)
        """
        return self._max_outside_distance

    @property
    def search_limit(self):
        """Allows to connect search_limit input to the operator.

        Default is 20

        Parameters
        ----------
        my_search_limit : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.search_limit.connect(my_search_limit)
        >>> # or
        >>> op.inputs.search_limit(my_search_limit)
        """
        return self._search_limit

    @property
    def bounding_box_sizing(self):
        """Allows to connect bounding_box_sizing input to the operator.

        Pinball area. default is 0.0.

        Parameters
        ----------
        my_bounding_box_sizing : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.bounding_box_sizing.connect(my_bounding_box_sizing)
        >>> # or
        >>> op.inputs.bounding_box_sizing(my_bounding_box_sizing)
        """
        return self._bounding_box_sizing

    @property
    def geometry_type(self):
        """Allows to connect geometry_type input to the operator.

        Default is 'volume'. can also be 'surface'.

        Parameters
        ----------
        my_geometry_type : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.geometry_type.connect(my_geometry_type)
        >>> # or
        >>> op.inputs.geometry_type(my_geometry_type)
        """
        return self._geometry_type

    @property
    def shell_thickness_factor(self):
        """Allows to connect shell_thickness_factor input to the operator.

        Default is '0.0'

        Parameters
        ----------
        my_shell_thickness_factor : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> op.inputs.shell_thickness_factor.connect(my_shell_thickness_factor)
        >>> # or
        >>> op.inputs.shell_thickness_factor(my_shell_thickness_factor)
        """
        return self._shell_thickness_factor


class OutputsPrepareMechanicalNativeMappingPointCloud(_Outputs):
    """Intermediate class used to get outputs from
    prepare_mechanical_native_mapping_point_cloud operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
    >>> # Connect inputs : op.inputs. ...
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(self, op: Operator):
        super().__init__(
            prepare_mechanical_native_mapping_point_cloud._spec().outputs, op
        )
        self._source_mesh = Output(
            prepare_mechanical_native_mapping_point_cloud._spec().output_pin(0), 0, op
        )
        self._outputs.append(self._source_mesh)
        self._source_mesh_id = Output(
            prepare_mechanical_native_mapping_point_cloud._spec().output_pin(1), 1, op
        )
        self._outputs.append(self._source_mesh_id)
        self._target_mesh = Output(
            prepare_mechanical_native_mapping_point_cloud._spec().output_pin(2), 2, op
        )
        self._outputs.append(self._target_mesh)
        self._target_mesh_id = Output(
            prepare_mechanical_native_mapping_point_cloud._spec().output_pin(3), 3, op
        )
        self._outputs.append(self._target_mesh_id)
        self._mapping_manager_data = Output(
            prepare_mechanical_native_mapping_point_cloud._spec().output_pin(4), 4, op
        )
        self._outputs.append(self._mapping_manager_data)
        self._target_scoping = Output(
            prepare_mechanical_native_mapping_point_cloud._spec().output_pin(6), 6, op
        )
        self._outputs.append(self._target_scoping)

    @property
    def source_mesh(self):
        """Allows to get source_mesh output of the operator

        Returns
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh = op.outputs.source_mesh()
        """  # noqa: E501
        return self._source_mesh

    @property
    def source_mesh_id(self):
        """Allows to get source_mesh_id output of the operator

        Returns
        ----------
        my_source_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh_id = op.outputs.source_mesh_id()
        """  # noqa: E501
        return self._source_mesh_id

    @property
    def target_mesh(self):
        """Allows to get target_mesh output of the operator

        Returns
        ----------
        my_target_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh = op.outputs.target_mesh()
        """  # noqa: E501
        return self._target_mesh

    @property
    def target_mesh_id(self):
        """Allows to get target_mesh_id output of the operator

        Returns
        ----------
        my_target_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh_id = op.outputs.target_mesh_id()
        """  # noqa: E501
        return self._target_mesh_id

    @property
    def mapping_manager_data(self):
        """Allows to get mapping_manager_data output of the operator

        Returns
        ----------
        my_mapping_manager_data :

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> # Connect inputs : op.inputs. ...
        >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
        """  # noqa: E501
        return self._mapping_manager_data

    @property
    def target_scoping(self):
        """Allows to get target_scoping output of the operator

        Returns
        ----------
        my_target_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_point_cloud()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_scoping = op.outputs.target_scoping()
        """  # noqa: E501
        return self._target_scoping

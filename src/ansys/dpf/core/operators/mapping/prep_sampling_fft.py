"""
prep_sampling_fft

Autogenerated DPF operator classes.
"""

from __future__ import annotations

from warnings import warn
from ansys.dpf.core.dpf_operator import Operator
from ansys.dpf.core.inputs import Input, _Inputs
from ansys.dpf.core.outputs import Output, _Outputs
from ansys.dpf.core.operators.specification import PinSpecification, Specification
from ansys.dpf.core.config import Config
from ansys.dpf.core.server_types import AnyServerType


class prep_sampling_fft(Operator):
    r"""Prepare time sampling optimum for FFT computation and expected
    frequencies in output.


    Parameters
    ----------
    time_freq_support: TimeFreqSupport
        Initial time domain TimeFreqSupport.
    cutoff_frequency: float, optional
        Cutoff Frequency. In this case, number of points is calculated computing (time_range * cutoff_freq * 2) and taking the next power of 2 (optimum for fft calculation).
    number_sampling_point: int, optional
        For number of sampling point (calculation with cutoff_frequency is ignored).

    Returns
    -------
    time_tfs_sampled: TimeFreqSupport
        Optimum sampled time domain TimeFreqSupport.
    freq_tfs_fft: TimeFreqSupport
        Frequency domain TimeFreqSupport expected in output of FFT.

    Examples
    --------
    >>> from ansys.dpf import core as dpf

    >>> # Instantiate operator
    >>> op = dpf.operators.mapping.prep_sampling_fft()

    >>> # Make input connections
    >>> my_time_freq_support = dpf.TimeFreqSupport()
    >>> op.inputs.time_freq_support.connect(my_time_freq_support)
    >>> my_cutoff_frequency = float()
    >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
    >>> my_number_sampling_point = int()
    >>> op.inputs.number_sampling_point.connect(my_number_sampling_point)

    >>> # Instantiate operator and connect inputs in one line
    >>> op = dpf.operators.mapping.prep_sampling_fft(
    ...     time_freq_support=my_time_freq_support,
    ...     cutoff_frequency=my_cutoff_frequency,
    ...     number_sampling_point=my_number_sampling_point,
    ... )

    >>> # Get output data
    >>> result_time_tfs_sampled = op.outputs.time_tfs_sampled()
    >>> result_freq_tfs_fft = op.outputs.freq_tfs_fft()
    """

    def __init__(
        self,
        time_freq_support=None,
        cutoff_frequency=None,
        number_sampling_point=None,
        config=None,
        server=None,
    ):
        super().__init__(name="prepare_sampling_fft", config=config, server=server)
        self._inputs = InputsPrepSamplingFft(self)
        self._outputs = OutputsPrepSamplingFft(self)
        if time_freq_support is not None:
            self.inputs.time_freq_support.connect(time_freq_support)
        if cutoff_frequency is not None:
            self.inputs.cutoff_frequency.connect(cutoff_frequency)
        if number_sampling_point is not None:
            self.inputs.number_sampling_point.connect(number_sampling_point)

    @staticmethod
    def _spec() -> Specification:
        description = r"""Prepare time sampling optimum for FFT computation and expected
frequencies in output.
"""
        spec = Specification(
            description=description,
            map_input_pin_spec={
                0: PinSpecification(
                    name="time_freq_support",
                    type_names=["time_freq_support"],
                    optional=False,
                    document=r"""Initial time domain TimeFreqSupport.""",
                ),
                1: PinSpecification(
                    name="cutoff_frequency",
                    type_names=["double"],
                    optional=True,
                    document=r"""Cutoff Frequency. In this case, number of points is calculated computing (time_range * cutoff_freq * 2) and taking the next power of 2 (optimum for fft calculation).""",
                ),
                2: PinSpecification(
                    name="number_sampling_point",
                    type_names=["int32"],
                    optional=True,
                    document=r"""For number of sampling point (calculation with cutoff_frequency is ignored).""",
                ),
            },
            map_output_pin_spec={
                0: PinSpecification(
                    name="time_tfs_sampled",
                    type_names=["time_freq_support"],
                    optional=False,
                    document=r"""Optimum sampled time domain TimeFreqSupport.""",
                ),
                1: PinSpecification(
                    name="freq_tfs_fft",
                    type_names=["time_freq_support"],
                    optional=False,
                    document=r"""Frequency domain TimeFreqSupport expected in output of FFT.""",
                ),
            },
        )
        return spec

    @staticmethod
    def default_config(server: AnyServerType = None) -> Config:
        """Returns the default config of the operator.

        This config can then be changed to the user needs and be used to
        instantiate the operator. The Configuration allows to customize
        how the operation will be processed by the operator.

        Parameters
        ----------
        server:
            Server with channel connected to the remote or local instance. When
            ``None``, attempts to use the global server.

        Returns
        -------
        config:
            A new Config instance equivalent to the default config for this operator.
        """
        return Operator.default_config(name="prepare_sampling_fft", server=server)

    @property
    def inputs(self) -> InputsPrepSamplingFft:
        """Enables to connect inputs to the operator

        Returns
        --------
        inputs:
            An instance of InputsPrepSamplingFft.
        """
        return super().inputs

    @property
    def outputs(self) -> OutputsPrepSamplingFft:
        """Enables to get outputs of the operator by evaluating it

        Returns
        --------
        outputs:
            An instance of OutputsPrepSamplingFft.
        """
        return super().outputs


class InputsPrepSamplingFft(_Inputs):
    """Intermediate class used to connect user inputs to
    prep_sampling_fft operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prep_sampling_fft()
    >>> my_time_freq_support = dpf.TimeFreqSupport()
    >>> op.inputs.time_freq_support.connect(my_time_freq_support)
    >>> my_cutoff_frequency = float()
    >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
    >>> my_number_sampling_point = int()
    >>> op.inputs.number_sampling_point.connect(my_number_sampling_point)
    """

    def __init__(self, op: Operator):
        super().__init__(prep_sampling_fft._spec().inputs, op)
        self._time_freq_support = Input(
            prep_sampling_fft._spec().input_pin(0), 0, op, -1
        )
        self._inputs.append(self._time_freq_support)
        self._cutoff_frequency = Input(
            prep_sampling_fft._spec().input_pin(1), 1, op, -1
        )
        self._inputs.append(self._cutoff_frequency)
        self._number_sampling_point = Input(
            prep_sampling_fft._spec().input_pin(2), 2, op, -1
        )
        self._inputs.append(self._number_sampling_point)

    @property
    def time_freq_support(self) -> Input:
        r"""Allows to connect time_freq_support input to the operator.

        Initial time domain TimeFreqSupport.

        Returns
        -------
        input:
            An Input instance for this pin.

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prep_sampling_fft()
        >>> op.inputs.time_freq_support.connect(my_time_freq_support)
        >>> # or
        >>> op.inputs.time_freq_support(my_time_freq_support)
        """
        return self._time_freq_support

    @property
    def cutoff_frequency(self) -> Input:
        r"""Allows to connect cutoff_frequency input to the operator.

        Cutoff Frequency. In this case, number of points is calculated computing (time_range * cutoff_freq * 2) and taking the next power of 2 (optimum for fft calculation).

        Returns
        -------
        input:
            An Input instance for this pin.

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prep_sampling_fft()
        >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
        >>> # or
        >>> op.inputs.cutoff_frequency(my_cutoff_frequency)
        """
        return self._cutoff_frequency

    @property
    def number_sampling_point(self) -> Input:
        r"""Allows to connect number_sampling_point input to the operator.

        For number of sampling point (calculation with cutoff_frequency is ignored).

        Returns
        -------
        input:
            An Input instance for this pin.

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prep_sampling_fft()
        >>> op.inputs.number_sampling_point.connect(my_number_sampling_point)
        >>> # or
        >>> op.inputs.number_sampling_point(my_number_sampling_point)
        """
        return self._number_sampling_point


class OutputsPrepSamplingFft(_Outputs):
    """Intermediate class used to get outputs from
    prep_sampling_fft operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prep_sampling_fft()
    >>> # Connect inputs : op.inputs. ...
    >>> result_time_tfs_sampled = op.outputs.time_tfs_sampled()
    >>> result_freq_tfs_fft = op.outputs.freq_tfs_fft()
    """

    def __init__(self, op: Operator):
        super().__init__(prep_sampling_fft._spec().outputs, op)
        self._time_tfs_sampled = Output(prep_sampling_fft._spec().output_pin(0), 0, op)
        self._outputs.append(self._time_tfs_sampled)
        self._freq_tfs_fft = Output(prep_sampling_fft._spec().output_pin(1), 1, op)
        self._outputs.append(self._freq_tfs_fft)

    @property
    def time_tfs_sampled(self) -> Output:
        r"""Allows to get time_tfs_sampled output of the operator

        Optimum sampled time domain TimeFreqSupport.

        Returns
        -------
        output:
            An Output instance for this pin.

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prep_sampling_fft()
        >>> # Get the output from op.outputs. ...
        >>> result_time_tfs_sampled = op.outputs.time_tfs_sampled()
        """
        return self._time_tfs_sampled

    @property
    def freq_tfs_fft(self) -> Output:
        r"""Allows to get freq_tfs_fft output of the operator

        Frequency domain TimeFreqSupport expected in output of FFT.

        Returns
        -------
        output:
            An Output instance for this pin.

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prep_sampling_fft()
        >>> # Get the output from op.outputs. ...
        >>> result_freq_tfs_fft = op.outputs.freq_tfs_fft()
        """
        return self._freq_tfs_fft

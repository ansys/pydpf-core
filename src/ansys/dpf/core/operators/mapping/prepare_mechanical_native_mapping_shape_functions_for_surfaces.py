"""
prepare_mechanical_native_mapping_shape_functions_for_surfaces
==============================================================
Autogenerated DPF operator classes.
"""
from warnings import warn
from ansys.dpf.core.dpf_operator import Operator
from ansys.dpf.core.inputs import Input, _Inputs
from ansys.dpf.core.outputs import Output, _Outputs
from ansys.dpf.core.operators.specification import PinSpecification, Specification


class prepare_mechanical_native_mapping_shape_functions_for_surfaces(Operator):
    """Prepare mapping of source data from source mesh to target mesh by
    operating the source_mesh/target_mesh weights computation. This
    operator will use the shape functions of the elements. This
    operator is meant for surfaces elements. This operator needs to be
    used with the apply mechanical native mapping associated one.

    Parameters
    ----------
    source_mesh : MeshedRegion
        Source mesh
    target_mesh : MeshedRegion
        Target mesh
    target_mesh_scoping : Scoping, optional
        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.
    unit : str, optional
        Unit of the result to map
    location : str
        Location of the result to map
    dimensionality : int
        Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).
    e_shell_layers : int, optional
        Eshelllayers enum value if field has shell
        layers
    html_report_path : str, optional
        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.
    scale : int, optional
        Default is 50
    edge_tolerance : float, optional
        Default is 0.02
    conservative : bool, optional
        Default is false
    ignore_outside_nodes : bool, optional
        Default is false
    key : str, optional
        Can be 'absolute' or 'relative'. default is
        'relative'
    normal_distance_check : bool, optional
        Default is false
    normal_tolerance : float, optional
        Default is 1e-6
    pinball_control : bool, optional
        Default is false
    pinball_key : str, optional
        Can be 'absolute' or 'relative'. default is
        'absolute'
    exclude_elements_outside_pinball : bool, optional
        Default is false
    pinball_value : float, optional
        Default is 0.0


    Examples
    --------
    >>> from ansys.dpf import core as dpf

    >>> # Instantiate operator
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()

    >>> # Make input connections
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_unit = str()
    >>> op.inputs.unit.connect(my_unit)
    >>> my_location = str()
    >>> op.inputs.location.connect(my_location)
    >>> my_dimensionality = int()
    >>> op.inputs.dimensionality.connect(my_dimensionality)
    >>> my_e_shell_layers = int()
    >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_scale = int()
    >>> op.inputs.scale.connect(my_scale)
    >>> my_edge_tolerance = float()
    >>> op.inputs.edge_tolerance.connect(my_edge_tolerance)
    >>> my_conservative = bool()
    >>> op.inputs.conservative.connect(my_conservative)
    >>> my_ignore_outside_nodes = bool()
    >>> op.inputs.ignore_outside_nodes.connect(my_ignore_outside_nodes)
    >>> my_key = str()
    >>> op.inputs.key.connect(my_key)
    >>> my_normal_distance_check = bool()
    >>> op.inputs.normal_distance_check.connect(my_normal_distance_check)
    >>> my_normal_tolerance = float()
    >>> op.inputs.normal_tolerance.connect(my_normal_tolerance)
    >>> my_pinball_control = bool()
    >>> op.inputs.pinball_control.connect(my_pinball_control)
    >>> my_pinball_key = str()
    >>> op.inputs.pinball_key.connect(my_pinball_key)
    >>> my_exclude_elements_outside_pinball = bool()
    >>> op.inputs.exclude_elements_outside_pinball.connect(my_exclude_elements_outside_pinball)
    >>> my_pinball_value = float()
    >>> op.inputs.pinball_value.connect(my_pinball_value)

    >>> # Instantiate operator and connect inputs in one line
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces(
    ...     source_mesh=my_source_mesh,
    ...     target_mesh=my_target_mesh,
    ...     target_mesh_scoping=my_target_mesh_scoping,
    ...     unit=my_unit,
    ...     location=my_location,
    ...     dimensionality=my_dimensionality,
    ...     e_shell_layers=my_e_shell_layers,
    ...     html_report_path=my_html_report_path,
    ...     scale=my_scale,
    ...     edge_tolerance=my_edge_tolerance,
    ...     conservative=my_conservative,
    ...     ignore_outside_nodes=my_ignore_outside_nodes,
    ...     key=my_key,
    ...     normal_distance_check=my_normal_distance_check,
    ...     normal_tolerance=my_normal_tolerance,
    ...     pinball_control=my_pinball_control,
    ...     pinball_key=my_pinball_key,
    ...     exclude_elements_outside_pinball=my_exclude_elements_outside_pinball,
    ...     pinball_value=my_pinball_value,
    ... )

    >>> # Get output data
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(
        self,
        source_mesh=None,
        target_mesh=None,
        target_mesh_scoping=None,
        unit=None,
        location=None,
        dimensionality=None,
        e_shell_layers=None,
        html_report_path=None,
        scale=None,
        edge_tolerance=None,
        conservative=None,
        ignore_outside_nodes=None,
        key=None,
        normal_distance_check=None,
        normal_tolerance=None,
        pinball_control=None,
        pinball_key=None,
        exclude_elements_outside_pinball=None,
        pinball_value=None,
        config=None,
        server=None,
    ):
        super().__init__(
            name="mechanical_native_mapping::prepare::shape_function_surfaces",
            config=config,
            server=server,
        )
        self._inputs = InputsPrepareMechanicalNativeMappingShapeFunctionsForSurfaces(
            self
        )
        self._outputs = OutputsPrepareMechanicalNativeMappingShapeFunctionsForSurfaces(
            self
        )
        if source_mesh is not None:
            self.inputs.source_mesh.connect(source_mesh)
        if target_mesh is not None:
            self.inputs.target_mesh.connect(target_mesh)
        if target_mesh_scoping is not None:
            self.inputs.target_mesh_scoping.connect(target_mesh_scoping)
        if unit is not None:
            self.inputs.unit.connect(unit)
        if location is not None:
            self.inputs.location.connect(location)
        if dimensionality is not None:
            self.inputs.dimensionality.connect(dimensionality)
        if e_shell_layers is not None:
            self.inputs.e_shell_layers.connect(e_shell_layers)
        if html_report_path is not None:
            self.inputs.html_report_path.connect(html_report_path)
        if scale is not None:
            self.inputs.scale.connect(scale)
        if edge_tolerance is not None:
            self.inputs.edge_tolerance.connect(edge_tolerance)
        if conservative is not None:
            self.inputs.conservative.connect(conservative)
        if ignore_outside_nodes is not None:
            self.inputs.ignore_outside_nodes.connect(ignore_outside_nodes)
        if key is not None:
            self.inputs.key.connect(key)
        if normal_distance_check is not None:
            self.inputs.normal_distance_check.connect(normal_distance_check)
        if normal_tolerance is not None:
            self.inputs.normal_tolerance.connect(normal_tolerance)
        if pinball_control is not None:
            self.inputs.pinball_control.connect(pinball_control)
        if pinball_key is not None:
            self.inputs.pinball_key.connect(pinball_key)
        if exclude_elements_outside_pinball is not None:
            self.inputs.exclude_elements_outside_pinball.connect(
                exclude_elements_outside_pinball
            )
        if pinball_value is not None:
            self.inputs.pinball_value.connect(pinball_value)

    @staticmethod
    def _spec():
        description = """Prepare mapping of source data from source mesh to target mesh by
            operating the source_mesh/target_mesh weights computation.
            This operator will use the shape functions of the
            elements. This operator is meant for surfaces elements.
            This operator needs to be used with the apply mechanical
            native mapping associated one."""
        spec = Specification(
            description=description,
            map_input_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Target mesh""",
                ),
                3: PinSpecification(
                    name="target_mesh_scoping",
                    type_names=["scoping"],
                    optional=True,
                    document="""Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.""",
                ),
                4: PinSpecification(
                    name="unit",
                    type_names=["string"],
                    optional=True,
                    document="""Unit of the result to map""",
                ),
                5: PinSpecification(
                    name="location",
                    type_names=["string"],
                    optional=False,
                    document="""Location of the result to map""",
                ),
                6: PinSpecification(
                    name="dimensionality",
                    type_names=["int32"],
                    optional=False,
                    document="""Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).""",
                ),
                7: PinSpecification(
                    name="e_shell_layers",
                    type_names=["int32"],
                    optional=True,
                    document="""Eshelllayers enum value if field has shell
        layers""",
                ),
                8: PinSpecification(
                    name="html_report_path",
                    type_names=["string"],
                    optional=True,
                    document="""Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.""",
                ),
                10: PinSpecification(
                    name="scale",
                    type_names=["int32"],
                    optional=True,
                    document="""Default is 50""",
                ),
                11: PinSpecification(
                    name="edge_tolerance",
                    type_names=["double"],
                    optional=True,
                    document="""Default is 0.02""",
                ),
                12: PinSpecification(
                    name="conservative",
                    type_names=["bool"],
                    optional=True,
                    document="""Default is false""",
                ),
                13: PinSpecification(
                    name="ignore_outside_nodes",
                    type_names=["bool"],
                    optional=True,
                    document="""Default is false""",
                ),
                14: PinSpecification(
                    name="key",
                    type_names=["string"],
                    optional=True,
                    document="""Can be 'absolute' or 'relative'. default is
        'relative'""",
                ),
                15: PinSpecification(
                    name="normal_distance_check",
                    type_names=["bool"],
                    optional=True,
                    document="""Default is false""",
                ),
                16: PinSpecification(
                    name="normal_tolerance",
                    type_names=["double"],
                    optional=True,
                    document="""Default is 1e-6""",
                ),
                17: PinSpecification(
                    name="pinball_control",
                    type_names=["bool"],
                    optional=True,
                    document="""Default is false""",
                ),
                18: PinSpecification(
                    name="pinball_key",
                    type_names=["string"],
                    optional=True,
                    document="""Can be 'absolute' or 'relative'. default is
        'absolute'""",
                ),
                19: PinSpecification(
                    name="exclude_elements_outside_pinball",
                    type_names=["bool"],
                    optional=True,
                    document="""Default is false""",
                ),
                20: PinSpecification(
                    name="pinball_value",
                    type_names=["double"],
                    optional=True,
                    document="""Default is 0.0""",
                ),
            },
            map_output_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="source_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Source mesh id""",
                ),
                2: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Target mesh""",
                ),
                3: PinSpecification(
                    name="target_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Target mesh id""",
                ),
                4: PinSpecification(
                    name="mapping_manager_data",
                    optional=False,
                    document="""""",
                ),
                6: PinSpecification(
                    name="target_scoping",
                    type_names=["scoping"],
                    optional=False,
                    document="""Target scoping""",
                ),
            },
        )
        return spec

    @staticmethod
    def default_config(server=None):
        """Returns the default config of the operator.

        This config can then be changed to the user needs and be used to
        instantiate the operator. The Configuration allows to customize
        how the operation will be processed by the operator.

        Parameters
        ----------
        server : server.DPFServer, optional
            Server with channel connected to the remote or local instance. When
            ``None``, attempts to use the global server.
        """
        return Operator.default_config(
            name="mechanical_native_mapping::prepare::shape_function_surfaces",
            server=server,
        )

    @property
    def inputs(self):
        """Enables to connect inputs to the operator

        Returns
        --------
        inputs : InputsPrepareMechanicalNativeMappingShapeFunctionsForSurfaces
        """
        return super().inputs

    @property
    def outputs(self):
        """Enables to get outputs of the operator by evaluating it

        Returns
        --------
        outputs : OutputsPrepareMechanicalNativeMappingShapeFunctionsForSurfaces
        """
        return super().outputs


class InputsPrepareMechanicalNativeMappingShapeFunctionsForSurfaces(_Inputs):
    """Intermediate class used to connect user inputs to
    prepare_mechanical_native_mapping_shape_functions_for_surfaces operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_unit = str()
    >>> op.inputs.unit.connect(my_unit)
    >>> my_location = str()
    >>> op.inputs.location.connect(my_location)
    >>> my_dimensionality = int()
    >>> op.inputs.dimensionality.connect(my_dimensionality)
    >>> my_e_shell_layers = int()
    >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_scale = int()
    >>> op.inputs.scale.connect(my_scale)
    >>> my_edge_tolerance = float()
    >>> op.inputs.edge_tolerance.connect(my_edge_tolerance)
    >>> my_conservative = bool()
    >>> op.inputs.conservative.connect(my_conservative)
    >>> my_ignore_outside_nodes = bool()
    >>> op.inputs.ignore_outside_nodes.connect(my_ignore_outside_nodes)
    >>> my_key = str()
    >>> op.inputs.key.connect(my_key)
    >>> my_normal_distance_check = bool()
    >>> op.inputs.normal_distance_check.connect(my_normal_distance_check)
    >>> my_normal_tolerance = float()
    >>> op.inputs.normal_tolerance.connect(my_normal_tolerance)
    >>> my_pinball_control = bool()
    >>> op.inputs.pinball_control.connect(my_pinball_control)
    >>> my_pinball_key = str()
    >>> op.inputs.pinball_key.connect(my_pinball_key)
    >>> my_exclude_elements_outside_pinball = bool()
    >>> op.inputs.exclude_elements_outside_pinball.connect(my_exclude_elements_outside_pinball)
    >>> my_pinball_value = float()
    >>> op.inputs.pinball_value.connect(my_pinball_value)
    """

    def __init__(self, op: Operator):
        super().__init__(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().inputs,
            op,
        )
        self._source_mesh = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                0
            ),
            0,
            op,
            -1,
        )
        self._inputs.append(self._source_mesh)
        self._target_mesh = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                1
            ),
            1,
            op,
            -1,
        )
        self._inputs.append(self._target_mesh)
        self._target_mesh_scoping = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                3
            ),
            3,
            op,
            -1,
        )
        self._inputs.append(self._target_mesh_scoping)
        self._unit = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                4
            ),
            4,
            op,
            -1,
        )
        self._inputs.append(self._unit)
        self._location = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                5
            ),
            5,
            op,
            -1,
        )
        self._inputs.append(self._location)
        self._dimensionality = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                6
            ),
            6,
            op,
            -1,
        )
        self._inputs.append(self._dimensionality)
        self._e_shell_layers = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                7
            ),
            7,
            op,
            -1,
        )
        self._inputs.append(self._e_shell_layers)
        self._html_report_path = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                8
            ),
            8,
            op,
            -1,
        )
        self._inputs.append(self._html_report_path)
        self._scale = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                10
            ),
            10,
            op,
            -1,
        )
        self._inputs.append(self._scale)
        self._edge_tolerance = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                11
            ),
            11,
            op,
            -1,
        )
        self._inputs.append(self._edge_tolerance)
        self._conservative = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                12
            ),
            12,
            op,
            -1,
        )
        self._inputs.append(self._conservative)
        self._ignore_outside_nodes = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                13
            ),
            13,
            op,
            -1,
        )
        self._inputs.append(self._ignore_outside_nodes)
        self._key = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                14
            ),
            14,
            op,
            -1,
        )
        self._inputs.append(self._key)
        self._normal_distance_check = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                15
            ),
            15,
            op,
            -1,
        )
        self._inputs.append(self._normal_distance_check)
        self._normal_tolerance = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                16
            ),
            16,
            op,
            -1,
        )
        self._inputs.append(self._normal_tolerance)
        self._pinball_control = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                17
            ),
            17,
            op,
            -1,
        )
        self._inputs.append(self._pinball_control)
        self._pinball_key = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                18
            ),
            18,
            op,
            -1,
        )
        self._inputs.append(self._pinball_key)
        self._exclude_elements_outside_pinball = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                19
            ),
            19,
            op,
            -1,
        )
        self._inputs.append(self._exclude_elements_outside_pinball)
        self._pinball_value = Input(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().input_pin(
                20
            ),
            20,
            op,
            -1,
        )
        self._inputs.append(self._pinball_value)

    @property
    def source_mesh(self):
        """Allows to connect source_mesh input to the operator.

        Source mesh

        Parameters
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.source_mesh.connect(my_source_mesh)
        >>> # or
        >>> op.inputs.source_mesh(my_source_mesh)
        """
        return self._source_mesh

    @property
    def target_mesh(self):
        """Allows to connect target_mesh input to the operator.

        Target mesh

        Parameters
        ----------
        my_target_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.target_mesh.connect(my_target_mesh)
        >>> # or
        >>> op.inputs.target_mesh(my_target_mesh)
        """
        return self._target_mesh

    @property
    def target_mesh_scoping(self):
        """Allows to connect target_mesh_scoping input to the operator.

        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.

        Parameters
        ----------
        my_target_mesh_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
        >>> # or
        >>> op.inputs.target_mesh_scoping(my_target_mesh_scoping)
        """
        return self._target_mesh_scoping

    @property
    def unit(self):
        """Allows to connect unit input to the operator.

        Unit of the result to map

        Parameters
        ----------
        my_unit : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.unit.connect(my_unit)
        >>> # or
        >>> op.inputs.unit(my_unit)
        """
        return self._unit

    @property
    def location(self):
        """Allows to connect location input to the operator.

        Location of the result to map

        Parameters
        ----------
        my_location : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.location.connect(my_location)
        >>> # or
        >>> op.inputs.location(my_location)
        """
        return self._location

    @property
    def dimensionality(self):
        """Allows to connect dimensionality input to the operator.

        Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).

        Parameters
        ----------
        my_dimensionality : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.dimensionality.connect(my_dimensionality)
        >>> # or
        >>> op.inputs.dimensionality(my_dimensionality)
        """
        return self._dimensionality

    @property
    def e_shell_layers(self):
        """Allows to connect e_shell_layers input to the operator.

        Eshelllayers enum value if field has shell
        layers

        Parameters
        ----------
        my_e_shell_layers : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
        >>> # or
        >>> op.inputs.e_shell_layers(my_e_shell_layers)
        """
        return self._e_shell_layers

    @property
    def html_report_path(self):
        """Allows to connect html_report_path input to the operator.

        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.

        Parameters
        ----------
        my_html_report_path : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.html_report_path.connect(my_html_report_path)
        >>> # or
        >>> op.inputs.html_report_path(my_html_report_path)
        """
        return self._html_report_path

    @property
    def scale(self):
        """Allows to connect scale input to the operator.

        Default is 50

        Parameters
        ----------
        my_scale : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.scale.connect(my_scale)
        >>> # or
        >>> op.inputs.scale(my_scale)
        """
        return self._scale

    @property
    def edge_tolerance(self):
        """Allows to connect edge_tolerance input to the operator.

        Default is 0.02

        Parameters
        ----------
        my_edge_tolerance : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.edge_tolerance.connect(my_edge_tolerance)
        >>> # or
        >>> op.inputs.edge_tolerance(my_edge_tolerance)
        """
        return self._edge_tolerance

    @property
    def conservative(self):
        """Allows to connect conservative input to the operator.

        Default is false

        Parameters
        ----------
        my_conservative : bool

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.conservative.connect(my_conservative)
        >>> # or
        >>> op.inputs.conservative(my_conservative)
        """
        return self._conservative

    @property
    def ignore_outside_nodes(self):
        """Allows to connect ignore_outside_nodes input to the operator.

        Default is false

        Parameters
        ----------
        my_ignore_outside_nodes : bool

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.ignore_outside_nodes.connect(my_ignore_outside_nodes)
        >>> # or
        >>> op.inputs.ignore_outside_nodes(my_ignore_outside_nodes)
        """
        return self._ignore_outside_nodes

    @property
    def key(self):
        """Allows to connect key input to the operator.

        Can be 'absolute' or 'relative'. default is
        'relative'

        Parameters
        ----------
        my_key : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.key.connect(my_key)
        >>> # or
        >>> op.inputs.key(my_key)
        """
        return self._key

    @property
    def normal_distance_check(self):
        """Allows to connect normal_distance_check input to the operator.

        Default is false

        Parameters
        ----------
        my_normal_distance_check : bool

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.normal_distance_check.connect(my_normal_distance_check)
        >>> # or
        >>> op.inputs.normal_distance_check(my_normal_distance_check)
        """
        return self._normal_distance_check

    @property
    def normal_tolerance(self):
        """Allows to connect normal_tolerance input to the operator.

        Default is 1e-6

        Parameters
        ----------
        my_normal_tolerance : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.normal_tolerance.connect(my_normal_tolerance)
        >>> # or
        >>> op.inputs.normal_tolerance(my_normal_tolerance)
        """
        return self._normal_tolerance

    @property
    def pinball_control(self):
        """Allows to connect pinball_control input to the operator.

        Default is false

        Parameters
        ----------
        my_pinball_control : bool

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.pinball_control.connect(my_pinball_control)
        >>> # or
        >>> op.inputs.pinball_control(my_pinball_control)
        """
        return self._pinball_control

    @property
    def pinball_key(self):
        """Allows to connect pinball_key input to the operator.

        Can be 'absolute' or 'relative'. default is
        'absolute'

        Parameters
        ----------
        my_pinball_key : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.pinball_key.connect(my_pinball_key)
        >>> # or
        >>> op.inputs.pinball_key(my_pinball_key)
        """
        return self._pinball_key

    @property
    def exclude_elements_outside_pinball(self):
        """Allows to connect exclude_elements_outside_pinball input to the operator.

        Default is false

        Parameters
        ----------
        my_exclude_elements_outside_pinball : bool

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.exclude_elements_outside_pinball.connect(my_exclude_elements_outside_pinball)
        >>> # or
        >>> op.inputs.exclude_elements_outside_pinball(my_exclude_elements_outside_pinball)
        """
        return self._exclude_elements_outside_pinball

    @property
    def pinball_value(self):
        """Allows to connect pinball_value input to the operator.

        Default is 0.0

        Parameters
        ----------
        my_pinball_value : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> op.inputs.pinball_value.connect(my_pinball_value)
        >>> # or
        >>> op.inputs.pinball_value(my_pinball_value)
        """
        return self._pinball_value


class OutputsPrepareMechanicalNativeMappingShapeFunctionsForSurfaces(_Outputs):
    """Intermediate class used to get outputs from
    prepare_mechanical_native_mapping_shape_functions_for_surfaces operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
    >>> # Connect inputs : op.inputs. ...
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(self, op: Operator):
        super().__init__(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().outputs,
            op,
        )
        self._source_mesh = Output(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().output_pin(
                0
            ),
            0,
            op,
        )
        self._outputs.append(self._source_mesh)
        self._source_mesh_id = Output(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().output_pin(
                1
            ),
            1,
            op,
        )
        self._outputs.append(self._source_mesh_id)
        self._target_mesh = Output(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().output_pin(
                2
            ),
            2,
            op,
        )
        self._outputs.append(self._target_mesh)
        self._target_mesh_id = Output(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().output_pin(
                3
            ),
            3,
            op,
        )
        self._outputs.append(self._target_mesh_id)
        self._mapping_manager_data = Output(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().output_pin(
                4
            ),
            4,
            op,
        )
        self._outputs.append(self._mapping_manager_data)
        self._target_scoping = Output(
            prepare_mechanical_native_mapping_shape_functions_for_surfaces._spec().output_pin(
                6
            ),
            6,
            op,
        )
        self._outputs.append(self._target_scoping)

    @property
    def source_mesh(self):
        """Allows to get source_mesh output of the operator

        Returns
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh = op.outputs.source_mesh()
        """  # noqa: E501
        return self._source_mesh

    @property
    def source_mesh_id(self):
        """Allows to get source_mesh_id output of the operator

        Returns
        ----------
        my_source_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh_id = op.outputs.source_mesh_id()
        """  # noqa: E501
        return self._source_mesh_id

    @property
    def target_mesh(self):
        """Allows to get target_mesh output of the operator

        Returns
        ----------
        my_target_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh = op.outputs.target_mesh()
        """  # noqa: E501
        return self._target_mesh

    @property
    def target_mesh_id(self):
        """Allows to get target_mesh_id output of the operator

        Returns
        ----------
        my_target_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh_id = op.outputs.target_mesh_id()
        """  # noqa: E501
        return self._target_mesh_id

    @property
    def mapping_manager_data(self):
        """Allows to get mapping_manager_data output of the operator

        Returns
        ----------
        my_mapping_manager_data :

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> # Connect inputs : op.inputs. ...
        >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
        """  # noqa: E501
        return self._mapping_manager_data

    @property
    def target_scoping(self):
        """Allows to get target_scoping output of the operator

        Returns
        ----------
        my_target_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_shape_functions_for_surfaces()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_scoping = op.outputs.target_scoping()
        """  # noqa: E501
        return self._target_scoping

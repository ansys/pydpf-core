"""
prepare_mechanical_native_mapping_kriging
=========================================
Autogenerated DPF operator classes.
"""
from warnings import warn
from ansys.dpf.core.dpf_operator import Operator
from ansys.dpf.core.inputs import Input, _Inputs
from ansys.dpf.core.outputs import Output, _Outputs
from ansys.dpf.core.operators.specification import PinSpecification, Specification


class prepare_mechanical_native_mapping_kriging(Operator):
    """Prepare mapping of source data from source mesh to target mesh by
    operating the source_mesh/target_mesh weights computation. This
    operator will use a point kriging algorithm. This operator needs
    to be used with the apply mechanical native mapping associated
    one.

    Parameters
    ----------
    source_mesh : MeshedRegion
        Source mesh
    target_mesh : MeshedRegion
        Target mesh
    target_mesh_scoping : Scoping, optional
        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.
    unit : str, optional
        Unit of the result to map
    location : str
        Location of the result to map
    dimensionality : int
        Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).
    e_shell_layers : int, optional
        Eshelllayers enum value if field has shell
        layers
    html_report_path : str, optional
        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.
    samples_limit : int, optional
        Default is 20
    correlation_function_type : str, optional
        Default is 'gaussian'. can also be
        'exponential', 'linear', 'none',
        'spherical', 'cubic',
        'multi_quadratic',
        'thin_plate_spline'.
    polynomial_type : str, optional
        Default is 'adaptive'. can also be
        'pure_quadratic', 'linear',
        'constant', 'none'.
    outside_distance_checking : bool, optional
        Default is false
    bounding_box_tolerance : float, optional
        Default is 0.0
    adaptive_tolerance_percent : float, optional
        Default is 0.1 (corresponds to 10%)
    geometry_type : str, optional
        Default is 'volume'. can also be 'surface'.


    Examples
    --------
    >>> from ansys.dpf import core as dpf

    >>> # Instantiate operator
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()

    >>> # Make input connections
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_unit = str()
    >>> op.inputs.unit.connect(my_unit)
    >>> my_location = str()
    >>> op.inputs.location.connect(my_location)
    >>> my_dimensionality = int()
    >>> op.inputs.dimensionality.connect(my_dimensionality)
    >>> my_e_shell_layers = int()
    >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_samples_limit = int()
    >>> op.inputs.samples_limit.connect(my_samples_limit)
    >>> my_correlation_function_type = str()
    >>> op.inputs.correlation_function_type.connect(my_correlation_function_type)
    >>> my_polynomial_type = str()
    >>> op.inputs.polynomial_type.connect(my_polynomial_type)
    >>> my_outside_distance_checking = bool()
    >>> op.inputs.outside_distance_checking.connect(my_outside_distance_checking)
    >>> my_bounding_box_tolerance = float()
    >>> op.inputs.bounding_box_tolerance.connect(my_bounding_box_tolerance)
    >>> my_adaptive_tolerance_percent = float()
    >>> op.inputs.adaptive_tolerance_percent.connect(my_adaptive_tolerance_percent)
    >>> my_geometry_type = str()
    >>> op.inputs.geometry_type.connect(my_geometry_type)

    >>> # Instantiate operator and connect inputs in one line
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging(
    ...     source_mesh=my_source_mesh,
    ...     target_mesh=my_target_mesh,
    ...     target_mesh_scoping=my_target_mesh_scoping,
    ...     unit=my_unit,
    ...     location=my_location,
    ...     dimensionality=my_dimensionality,
    ...     e_shell_layers=my_e_shell_layers,
    ...     html_report_path=my_html_report_path,
    ...     samples_limit=my_samples_limit,
    ...     correlation_function_type=my_correlation_function_type,
    ...     polynomial_type=my_polynomial_type,
    ...     outside_distance_checking=my_outside_distance_checking,
    ...     bounding_box_tolerance=my_bounding_box_tolerance,
    ...     adaptive_tolerance_percent=my_adaptive_tolerance_percent,
    ...     geometry_type=my_geometry_type,
    ... )

    >>> # Get output data
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(
        self,
        source_mesh=None,
        target_mesh=None,
        target_mesh_scoping=None,
        unit=None,
        location=None,
        dimensionality=None,
        e_shell_layers=None,
        html_report_path=None,
        samples_limit=None,
        correlation_function_type=None,
        polynomial_type=None,
        outside_distance_checking=None,
        bounding_box_tolerance=None,
        adaptive_tolerance_percent=None,
        geometry_type=None,
        config=None,
        server=None,
    ):
        super().__init__(
            name="mechanical_native_mapping::prepare::kriging",
            config=config,
            server=server,
        )
        self._inputs = InputsPrepareMechanicalNativeMappingKriging(self)
        self._outputs = OutputsPrepareMechanicalNativeMappingKriging(self)
        if source_mesh is not None:
            self.inputs.source_mesh.connect(source_mesh)
        if target_mesh is not None:
            self.inputs.target_mesh.connect(target_mesh)
        if target_mesh_scoping is not None:
            self.inputs.target_mesh_scoping.connect(target_mesh_scoping)
        if unit is not None:
            self.inputs.unit.connect(unit)
        if location is not None:
            self.inputs.location.connect(location)
        if dimensionality is not None:
            self.inputs.dimensionality.connect(dimensionality)
        if e_shell_layers is not None:
            self.inputs.e_shell_layers.connect(e_shell_layers)
        if html_report_path is not None:
            self.inputs.html_report_path.connect(html_report_path)
        if samples_limit is not None:
            self.inputs.samples_limit.connect(samples_limit)
        if correlation_function_type is not None:
            self.inputs.correlation_function_type.connect(correlation_function_type)
        if polynomial_type is not None:
            self.inputs.polynomial_type.connect(polynomial_type)
        if outside_distance_checking is not None:
            self.inputs.outside_distance_checking.connect(outside_distance_checking)
        if bounding_box_tolerance is not None:
            self.inputs.bounding_box_tolerance.connect(bounding_box_tolerance)
        if adaptive_tolerance_percent is not None:
            self.inputs.adaptive_tolerance_percent.connect(adaptive_tolerance_percent)
        if geometry_type is not None:
            self.inputs.geometry_type.connect(geometry_type)

    @staticmethod
    def _spec():
        description = """Prepare mapping of source data from source mesh to target mesh by
            operating the source_mesh/target_mesh weights computation.
            This operator will use a point kriging algorithm. This
            operator needs to be used with the apply mechanical native
            mapping associated one."""
        spec = Specification(
            description=description,
            map_input_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Target mesh""",
                ),
                3: PinSpecification(
                    name="target_mesh_scoping",
                    type_names=["scoping"],
                    optional=True,
                    document="""Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.""",
                ),
                4: PinSpecification(
                    name="unit",
                    type_names=["string"],
                    optional=True,
                    document="""Unit of the result to map""",
                ),
                5: PinSpecification(
                    name="location",
                    type_names=["string"],
                    optional=False,
                    document="""Location of the result to map""",
                ),
                6: PinSpecification(
                    name="dimensionality",
                    type_names=["int32"],
                    optional=False,
                    document="""Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).""",
                ),
                7: PinSpecification(
                    name="e_shell_layers",
                    type_names=["int32"],
                    optional=True,
                    document="""Eshelllayers enum value if field has shell
        layers""",
                ),
                8: PinSpecification(
                    name="html_report_path",
                    type_names=["string"],
                    optional=True,
                    document="""Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.""",
                ),
                10: PinSpecification(
                    name="samples_limit",
                    type_names=["int32"],
                    optional=True,
                    document="""Default is 20""",
                ),
                11: PinSpecification(
                    name="correlation_function_type",
                    type_names=["string"],
                    optional=True,
                    document="""Default is 'gaussian'. can also be
        'exponential', 'linear', 'none',
        'spherical', 'cubic',
        'multi_quadratic',
        'thin_plate_spline'.""",
                ),
                12: PinSpecification(
                    name="polynomial_type",
                    type_names=["string"],
                    optional=True,
                    document="""Default is 'adaptive'. can also be
        'pure_quadratic', 'linear',
        'constant', 'none'.""",
                ),
                13: PinSpecification(
                    name="outside_distance_checking",
                    type_names=["bool"],
                    optional=True,
                    document="""Default is false""",
                ),
                14: PinSpecification(
                    name="bounding_box_tolerance",
                    type_names=["double"],
                    optional=True,
                    document="""Default is 0.0""",
                ),
                15: PinSpecification(
                    name="adaptive_tolerance_percent",
                    type_names=["double"],
                    optional=True,
                    document="""Default is 0.1 (corresponds to 10%)""",
                ),
                16: PinSpecification(
                    name="geometry_type",
                    type_names=["string"],
                    optional=True,
                    document="""Default is 'volume'. can also be 'surface'.""",
                ),
            },
            map_output_pin_spec={
                0: PinSpecification(
                    name="source_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Source mesh""",
                ),
                1: PinSpecification(
                    name="source_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Source mesh id""",
                ),
                2: PinSpecification(
                    name="target_mesh",
                    type_names=["abstract_meshed_region"],
                    optional=False,
                    document="""Target mesh""",
                ),
                3: PinSpecification(
                    name="target_mesh_id",
                    type_names=["int32"],
                    optional=False,
                    document="""Target mesh id""",
                ),
                4: PinSpecification(
                    name="mapping_manager_data",
                    optional=False,
                    document="""""",
                ),
                6: PinSpecification(
                    name="target_scoping",
                    type_names=["scoping"],
                    optional=False,
                    document="""Target scoping""",
                ),
            },
        )
        return spec

    @staticmethod
    def default_config(server=None):
        """Returns the default config of the operator.

        This config can then be changed to the user needs and be used to
        instantiate the operator. The Configuration allows to customize
        how the operation will be processed by the operator.

        Parameters
        ----------
        server : server.DPFServer, optional
            Server with channel connected to the remote or local instance. When
            ``None``, attempts to use the global server.
        """
        return Operator.default_config(
            name="mechanical_native_mapping::prepare::kriging", server=server
        )

    @property
    def inputs(self):
        """Enables to connect inputs to the operator

        Returns
        --------
        inputs : InputsPrepareMechanicalNativeMappingKriging
        """
        return super().inputs

    @property
    def outputs(self):
        """Enables to get outputs of the operator by evaluating it

        Returns
        --------
        outputs : OutputsPrepareMechanicalNativeMappingKriging
        """
        return super().outputs


class InputsPrepareMechanicalNativeMappingKriging(_Inputs):
    """Intermediate class used to connect user inputs to
    prepare_mechanical_native_mapping_kriging operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
    >>> my_source_mesh = dpf.MeshedRegion()
    >>> op.inputs.source_mesh.connect(my_source_mesh)
    >>> my_target_mesh = dpf.MeshedRegion()
    >>> op.inputs.target_mesh.connect(my_target_mesh)
    >>> my_target_mesh_scoping = dpf.Scoping()
    >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
    >>> my_unit = str()
    >>> op.inputs.unit.connect(my_unit)
    >>> my_location = str()
    >>> op.inputs.location.connect(my_location)
    >>> my_dimensionality = int()
    >>> op.inputs.dimensionality.connect(my_dimensionality)
    >>> my_e_shell_layers = int()
    >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
    >>> my_html_report_path = str()
    >>> op.inputs.html_report_path.connect(my_html_report_path)
    >>> my_samples_limit = int()
    >>> op.inputs.samples_limit.connect(my_samples_limit)
    >>> my_correlation_function_type = str()
    >>> op.inputs.correlation_function_type.connect(my_correlation_function_type)
    >>> my_polynomial_type = str()
    >>> op.inputs.polynomial_type.connect(my_polynomial_type)
    >>> my_outside_distance_checking = bool()
    >>> op.inputs.outside_distance_checking.connect(my_outside_distance_checking)
    >>> my_bounding_box_tolerance = float()
    >>> op.inputs.bounding_box_tolerance.connect(my_bounding_box_tolerance)
    >>> my_adaptive_tolerance_percent = float()
    >>> op.inputs.adaptive_tolerance_percent.connect(my_adaptive_tolerance_percent)
    >>> my_geometry_type = str()
    >>> op.inputs.geometry_type.connect(my_geometry_type)
    """

    def __init__(self, op: Operator):
        super().__init__(prepare_mechanical_native_mapping_kriging._spec().inputs, op)
        self._source_mesh = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(0), 0, op, -1
        )
        self._inputs.append(self._source_mesh)
        self._target_mesh = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(1), 1, op, -1
        )
        self._inputs.append(self._target_mesh)
        self._target_mesh_scoping = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(3), 3, op, -1
        )
        self._inputs.append(self._target_mesh_scoping)
        self._unit = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(4), 4, op, -1
        )
        self._inputs.append(self._unit)
        self._location = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(5), 5, op, -1
        )
        self._inputs.append(self._location)
        self._dimensionality = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(6), 6, op, -1
        )
        self._inputs.append(self._dimensionality)
        self._e_shell_layers = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(7), 7, op, -1
        )
        self._inputs.append(self._e_shell_layers)
        self._html_report_path = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(8), 8, op, -1
        )
        self._inputs.append(self._html_report_path)
        self._samples_limit = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(10), 10, op, -1
        )
        self._inputs.append(self._samples_limit)
        self._correlation_function_type = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(11), 11, op, -1
        )
        self._inputs.append(self._correlation_function_type)
        self._polynomial_type = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(12), 12, op, -1
        )
        self._inputs.append(self._polynomial_type)
        self._outside_distance_checking = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(13), 13, op, -1
        )
        self._inputs.append(self._outside_distance_checking)
        self._bounding_box_tolerance = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(14), 14, op, -1
        )
        self._inputs.append(self._bounding_box_tolerance)
        self._adaptive_tolerance_percent = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(15), 15, op, -1
        )
        self._inputs.append(self._adaptive_tolerance_percent)
        self._geometry_type = Input(
            prepare_mechanical_native_mapping_kriging._spec().input_pin(16), 16, op, -1
        )
        self._inputs.append(self._geometry_type)

    @property
    def source_mesh(self):
        """Allows to connect source_mesh input to the operator.

        Source mesh

        Parameters
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.source_mesh.connect(my_source_mesh)
        >>> # or
        >>> op.inputs.source_mesh(my_source_mesh)
        """
        return self._source_mesh

    @property
    def target_mesh(self):
        """Allows to connect target_mesh input to the operator.

        Target mesh

        Parameters
        ----------
        my_target_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.target_mesh.connect(my_target_mesh)
        >>> # or
        >>> op.inputs.target_mesh(my_target_mesh)
        """
        return self._target_mesh

    @property
    def target_mesh_scoping(self):
        """Allows to connect target_mesh_scoping input to the operator.

        Target mesh scoping. if used, ensure to give
        only the elements where results are
        expected into source mesh input to
        have optimized computation.

        Parameters
        ----------
        my_target_mesh_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.target_mesh_scoping.connect(my_target_mesh_scoping)
        >>> # or
        >>> op.inputs.target_mesh_scoping(my_target_mesh_scoping)
        """
        return self._target_mesh_scoping

    @property
    def unit(self):
        """Allows to connect unit input to the operator.

        Unit of the result to map

        Parameters
        ----------
        my_unit : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.unit.connect(my_unit)
        >>> # or
        >>> op.inputs.unit(my_unit)
        """
        return self._unit

    @property
    def location(self):
        """Allows to connect location input to the operator.

        Location of the result to map

        Parameters
        ----------
        my_location : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.location.connect(my_location)
        >>> # or
        >>> op.inputs.location(my_location)
        """
        return self._location

    @property
    def dimensionality(self):
        """Allows to connect dimensionality input to the operator.

        Dimensionality of the result to map (for
        example it will be 3 for a
        displacement along (x, y, z) axes).

        Parameters
        ----------
        my_dimensionality : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.dimensionality.connect(my_dimensionality)
        >>> # or
        >>> op.inputs.dimensionality(my_dimensionality)
        """
        return self._dimensionality

    @property
    def e_shell_layers(self):
        """Allows to connect e_shell_layers input to the operator.

        Eshelllayers enum value if field has shell
        layers

        Parameters
        ----------
        my_e_shell_layers : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.e_shell_layers.connect(my_e_shell_layers)
        >>> # or
        >>> op.inputs.e_shell_layers(my_e_shell_layers)
        """
        return self._e_shell_layers

    @property
    def html_report_path(self):
        """Allows to connect html_report_path input to the operator.

        Path for html report (for example
        'my_disk/my_report.html'). if set, an
        html report will be generated and
        exported to the html file. if not
        set, nothing will be generated.

        Parameters
        ----------
        my_html_report_path : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.html_report_path.connect(my_html_report_path)
        >>> # or
        >>> op.inputs.html_report_path(my_html_report_path)
        """
        return self._html_report_path

    @property
    def samples_limit(self):
        """Allows to connect samples_limit input to the operator.

        Default is 20

        Parameters
        ----------
        my_samples_limit : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.samples_limit.connect(my_samples_limit)
        >>> # or
        >>> op.inputs.samples_limit(my_samples_limit)
        """
        return self._samples_limit

    @property
    def correlation_function_type(self):
        """Allows to connect correlation_function_type input to the operator.

        Default is 'gaussian'. can also be
        'exponential', 'linear', 'none',
        'spherical', 'cubic',
        'multi_quadratic',
        'thin_plate_spline'.

        Parameters
        ----------
        my_correlation_function_type : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.correlation_function_type.connect(my_correlation_function_type)
        >>> # or
        >>> op.inputs.correlation_function_type(my_correlation_function_type)
        """
        return self._correlation_function_type

    @property
    def polynomial_type(self):
        """Allows to connect polynomial_type input to the operator.

        Default is 'adaptive'. can also be
        'pure_quadratic', 'linear',
        'constant', 'none'.

        Parameters
        ----------
        my_polynomial_type : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.polynomial_type.connect(my_polynomial_type)
        >>> # or
        >>> op.inputs.polynomial_type(my_polynomial_type)
        """
        return self._polynomial_type

    @property
    def outside_distance_checking(self):
        """Allows to connect outside_distance_checking input to the operator.

        Default is false

        Parameters
        ----------
        my_outside_distance_checking : bool

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.outside_distance_checking.connect(my_outside_distance_checking)
        >>> # or
        >>> op.inputs.outside_distance_checking(my_outside_distance_checking)
        """
        return self._outside_distance_checking

    @property
    def bounding_box_tolerance(self):
        """Allows to connect bounding_box_tolerance input to the operator.

        Default is 0.0

        Parameters
        ----------
        my_bounding_box_tolerance : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.bounding_box_tolerance.connect(my_bounding_box_tolerance)
        >>> # or
        >>> op.inputs.bounding_box_tolerance(my_bounding_box_tolerance)
        """
        return self._bounding_box_tolerance

    @property
    def adaptive_tolerance_percent(self):
        """Allows to connect adaptive_tolerance_percent input to the operator.

        Default is 0.1 (corresponds to 10%)

        Parameters
        ----------
        my_adaptive_tolerance_percent : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.adaptive_tolerance_percent.connect(my_adaptive_tolerance_percent)
        >>> # or
        >>> op.inputs.adaptive_tolerance_percent(my_adaptive_tolerance_percent)
        """
        return self._adaptive_tolerance_percent

    @property
    def geometry_type(self):
        """Allows to connect geometry_type input to the operator.

        Default is 'volume'. can also be 'surface'.

        Parameters
        ----------
        my_geometry_type : str

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> op.inputs.geometry_type.connect(my_geometry_type)
        >>> # or
        >>> op.inputs.geometry_type(my_geometry_type)
        """
        return self._geometry_type


class OutputsPrepareMechanicalNativeMappingKriging(_Outputs):
    """Intermediate class used to get outputs from
    prepare_mechanical_native_mapping_kriging operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
    >>> # Connect inputs : op.inputs. ...
    >>> result_source_mesh = op.outputs.source_mesh()
    >>> result_source_mesh_id = op.outputs.source_mesh_id()
    >>> result_target_mesh = op.outputs.target_mesh()
    >>> result_target_mesh_id = op.outputs.target_mesh_id()
    >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
    >>> result_target_scoping = op.outputs.target_scoping()
    """

    def __init__(self, op: Operator):
        super().__init__(prepare_mechanical_native_mapping_kriging._spec().outputs, op)
        self._source_mesh = Output(
            prepare_mechanical_native_mapping_kriging._spec().output_pin(0), 0, op
        )
        self._outputs.append(self._source_mesh)
        self._source_mesh_id = Output(
            prepare_mechanical_native_mapping_kriging._spec().output_pin(1), 1, op
        )
        self._outputs.append(self._source_mesh_id)
        self._target_mesh = Output(
            prepare_mechanical_native_mapping_kriging._spec().output_pin(2), 2, op
        )
        self._outputs.append(self._target_mesh)
        self._target_mesh_id = Output(
            prepare_mechanical_native_mapping_kriging._spec().output_pin(3), 3, op
        )
        self._outputs.append(self._target_mesh_id)
        self._mapping_manager_data = Output(
            prepare_mechanical_native_mapping_kriging._spec().output_pin(4), 4, op
        )
        self._outputs.append(self._mapping_manager_data)
        self._target_scoping = Output(
            prepare_mechanical_native_mapping_kriging._spec().output_pin(6), 6, op
        )
        self._outputs.append(self._target_scoping)

    @property
    def source_mesh(self):
        """Allows to get source_mesh output of the operator

        Returns
        ----------
        my_source_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh = op.outputs.source_mesh()
        """  # noqa: E501
        return self._source_mesh

    @property
    def source_mesh_id(self):
        """Allows to get source_mesh_id output of the operator

        Returns
        ----------
        my_source_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> # Connect inputs : op.inputs. ...
        >>> result_source_mesh_id = op.outputs.source_mesh_id()
        """  # noqa: E501
        return self._source_mesh_id

    @property
    def target_mesh(self):
        """Allows to get target_mesh output of the operator

        Returns
        ----------
        my_target_mesh : MeshedRegion

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh = op.outputs.target_mesh()
        """  # noqa: E501
        return self._target_mesh

    @property
    def target_mesh_id(self):
        """Allows to get target_mesh_id output of the operator

        Returns
        ----------
        my_target_mesh_id : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_mesh_id = op.outputs.target_mesh_id()
        """  # noqa: E501
        return self._target_mesh_id

    @property
    def mapping_manager_data(self):
        """Allows to get mapping_manager_data output of the operator

        Returns
        ----------
        my_mapping_manager_data :

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> # Connect inputs : op.inputs. ...
        >>> result_mapping_manager_data = op.outputs.mapping_manager_data()
        """  # noqa: E501
        return self._mapping_manager_data

    @property
    def target_scoping(self):
        """Allows to get target_scoping output of the operator

        Returns
        ----------
        my_target_scoping : Scoping

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.mapping.prepare_mechanical_native_mapping_kriging()
        >>> # Connect inputs : op.inputs. ...
        >>> result_target_scoping = op.outputs.target_scoping()
        """  # noqa: E501
        return self._target_scoping

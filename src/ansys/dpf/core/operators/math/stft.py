"""
stft
====
Autogenerated DPF operator classes.
"""

from warnings import warn
from ansys.dpf.core.dpf_operator import Operator
from ansys.dpf.core.inputs import Input, _Inputs
from ansys.dpf.core.outputs import Output, _Outputs
from ansys.dpf.core.operators.specification import PinSpecification, Specification


class stft(Operator):
    """Perform Short Term Fourier Transform on a time scoped field having a
    TimeFreqSupport.

    Parameters
    ----------
    time_field : Field
    cutoff_frequency : float
        Max frequency in output
    min_freq_resolution : float
        Minimum frequency resolution (difference
        between each frequency in output)
    slice_number : int
        Number of stft slices
    overlap : float
        Overlapping of between slices
    window : int
        Connect max number subdivisions, used to
        avoid huge number of sudivisions


    Examples
    --------
    >>> from ansys.dpf import core as dpf

    >>> # Instantiate operator
    >>> op = dpf.operators.math.stft()

    >>> # Make input connections
    >>> my_time_field = dpf.Field()
    >>> op.inputs.time_field.connect(my_time_field)
    >>> my_cutoff_frequency = float()
    >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
    >>> my_min_freq_resolution = float()
    >>> op.inputs.min_freq_resolution.connect(my_min_freq_resolution)
    >>> my_slice_number = int()
    >>> op.inputs.slice_number.connect(my_slice_number)
    >>> my_overlap = float()
    >>> op.inputs.overlap.connect(my_overlap)
    >>> my_window = int()
    >>> op.inputs.window.connect(my_window)

    >>> # Instantiate operator and connect inputs in one line
    >>> op = dpf.operators.math.stft(
    ...     time_field=my_time_field,
    ...     cutoff_frequency=my_cutoff_frequency,
    ...     min_freq_resolution=my_min_freq_resolution,
    ...     slice_number=my_slice_number,
    ...     overlap=my_overlap,
    ...     window=my_window,
    ... )

    >>> # Get output data
    >>> result_fc_stft_output = op.outputs.fc_stft_output()
    """

    def __init__(
        self,
        time_field=None,
        cutoff_frequency=None,
        min_freq_resolution=None,
        slice_number=None,
        overlap=None,
        window=None,
        config=None,
        server=None,
    ):
        super().__init__(name="stft", config=config, server=server)
        self._inputs = InputsStft(self)
        self._outputs = OutputsStft(self)
        if time_field is not None:
            self.inputs.time_field.connect(time_field)
        if cutoff_frequency is not None:
            self.inputs.cutoff_frequency.connect(cutoff_frequency)
        if min_freq_resolution is not None:
            self.inputs.min_freq_resolution.connect(min_freq_resolution)
        if slice_number is not None:
            self.inputs.slice_number.connect(slice_number)
        if overlap is not None:
            self.inputs.overlap.connect(overlap)
        if window is not None:
            self.inputs.window.connect(window)

    @staticmethod
    def _spec():
        description = """Perform Short Term Fourier Transform on a time scoped field having a
            TimeFreqSupport."""
        spec = Specification(
            description=description,
            map_input_pin_spec={
                0: PinSpecification(
                    name="time_field",
                    type_names=["field"],
                    optional=False,
                    document="""""",
                ),
                1: PinSpecification(
                    name="cutoff_frequency",
                    type_names=["double"],
                    optional=False,
                    document="""Max frequency in output""",
                ),
                2: PinSpecification(
                    name="min_freq_resolution",
                    type_names=["double"],
                    optional=False,
                    document="""Minimum frequency resolution (difference
        between each frequency in output)""",
                ),
                3: PinSpecification(
                    name="slice_number",
                    type_names=["int32"],
                    optional=False,
                    document="""Number of stft slices""",
                ),
                4: PinSpecification(
                    name="overlap",
                    type_names=["double"],
                    optional=False,
                    document="""Overlapping of between slices""",
                ),
                5: PinSpecification(
                    name="window",
                    type_names=["int32"],
                    optional=False,
                    document="""Connect max number subdivisions, used to
        avoid huge number of sudivisions""",
                ),
            },
            map_output_pin_spec={
                0: PinSpecification(
                    name="fc_stft_output",
                    type_names=["fields_container"],
                    optional=False,
                    document="""Fields container having slice label, each
        field representing a fft on slice.""",
                ),
            },
        )
        return spec

    @staticmethod
    def default_config(server=None):
        """Returns the default config of the operator.

        This config can then be changed to the user needs and be used to
        instantiate the operator. The Configuration allows to customize
        how the operation will be processed by the operator.

        Parameters
        ----------
        server : server.DPFServer, optional
            Server with channel connected to the remote or local instance. When
            ``None``, attempts to use the global server.
        """
        return Operator.default_config(name="stft", server=server)

    @property
    def inputs(self):
        """Enables to connect inputs to the operator

        Returns
        --------
        inputs : InputsStft
        """
        return super().inputs

    @property
    def outputs(self):
        """Enables to get outputs of the operator by evaluating it

        Returns
        --------
        outputs : OutputsStft
        """
        return super().outputs


class InputsStft(_Inputs):
    """Intermediate class used to connect user inputs to
    stft operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.math.stft()
    >>> my_time_field = dpf.Field()
    >>> op.inputs.time_field.connect(my_time_field)
    >>> my_cutoff_frequency = float()
    >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
    >>> my_min_freq_resolution = float()
    >>> op.inputs.min_freq_resolution.connect(my_min_freq_resolution)
    >>> my_slice_number = int()
    >>> op.inputs.slice_number.connect(my_slice_number)
    >>> my_overlap = float()
    >>> op.inputs.overlap.connect(my_overlap)
    >>> my_window = int()
    >>> op.inputs.window.connect(my_window)
    """

    def __init__(self, op: Operator):
        super().__init__(stft._spec().inputs, op)
        self._time_field = Input(stft._spec().input_pin(0), 0, op, -1)
        self._inputs.append(self._time_field)
        self._cutoff_frequency = Input(stft._spec().input_pin(1), 1, op, -1)
        self._inputs.append(self._cutoff_frequency)
        self._min_freq_resolution = Input(stft._spec().input_pin(2), 2, op, -1)
        self._inputs.append(self._min_freq_resolution)
        self._slice_number = Input(stft._spec().input_pin(3), 3, op, -1)
        self._inputs.append(self._slice_number)
        self._overlap = Input(stft._spec().input_pin(4), 4, op, -1)
        self._inputs.append(self._overlap)
        self._window = Input(stft._spec().input_pin(5), 5, op, -1)
        self._inputs.append(self._window)

    @property
    def time_field(self):
        """Allows to connect time_field input to the operator.

        Parameters
        ----------
        my_time_field : Field

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> op.inputs.time_field.connect(my_time_field)
        >>> # or
        >>> op.inputs.time_field(my_time_field)
        """
        return self._time_field

    @property
    def cutoff_frequency(self):
        """Allows to connect cutoff_frequency input to the operator.

        Max frequency in output

        Parameters
        ----------
        my_cutoff_frequency : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> op.inputs.cutoff_frequency.connect(my_cutoff_frequency)
        >>> # or
        >>> op.inputs.cutoff_frequency(my_cutoff_frequency)
        """
        return self._cutoff_frequency

    @property
    def min_freq_resolution(self):
        """Allows to connect min_freq_resolution input to the operator.

        Minimum frequency resolution (difference
        between each frequency in output)

        Parameters
        ----------
        my_min_freq_resolution : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> op.inputs.min_freq_resolution.connect(my_min_freq_resolution)
        >>> # or
        >>> op.inputs.min_freq_resolution(my_min_freq_resolution)
        """
        return self._min_freq_resolution

    @property
    def slice_number(self):
        """Allows to connect slice_number input to the operator.

        Number of stft slices

        Parameters
        ----------
        my_slice_number : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> op.inputs.slice_number.connect(my_slice_number)
        >>> # or
        >>> op.inputs.slice_number(my_slice_number)
        """
        return self._slice_number

    @property
    def overlap(self):
        """Allows to connect overlap input to the operator.

        Overlapping of between slices

        Parameters
        ----------
        my_overlap : float

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> op.inputs.overlap.connect(my_overlap)
        >>> # or
        >>> op.inputs.overlap(my_overlap)
        """
        return self._overlap

    @property
    def window(self):
        """Allows to connect window input to the operator.

        Connect max number subdivisions, used to
        avoid huge number of sudivisions

        Parameters
        ----------
        my_window : int

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> op.inputs.window.connect(my_window)
        >>> # or
        >>> op.inputs.window(my_window)
        """
        return self._window


class OutputsStft(_Outputs):
    """Intermediate class used to get outputs from
    stft operator.

    Examples
    --------
    >>> from ansys.dpf import core as dpf
    >>> op = dpf.operators.math.stft()
    >>> # Connect inputs : op.inputs. ...
    >>> result_fc_stft_output = op.outputs.fc_stft_output()
    """

    def __init__(self, op: Operator):
        super().__init__(stft._spec().outputs, op)
        self._fc_stft_output = Output(stft._spec().output_pin(0), 0, op)
        self._outputs.append(self._fc_stft_output)

    @property
    def fc_stft_output(self):
        """Allows to get fc_stft_output output of the operator

        Returns
        ----------
        my_fc_stft_output : FieldsContainer

        Examples
        --------
        >>> from ansys.dpf import core as dpf
        >>> op = dpf.operators.math.stft()
        >>> # Connect inputs : op.inputs. ...
        >>> result_fc_stft_output = op.outputs.fc_stft_output()
        """  # noqa: E501
        return self._fc_stft_output

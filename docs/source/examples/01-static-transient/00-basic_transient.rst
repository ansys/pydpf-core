
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\01-static-transient\00-basic_transient.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_01-static-transient_00-basic_transient.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_01-static-transient_00-basic_transient.py:


.. _ref_basic_transient:

Transient Analysis Result Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how to postprocess a transient result and
visualize the outputs.

Import the necessary modules:

.. GENERATED FROM PYTHON SOURCE LINES 11-18

.. code-block:: default

    import matplotlib.pyplot as plt
    import numpy as np

    from ansys.dpf import core as dpf
    from ansys.dpf.core import examples
    from ansys.dpf.core import operators as ops








.. GENERATED FROM PYTHON SOURCE LINES 19-25

Download the transient result example. This example is
not included in DPF-Core by default to speed up the installation.
Downloading this example should take only a few seconds.

Next, create the model and display the state of the result. This transient
result file contains several individual results, each at a different timestamp.

.. GENERATED FROM PYTHON SOURCE LINES 25-30

.. code-block:: default


    transient = examples.download_transient_result()
    model = dpf.Model(transient)
    print(model)



.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "D:\PyAnsysRepo\pydpf-core\examples\01-static-transient\00-basic_transient.py", line 28, in <module>
        print(model)
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\model.py", line 207, in __str__
        txt += str(self.results)
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\model.py", line 159, in results
        self._results = CommonResults(self)
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\results.py", line 574, in __init__
        self._result_info = model.metadata.result_info
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\model.py", line 104, in metadata
        self._metadata = Metadata(self._data_sources, self._server)
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\model.py", line 258, in __init__
        self._set_data_sources(data_sources)
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\model.py", line 394, in _set_data_sources
        self._cache_streams_provider()
      File "d:\pyansysrepo\pydpf-core\ansys\dpf\core\model.py", line 282, in _cache_streams_provider
        self._stream_provider.inputs.connect(self._data_sources)
    AttributeError: 'NoneType' object has no attribute 'connect'




.. GENERATED FROM PYTHON SOURCE LINES 31-32

Get the timestamps for each substep as a numpy array:

.. GENERATED FROM PYTHON SOURCE LINES 32-35

.. code-block:: default

    tf = model.metadata.time_freq_support
    print(tf.time_frequencies.data)


.. GENERATED FROM PYTHON SOURCE LINES 36-40

Obtain Minimum and Maximum Displacements for All Results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Create a displacement operator and set its time scoping request to
the entire time frequency support:

.. GENERATED FROM PYTHON SOURCE LINES 40-51

.. code-block:: default

    disp = model.results.displacement()
    timeids = range(1, tf.n_sets + 1)  # Must use 1-based indexing.
    disp.inputs.time_scoping(timeids)

    # Chain the displacement operator with ``norm`` and ``min_max`` operators.
    min_max_op = ops.min_max.min_max_fc(ops.math.norm_fc(disp))

    min_disp = min_max_op.outputs.field_min()
    max_disp = min_max_op.outputs.field_max()
    print(max_disp.data)


.. GENERATED FROM PYTHON SOURCE LINES 52-53

Plot the minimum and maximum displacements over time:

.. GENERATED FROM PYTHON SOURCE LINES 53-62

.. code-block:: default


    tdata = tf.time_frequencies.data
    plt.plot(tdata, max_disp.data, "r", label="Max")
    plt.plot(tdata, min_disp.data, "b", label="Min")
    plt.xlabel("Time (s)")
    plt.ylabel("Displacement (m)")
    plt.legend()
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 63-65

Plot the minimum and maximum displacements over time for the X
component.

.. GENERATED FROM PYTHON SOURCE LINES 65-79

.. code-block:: default

    disp_z = disp.Z()
    min_max_op = ops.min_max.min_max_fc(ops.math.norm_fc(disp_z))

    min_disp_z = min_max_op.outputs.field_min()
    max_disp_z = min_max_op.outputs.field_max()

    tdata = tf.time_frequencies.data
    plt.plot(tdata, max_disp_z.data, "r", label="Max")
    plt.plot(tdata, min_disp_z.data, "b", label="Min")
    plt.xlabel("Time (s)")
    plt.ylabel("X Displacement (m)")
    plt.legend()
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 80-84

Postprocessing Stress
~~~~~~~~~~~~~~~~~~~~~
Create an equivalent (von Mises) stress operator and set its time
scoping to the entire time frequency support:

.. GENERATED FROM PYTHON SOURCE LINES 84-100

.. code-block:: default


    # Component stress operator (stress)
    stress = model.results.stress()

    # Equivalent stress operator
    eqv = stress.eqv()
    eqv.inputs.time_scoping(timeids)

    # Connect to the min_max operator and return the minimum and maximum
    # fields.
    min_max_eqv = ops.min_max.min_max_fc(eqv)
    eqv_min = min_max_eqv.outputs.field_min()
    eqv_max = min_max_eqv.outputs.field_max()

    print(eqv_min)


.. GENERATED FROM PYTHON SOURCE LINES 101-102

Plot the maximum stress over time:

.. GENERATED FROM PYTHON SOURCE LINES 102-110

.. code-block:: default


    plt.plot(tdata, eqv_min.data, "b", label="Minimum")
    plt.plot(tdata, eqv_max.data, "r", label="Maximum")
    plt.xlabel("Time (s)")
    plt.ylabel("Equivalent Stress (Pa)")
    plt.legend()
    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 111-115

Scoping and Stress Field Coordinates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The scoping of the stress field can be used to extract the
coordinates used for each result:

.. GENERATED FROM PYTHON SOURCE LINES 115-122

.. code-block:: default


    # Extract a single field from the equivalent stress operator.
    field = eqv.outputs.fields_container()[28]

    # Print the first node IDs from the field.
    print(field.scoping.ids[:10])


.. GENERATED FROM PYTHON SOURCE LINES 123-132

As you can see, these node IDs are not in order. Additionally,
there may be fewer entries in the field than nodes in the model. For
example, stresses are not computed at mid-side nodes.

To extract the coordinates for these node IDs, load the mesh from
the model and then extract a coordinate for each node index.

Here is an inefficient way of getting the coordinates as each
individual request must be sent to the DPF service:

.. GENERATED FROM PYTHON SOURCE LINES 132-143

.. code-block:: default


    # Load the mesh from the model.
    meshed_region = model.metadata.meshed_region

    # Print the first 10 coordinates for the field.
    node_ids = field.scoping.ids
    for node_id in node_ids[:10]:
        # Fetch each individual node by node ID.
        node_coord = meshed_region.nodes.node_by_id(node_id).coordinates
        print(f"Node ID {node_id} : %8.5f, %8.5f, %8.5f" % tuple(node_coord))


.. GENERATED FROM PYTHON SOURCE LINES 144-150

Rather than individually querying for each node coordinate of the
field, you can use the :func:`map_scoping` to remap the field data
to match the order of the nodes in the meshed region.

Obtain the indices needed to get the data from ``field.data`` to match
the order of nodes in the mesh:

.. GENERATED FROM PYTHON SOURCE LINES 150-166

.. code-block:: default


    nodes = meshed_region.nodes
    ind, mask = nodes.map_scoping(field.scoping)

    # Show that the order of the remapped node scoping matches the field scoping.
    print(
        "Scoping matches:", np.allclose(np.array(nodes.scoping.ids)[ind], field.scoping.ids)
    )

    # Now plot the von Mises stress relative to the Z coordinates.
    z_coord = nodes.coordinates_field.data[ind, 2]

    plt.plot(z_coord, field.data, ".")
    plt.xlabel("Z Coordinate (m)")
    plt.ylabel("Equivalent Stress (Pa)")
    plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.016 seconds)


.. _sphx_glr_download_examples_01-static-transient_00-basic_transient.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: 00-basic_transient.py <00-basic_transient.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: 00-basic_transient.ipynb <00-basic_transient.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_

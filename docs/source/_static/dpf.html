<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
   <style>
body {
  /* font-family: Arial, Helvetica, sans-serif; */
    font-family: 'Source Sans Pro', sans-serif;
}


* {
  box-sizing: border-box;
}

/* Create a column layout with Flexbox */
/* Create a column layout with Flexbox */
.row {
  display: flex;
}

.main h1
{
/* margin-top:150px; */
}

:root {
  --ansysGold: #FFB71B;
  --ansysBronze: #C89211;
  --pythonBlue: #3972a1;
}


.main h1
{
padding : 30px;
  text-align: left;
  /* background:#f1f1f1; */
  color: var(--pythonBlue);
  font-size: 35px;
   border-top: 1px solid black;
   border-bottom: 1px solid black;
}


/* The sidebar menu */
.sidenav {

  /* margin-top : 30px; */
  margin-left: 0px;
  height: 99%; /* Full-height: remove this if you want "auto" height */
  width: 300px; /* Set the width of the sidebar */
  position: fixed; /* Fixed Sidebar (stay in place on scroll) */
  z-index: 1; /* Stay on top */
  left: 0;
  background-color: #B5B5B5; /* Grey */
  overflow-x: hidden; /* Disable horizontal scroll */
  padding-top: 20px;
}

.sidenav h2 { padding-left : 20px;}

/* The navigation menu links */
.sidenav a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 16px;
  display: block;
}

/* When you mouse over the navigation links, change their color */
.sidenav a:hover {
  overflow: hidden;
}

/* Style page content */
.main {
  margin-left: 290px; /* Same as the width of the sidebar */
  margin-right:-8px;
  /* padding-top: 1px; */
  background-color: white;
  padding-bottom: 30px;
}


.op-des-h1 {

padding : 20px;
margin : -50 px;
  text-align: left;
  background:#f1f1f1;
  /* color: #4CAF50; */
  font-size: 30px;
   border-top: 1px solid black;
   border-bottom: 1px solid black;
}

.op-des-h2{
padding : 10px;
padding-left:30px;
  text-align: left;
  color: black;
  font-size: 25px;
  margin:0px;
  margin-top :10px;
}

/* Style the search box */
#mySearch {
  width: 100%;
  font-size: 13px;
  padding: 11px;
  border: 10px solid #B5B5B5;
}

/* Style the navigation menu inside the left column */

.collapsible {
  background-color: #777;
  color: white;
  cursor: pointer;
  padding: 8px;
  padding-left:20px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

.collapsible.active, .collapsible:hover {
    background-color: #555; /*dark grey*/
}

.ul-main {
    margin-left: 30px;
    font-size: 0.9em;
}
.content {
    padding: 5px 0px 10px 0px;
    display: none;
    overflow: hidden;
    background-color: #f1f1f1; /*grey*/
}

.content ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.content ul li a {
    padding: 6px;
    padding-left: 20px;
    text-decoration: none;
    color: black;
    display: block ;
    cursor: pointer;
    outline: none;
    font-size: 14px;
}

.content ul li a:hover, .content ul li a.active {
    background-color: #E8E8E8;/*grey*/
    color: black;
    cursor: pointer;
    padding: 6px;
    padding-left: 20px;
}

/* Add a black background color to the top navigation */
.topnav {
    display: none;
    background-color: #333; /*balck*/
    position: fixed;
    margin-left: 0px;
    width: 100%;
    height: 120px;
    /*overflow: hidden;*/
    padding: 0px;
    margin-left: -8px;
    margin-right: -8px;
    margin-top: -8px;
    cursor: pointer;
    z-index: 100;
}
/* Style of dpf logo*/
.dpf-logo
{
  /* color:  #4CAF50; */
  text-align: left;
  text-decoration: none;
  cursor: pointer;
  background-color : #333;
  font-size : 45px;
  /* font-family: Trebuchet MS, sans-serif; */
  font-weight: 2000;
  padding : 20px;
  padding-bottom : 10px;
  padding-top : 10px;
  margin : 0px;
}
/* Style the links inside the navigation bar */
.topnav a {
    float: left;
    color: #f2f2f2; /*grey*/
    text-align: center;
    padding: 14px 16px;
    margin: 0px;
    padding-left: 14px;
    text-decoration: none;
    font-size: 17px;
    cursor: pointer;
    z-index: 100;
    min-width: 11em;
        
        
}

/* Change the color of links on hover */
    .topnav a:hover, .topnav a.active {
        /* background-color: #4CAF50; /\*green*\/ */
        color: black;
        cursor: pointer;
    }
.content-list-topnav {
    cursor: pointer;
    position: relative;
    left: 0;
    text-align: left;
    list-style: none;
    padding: 0;
    pointer-events: all;
    margin-bottom: 0;
}
    .content-list-topnav li{
        display:block;
        width:100%;
    }
    
    
    .content-list-topnav p.active, .content-list-topnav li:hover {
        font-weight: bold;
    }

    .data * {
    display: none;
}

table{
margin-left : 20px;
}
table,tbody,tr, td
{
padding : 4px;
}

td
{
valign : bottom;
align : left;
min-height : 120px;
font-size : 15px;
}
req-type {
	/* color : purple; */
	font-weight: bold;
	white-space:nowrap;
}

pin-name {
	color : var(--ansysBronze);
	font-weight: bold;
}

op-tag {
	color : white;
	width: 300px;
	/* font-family: "Lucida Console", Courier, monospace; */
	valign : top;
}

pin-number {
    display: none;
	color : white;
	background-color: green;
	width: 300px;
	border: 1px solid green;
	border-radius: 6px;
	/* font-family: "Lucida Console", Courier, monospace; */
	padding : 4px;
	white-space:nowrap;
	valign : top;
}

pin-number-optional {
    display: none;
	width: 300px;
	border: 1px solid green;
	border-radius: 6px;
	/* font-family: "Lucida Console", Courier, monospace; */
	padding : 4px;
	white-space:nowrap;
	valign : top;
}

/* Tooltip container */
.tooltip {
  position: relative;
  display: inline-block;
}

/* Tooltip text */
.tooltip .tooltiptext {
  visibility: hidden;
  width: 100px;
  background-color: #f9f9f9;
  opacity : 70%;
  color: black;
  text-align: center;
  padding: 0px 0;
  border-radius: 1px;
  /* font-family: Arial, Helvetica, sans-serif; */
  /* Position the tooltip */
  position: absolute;
  z-index: 1;
  top: 100%;
  left: 50%;
  margin-left: 0px;
font-weight: normal;
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip:hover .tooltiptext {
  visibility: visible;
}

.tooltip-lower {
    display: none;
    position: relative;
    display: inline-block;
   
}

/* Tooltip text */
.tooltip-lower .tooltiptext {
  visibility: hidden;
  background-color: none;
  opacity : 100%;
  color : black;
  text-align: center;
  border-radius: 1px;
	font-weight : normal;
   font-size: 14px;
  /* Position the tooltip */
  transform: translateX(-50%);
   position: absolute;
   left: 50%;
  bottom: 100%;
  
}

/* Show the tooltip text when you mouse over the tooltip container */
.tooltip-lower:hover .tooltiptext {
  visibility: visible;

}
.api-scripting {
    margin-left: 30px;
    font-family: "Source Code Pro", "Courier New", monospace;
}
figure {
    display: block;
    width: 900px;
    border: 1px solid #ccc;
    border-radius: 3px;
    background: #eee;
    padding: 0;
    margin: 5px 0px 5px 20px;
}

.entity-drawing
{
display:flex;
zoom :70%;
/*width: 70%;*/ 
	margin :0;
	margin-left :0px;
 position: relative;
left:15%;
	border:none;
	background:none;
	padding:0;
}

/* code example caption */
figure figcaption
{
	display:block;
	
	padding:5px 10px 4px 10px;

	border-bottom:1px solid #ccc;
	border-radius:5px 5px 0 0;
	
	font-weight:bold;
	
	background: var(--pythonBlue);
	color:white;
	font-size : 17px;
	
}



/* the code example itself */
pre, code, pre samp {
    display: block;
    margin: 0;
    cursor: text;
    /* same core font for outer and inner elements */
    font: normal normal normal 13px monaco, courier, monospace;
    line-height:140%;
}
pre {
    padding: 0px 10px 0px 10px;
    /* overall font-size */
    font: normal normal normal 13px monaco, courier, monospace;
}

dl
{
margin-left : 20px;
padding : 4px;

}

dt {
    font-weight: bold;
	padding : 4px;
	
}
dd
{
margin-bottom : 20px;
font-size : 15px;
max-width : 90%;
text-align: justify;
}

.list_scripting
{
	display:block;
	list-style-type: none;
	font-size:1.0em;
	margin:0px;
	padding-left:30px;
}

.list_scripting li
{
	padding-left: 10px;
	padding: 5px;
}

.figure-op-des
{
margin : 0px;
margin-left : 30px;
border-radius:0px;
padding : 0px;
border:none;
width : 900px;
border: none;
-webkit-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
-moz-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
font-family: "Source Code Pro", "Courier New", monospace;	
}

.figure-op-des figcaption
{

width : 900px;
margin:0px;
display:inline-block;
/* background-color: green;  */
background-color: var(--ansysBronze);
padding:10px 10px;
border:none;
border-radius:0px;
font-size : 20px;
color:#f1f1f1;
}

.figure-op-des-text
{

  word-wrap: break-word; 
  white-space:normal;
margin:0px;
margin-left : 30px;
width : 900px;
display:inline-block;

padding:15px;
    border: none;
	background-color:#f1f1f1;
	
	-webkit-box-shadow: 0px 1px 5px 0px rgba(0,0,0,0.75);
-moz-box-shadow: 0px 1px 5px 0px rgba(0,0,0,0.75);
box-shadow: 0px 1px 5px 0px rgba(0,0,0,0.75);
}

.figure-op-des-text  p
{
font-family: Arial, Helvetica, sans-serif;
 display: inline-block;
 padding:0px;
 margin:0px;
font-size : 15px;
text-align:justify;
}

.overview_des
{
margin : 0px;
margin-left : 30px;
border-radius:0px;
padding : 20px;
border:none;
max-width : 90%;
border: none;
-webkit-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
-moz-box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
box-shadow: 0px 0px 5px 0px rgba(0,0,0,0.75);
background : #f1f1f1;
font-size:1.1em;
text-align:justify;
}

.p-main {
    font-size: 15px;
    margin-left : 30px;
    padding: 0px 0px 10px 0px;
    max-width: 90%;
    text-align: justify;
}

.h2-main
{
color: var(--pythonBlue);
margin-left : 30px;
max-width : 90%;
font-size : 20px;
border-bottom : 3px solid;
}


.h3-main {
    margin: 0px;
    margin-left: 30px;
    max-width: 90%;
    font-size: 15px;
    color: black;
    font-weight: bold;
    padding: 0px;
}

ul.horizontal {
    margin: 0;
    margin-top: -1px;
    padding: 0;
    display: block;
    position: relative;
    list-style-type: none;
    list-style-position: outside;
    background-color: #B5B5B5;
    position: relative;
    z-index:50;
    height: 32px;
}

ul.horizontal li {
    display: block;
    float: left;
    color: white;
    position: relative;
    height: 100%;
    list-style-type: none;
    margin: 0;
    padding: 0;
}

ul.horizontal a {
    float: left;
    text-align: center;
    padding: 10px;
    margin: 0px;
    text-decoration: none;
    font-size: 12px;
    cursor: pointer;
}

/* Change the color of links on hover */
    ul.horizontal a:hover, ul.horizontal a.active {
        background-color: #f1f1f1;
        color: black;
        cursor: pointer;
        padding: -2px;
        padding-bottom: 6px;
        border: 2px solid #777;
        border-bottom: 0px solid black;
        border-radius: 2px;
    }


</style>
</head>
<body onLoad="fillOperatorList(), collapsibleTreatment()">
    <div class="topnav">
        <h1 class="dpf-logo">DPF <span style="font-size:20px;font-style:italic; color:#f2f2f2;">data processing framework</span></h1>
        <a class="my-main-menu" id="disp_mainText" onclick="changeDisplay(this)">Overview</a>
        <a class="my-main-menu" id="disp_mainDataTypes" onclick="changeDisplay(this)">Main Data Types</a>
        <a class="my-main-menu" id="disp_APIs"onmouseenter="changeDisplayMouseOver(this)" onmouseleave ="changeDisplayMouseOut(this)">APIs
            <ul class="content-list-topnav" style="display:none;">
            <li><p class="my-main-menu" id="disp_dataAPIs" onclick="changeDisplay(this)">Data APIs</p></li>
            <li><p class="my-main-menu" id="disp_exampleWorkflows" onclick="changeDisplay(this)">Workflow examples</p></li>
            </ul></a>
        <a class="my-main-menu" id="disp_howToUse" onmouseenter="changeDisplayMouseOver(this)" onmouseleave ="changeDisplayMouseOut(this)">How to use DPF's package
            <ul class="content-list-topnav" style="display:none;">
            <li><p class="my-main-menu" id="disp_howToUseCPython" onclick="changeDisplay(this)">CPython</p></li>
                <li><p class="my-main-menu" id="disp_howToUseIPython" onclick="changeDisplay(this)">IPython</p></li>
                </ul></a>
    </div>

    <div class="sidenav" id="sidenav">
        <h2>Available Operators</h2>
        <input type="text" id="mySearch" onkeyup="myFunction()" placeholder="Search.." title="Type in a category">
    </div>

    <div id="displayer" class="main">
    </div>
    <div class="data" id="operator_list"><div class="main_text" id="mainText"><h1>DPF Operator API Description</h1>
        <div class="overview_des">This API reference contains descriptions and examples for all default DPF operators contained in the ANSYS 2021R1 release.</div>

<br>

<p class="p-main" >Each DPF operator is created based on its name using the <user-data><span style="color: #4070a0;">dpf.Operator</span></user-data> class.  The <user-data><span style="color: #4070a0;">inputs</span></user-data> and <user-data><span style="color: #4070a0;">outputs</span></user-data> attributes are then used to connect the operator with various sources, including other operators, data sources, fields, or data provided from Python.
</p>

<p class="p-main">The following example creates an nodal accumulated equivalent strain creep operator using <user-data><span style="color: #4070a0;">dpf.Operator('ENL_CREQ')</span></user-data>, which can be used to extract the accumulated equivalent strain creep from a result.

</p>

<br>

<!-- Autogenerated: -->

<figure id="fig_cpythonaccu_eqv_creep_strain"><figcaption>Example Usage in Python</figcaption><pre aria-labelledby="scripting"><code>from ansys.dpf import core as dpf<br><br><commented-data><span style="color: #8f5902; font-style: italic;"># Create the ENL_CREQ operator</span></commented-data><br>op = dpf.Operator(<user-data><span style="color: #4070a0;">'ENL_CREQ'</span></user-data>)<br><br><commented-data><span style="color: #8f5902; font-style: italic;"># Connect the inputs</span></commented-data><br>op.inputs.time_scoping.connect(<user-data><span style="color: #4070a0;">my_time_scoping</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.mesh_scoping.connect(<user-data><span style="color: #4070a0;">my_mesh_scoping</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.fields_container.connect(<user-data><span style="color: #4070a0;">my_fields_container</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.streams_container.connect(<user-data><span style="color: #4070a0;">my_streams_container</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.data_sources.connect(<user-data><span style="color: #4070a0;">my_data_sources</span></user-data>)<br>op.inputs.bool_rotate_to_global.connect(<user-data><span style="color: #4070a0;">my_bool_rotate_to_global</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.mesh.connect(<user-data><span style="color: #4070a0;">my_mesh</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.requested_location.connect(<user-data><span style="color: #4070a0;">my_requested_location</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br>op.inputs.domain_id.connect(<user-data><span style="color: #4070a0;">my_domain_id</span></user-data>)  <commented-data><span style="color: #8f5902; font-style: italic;"># optional</span></commented-data><br><br><commented-data><span style="color: #8f5902; font-style: italic;"># Access the outputs</span></commented-data><br>my_fields_container = op.outputs.fields_container(<user-data><span style="color: #4070a0;"></span></user-data>)<br></code></pre></figure>

</dd>

</dl></div><div class="main_text" id="howToUseCPython"><h1>How to use the CPython package</h1><div><h2 class="h2-main">Install the environment</h2>
<p class="p-main" >DPF's CPython interface is a grpc service. Its server is available in Workbench installation under aisol/bin/{platform}/Ans.Dpf.Grpc.exe. The client is based on a python SDK and protobuf generated python scripts. To use this API, the environment must have:</p>
<ul class="ul-main">
    <li>grpc io-tools</li>
    <li>jupyter-lab</li>
</ul>
 <p class="p-main" id="des_PackageCPythonInstall">To install those module with anaconda:</p>
<p class="p-main" id="des_PackageCPythonVariables">Before launching the jupyter notebook application, several environment variables need to be set:</p>
<ul class="ul-main">
    <li>%ANSYS_PATH% to the install folder: ANSYSInc/v{version}.</li>
    <li>%DPF_PATH% to %ANSYS_PATH%/aisol/bin/{platform}/Ans.Dpf.Grpc.exe.</li>
    <li>%PYTHONPATH%: add the paths to DPF's SDK and protobuf generated python scripts.</li>
</ul>

<h2 class="h2-main">Connect to the server</h2>
<p class="p-main" id="des_PackageCPythonConnect">Once Jupyter Notebook or Lab is launched with the requierements above, connecting the Python client to the service is done with:</p>
<simple-scripts id="script_PackageCPythonInstall" python=" conda install -c anaconda grpcio-tools
 conda install -c conda-forge jupyterlab"></apis-scripts><simple-scripts id="script_PackageCPythonConnect" python="from ansys import dpf<br><br>#start server on local machine with default port<br>dpf.start_local_server()<br><br>#start a specified server<br>dpf.start_local_server(ip=my_ip, port=my_port)<br>"></apis-scripts></div></div><div class="main_text" id="howToUseIPython"><h1>How to use the IPython package</h1><div><h2 class="h2-main">ACT Console</h2>
<h3 class="h3-main">Open the ACT console scripting in Mechanical</h3>
<p class="p-main" id="des_PackageOpenACT">The ACT console can be opened by clicking on "Automation"/"Scripting" menus in Mechanical.</p>
<h3 class="h3-main">Import DPF and connect it to the current console</h3>
<p class="p-main" id="des_PackageImportDPFACT">To import DPF’s capabilities into the ACT console, the user should import mech_dpf to access helpers and import the framework contained in the Ans.DataProcessing module. To access data from the current Mechanical windows, DPF’s helpers should be linked to it through the extAPI.</p>

<h3 class="h3-main">DPF's helpers to access mechanical's data</h3>
<p class="p-main">Diverse Mechanical’s and DPF's data can be accessed: </p>
<ul class="ul-main">
    <li  id="des_PackageACTDoc">this documentation can be generated via:</li>
    <li id="des_PackageACTDataSources">the result files of Mechanical’s analysis: to collect the DataSources (DPF’s entity containing result file paths) the user can write:</li>
    <li id="des_PackageACTMeshScoping">a mesh selection in the interface: to collect a mesh Scoping (DPF’s entity representing a list of ids of nodes or elements), once a geometry selection is picked out in the interface, it can be accessed via:</li>
</ul>

</div><simple-scripts id="script_PackageImportDPFACT" python="import mech_dpf<br>import Ans.DataProcessing as dpf<br>mech_dpf.setExtAPI(ExtAPI) <br>"></apis-scripts><simple-scripts id="script_PackageACTDoc" python="mech_dpf.help() <br>"></apis-scripts><simple-scripts id="script_PackageACTDataSources" python="my_data_sources = mech_dpf.GetDataSources() <br>"></apis-scripts><simple-scripts id="script_PackageACTMeshScoping" python="my_nodes_scoping = mech_dpf.GetNodesScoping() <br>my_elements_scoping = mech_dpf.GetElementScoping() <br>"></apis-scripts></div><div class="main_text" id="mainDataTypes"><h1>Overview of the main data types</h1><div><h2 class="h2-main">Main data types</h2>

<h3 class="h3-main">Operator</h3>
<p class="p-main" id="des_Operator">The Operator is the only object used to create and transform the data. It can be seen as an integrated circuit in electronics with a range of pins in input and in output. Those pins allow the user to pass on his information to each operator. When the operator is evaluated, it will process the input information to compute its output with respect to its description. Operators can be chained together to create workflows. To do so, the user only needs to connect some operator's outputs to an other operator's inputs. With workflows, lazy evaluation is performed, which means that when the last operator's outputs are asked by the user, all the connected operators will also be evaluated (and not before) to compute a given result. All the inputs, outputs and description information can be found by clicking on operators on the left pannel of this documentation.</p>

<h3 class="h3-main">Field</h3>
<p class="p-main" id="des_Field">The field is the main simulation data container. In numerical simulations, results data are defined by values associated to entities (scoping), and these entities are a subset of a model (support). In DPF, field data is always associated to its scoping and support, making the field a self-describing piece of data. A field is also defined by its dimensionnality, unit, location... A field can for example, describe a displacement vector or norm, stresses and strains tensors, stresses and strains equivalent, min max over time of any result... It can be defined on a complete model or just on certain entities of the model thanks to its scoping. The data is stored as a vector of double values and each elementary entity has a number of components (thanks to the dimensionality, a displacement will have 3 components, a symmetrical stress matrix 6...) </p>

<h3 class="h3-main">Workflow</h3>
<p class="p-main" id="des_Workflow">The workflow is built by chaining operators. It will evaluate the data processing defined by the used operators. It needs input information, and it will compute the requested output information. See workflows' examples in the APIs tab.</p>



<h2 class="h2-main">Secondary data types</h2>

<h3 class="h3-main">Scoping</h3>
<p class="p-main" id="des_Scoping">The scoping is entities ids representing a subset of the model's support. Typically, scoping can represent node ids, element ids, time steps, frequencies, joints... Its location indicates what kind of entity the scoping is referring to. Scopings are used to identify the entities where a field is scoped or to choose (through an input pin) a subset on which an operator should compute its result.</p>


<h3 class="h3-main">Data Sources</h3>
<p class="p-main" id="des_DS">The data sources is a container of files on which the analysis results can be found.</p>

<h3 class="h3-main">Streams</h3>
<p class="p-main" id="des_Streams">Streams is an entity containing the data sources. Once the files in the streams are opened, they stay opened and they keep some data in cache to make the next evaluations faster. To close the files, release the streams.</p>

<h3 class="h3-main">Support</h3>
<p class="p-main" id="des_Support">The support describes the model. It can be the mesh, geometric entities, time or frequency domain...</p>

<h3 class="h3-main">Fields Container</h3>
<p class="p-main" id="des_FC">The fields container is a container of fields, used mainly in transient, harmonic, modal or multi-steps static analysis, where we can have a field for each time step or for each frequency. Consequently the fields container can describle a complete analysis with all its details. The fields container is designed as a set of fields ordered through labels and ids. Labels identify how the fields are filtered. The most common fields container have the label "time" with ids corresponding to each time sets, the label "complex" will allow to separate real parts (id=0) from imaginary parts (id=1) in a harmonic analysis.</p>


<h3 class="h3-main">Meshed Region</h3>
<p class="p-main" id="des_MeshedRegion">The meshed region is dpf's entity describing a mesh. Node and element scopings, element types, connectivity (list of node indeces composing each element) and node coordinates are the fundamental entities composing the meshed region. It can also have materials, named selections...</p>



<h3 class="h3-main">Time Freq Support</h3>
<p class="p-main" id="des_TFSupport">The time freq support describes an analysis'temporal or frequential space. For a transient analysis all the time sets cumulatives indeces with their times are described. For a harmonic analysis, the real and imaginary frequencies, the RPMs, the load steps are described.</p>

</div><figure-types class="entity-drawing" id="fig_Operator"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="1194.223"
   height="294.93262"
   viewBox="0 0 1194.223 294.93259"
   id="svg2"
   version="1.1"
   inkscape:version="0.91 r13725"
   sodipodi:docname="operator_drawing.svg">
  <defs
     id="defs4" />
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.7"
     inkscape:cx="443.46206"
     inkscape:cy="372.58673"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1137"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1"
     units="px"
     showguides="false"
     fit-margin-top="0"
     fit-margin-left="0"
     fit-margin-right="0"
     fit-margin-bottom="0" />
  <metadata
     id="metadata7">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Layer 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(-196.92928,-419.59993)">
    <rect
       style="opacity:1;fill:none;fill-opacity:1;stroke:#000000;stroke-width:3.90756917;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="rect4140"
       width="584.10577"
       height="236.51965"
       x="480.6987"
       y="429.63202" />
    <text
       sodipodi:linespacing="125%"
       id="text4250"
       y="556.87451"
       x="705.0752"
       style="font-style:normal;font-weight:normal;font-size:43.03269577px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       xml:space="preserve"><tspan
         y="556.87451"
         x="705.0752"
         id="tspan4252"
         sodipodi:role="line"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:35.86058044px;font-family:Helvetica;-inkscape-font-specification:'Helvetica Bold'">operator</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="85.714287"
       y="1178.0765"
       id="text4410"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4412"
         x="85.714287"
         y="1178.0765" /></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="84.852814"
       y="1176.6111"
       id="text4457"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4459"
         x="84.852814"
         y="1176.6111" /></text>
    <g
       id="svg-required-2"
       transform="matrix(0.71721161,0,0,0.71721161,743.19892,83.129561)"
       inkscape:label="#g4224-0">
      <rect
         style="opacity:1;fill:#008000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0-1"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="518.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="572.18774"
         id="text4205-8-3"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7-0"
           x="343.6933"
           y="572.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#ffffff;fill-opacity:1">pin 0</tspan></text>
    </g>
    <g
       id="svg-required-1"
       transform="matrix(0.71721161,0,0,0.71721161,307.77855,83.129561)"
       inkscape:label="#g4224">
      <rect
         style="opacity:1;fill:#008000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="518.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="572.18774"
         id="text4205-8"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7"
           x="343.6933"
           y="572.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#ffffff;fill-opacity:1">pin 0</tspan></text>
    </g>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:43.03269577px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#018319;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="363.50027"
       y="496.58221"
       id="text4425"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4427"
         x="363.50027"
         y="496.58221"
         style="font-size:35.86058044px">fieldA</tspan></text>
    <g
       id="svg-optional-1"
       transform="matrix(0.71721161,0,0,0.71721161,307.77855,199.35832)"
       inkscape:label="#g4224-7">
      <rect
         style="opacity:1;fill:none;fill-opacity:1;stroke:#008000;stroke-width:5;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0-0"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="534.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="588.18774"
         id="text4205-8-9"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7-4"
           x="343.6933"
           y="588.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#000000;fill-opacity:1">pin 1</tspan></text>
    </g>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:43.03269577px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#018319;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="363.94681"
       y="624.28644"
       id="text4425-5"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4427-8"
         x="363.94681"
         y="624.28644"
         style="font-size:35.86058044px">fieldB</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:43.03269577px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#018319;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="1081.1036"
       y="496.58221"
       id="text4425-19-5"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4427-38-6"
         x="1081.1036"
         y="496.58221"
         style="font-size:35.86058044px">fieldOut</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:43.03269577px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#8b1485;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="480.55185"
       y="702.27997"
       id="text4463-1"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4465-5"
         x="480.55185"
         y="702.27997"
         style="font-size:35.86058044px;text-align:center;text-anchor:middle;fill:#8b1485;fill-opacity:1">inputs</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:43.03269577px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#8b1485;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="1063.7727"
       y="701.74591"
       id="text4463-1-7"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4465-5-0"
         x="1063.7727"
         y="701.74591"
         style="font-size:35.86058044px;text-align:center;text-anchor:middle;fill:#8b1485;fill-opacity:1">outputs</tspan></text>
    <flowRoot
       xml:space="preserve"
       id="flowRoot4492"
       style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       transform="translate(-50.071426,1172.2908)"><flowRegion
         id="flowRegion4494"><rect
           id="rect4496"
           width="225.71428"
           height="158.57143"
           x="715.71429"
           y="-1122.7142" /></flowRegion><flowPara
         id="flowPara4498" /></flowRoot>    <flowRoot
       xml:space="preserve"
       id="flowRoot4500"
       style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       transform="translate(-50.071426,1172.2908)"><flowRegion
         id="flowRegion4502"><rect
           id="rect4504"
           width="64.285713"
           height="111.42857"
           x="807.14288"
           y="-998.42853" /></flowRegion><flowPara
         id="flowPara4506" /></flowRoot>  </g>
</svg>
</figure-types><figure-types class="entity-drawing" id="fig_Workflow"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:osb="http://www.openswatchbook.org/uri/2009/osb"
   xmlns:dc="http://purl.org/dc/elements/1.1/"
   xmlns:cc="http://creativecommons.org/ns#"
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
   width="322mm"
   height="84mm"
   viewBox="0 0 1140.9447 297.63749"
   id="svg5968"
   version="1.1"
   inkscape:version="0.91 r13725"
   sodipodi:docname="workflow_drawing.svg"
   inkscape:export-filename="C:\Users\lparadis\OneDrive - ANSYS, Inc\Desktop\LPA_files\LPA_to_save\Travail en cours\DPF's schemes\workflow black box.png"
   inkscape:export-xdpi="90"
   inkscape:export-ydpi="90">
  <defs
     id="defs5970">
    <linearGradient
       id="linearGradient5773"
       osb:paint="solid">
      <stop
         style="stop-color:#ee777e;stop-opacity:1;"
         offset="0"
         id="stop5775" />
    </linearGradient>
  </defs>
  <sodipodi:namedview
     id="base"
     pagecolor="#ffffff"
     bordercolor="#666666"
     borderopacity="1.0"
     inkscape:pageopacity="0.0"
     inkscape:pageshadow="2"
     inkscape:zoom="0.98994949"
     inkscape:cx="457.50927"
     inkscape:cy="169.06143"
     inkscape:document-units="px"
     inkscape:current-layer="layer1"
     showgrid="false"
     inkscape:window-width="1920"
     inkscape:window-height="1137"
     inkscape:window-x="-8"
     inkscape:window-y="-8"
     inkscape:window-maximized="1" />
  <metadata
     id="metadata5973">
    <rdf:RDF>
      <cc:Work
         rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
        <dc:title />
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label="Calque 1"
     inkscape:groupmode="layer"
     id="layer1"
     transform="translate(0,-754.72478)">
    <rect
       style="fill:#000000;fill-opacity:0.02298851;stroke:#000000;stroke-width:1.06492531;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5976"
       width="755.47321"
       height="287.46432"
       x="229.78369"
       y="761.33521" />
    <flowRoot
       xml:space="preserve"
       id="flowRoot6590"
       style="font-style:normal;font-weight:normal;font-size:25px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"><flowRegion
         id="flowRegion6592"><rect
           id="rect6594"
           width="629.28571"
           height="221.42857"
           x="287.85715"
           y="266.23734"
           style="font-size:25px" /></flowRegion><flowPara
         id="flowPara6596" /></flowRoot>    <rect
       style="fill:#eeffaa;fill-opacity:1;stroke:#000000;stroke-width:1.56349313;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5630-6"
       width="46.712833"
       height="47.308529"
       x="986.98596"
       y="845.91534" />
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:42.64072037px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="1074.9828"
       y="837.46082"
       id="text5912-3-5"
       sodipodi:linespacing="125%"
       transform="scale(0.97118288,1.0296722)"><tspan
         sodipodi:role="line"
         id="tspan5914-1-9"
         x="1074.9828"
         y="837.46082">field </tspan><tspan
         sodipodi:role="line"
         x="1074.9828"
         y="890.76172"
         id="tspan4268">out</tspan></text>
    <flowRoot
       xml:space="preserve"
       id="flowRoot6867"
       style="font-style:normal;font-weight:normal;font-size:25px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"><flowRegion
         id="flowRegion6869"><rect
           id="rect6871"
           width="432.34528"
           height="82.832512"
           x="75.761444"
           y="-17.560537"
           style="font-size:25px" /></flowRegion><flowPara
         id="flowPara6873" /></flowRoot>    <path
       style="fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:1.46575904px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 569.23534,869.35452 71.82661,0"
       id="path7043"
       inkscape:connector-curvature="0" />
    <path
       style="fill:#000000;fill-rule:evenodd;stroke:#000000;stroke-width:1.42135739px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       d="m 641.11451,865.0482 0,8.40835 3.48603,-3.97319 z"
       id="path7047"
       inkscape:connector-curvature="0" />
    <flowRoot
       xml:space="preserve"
       id="flowRoot4217"
       style="font-style:normal;font-weight:normal;font-size:25px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       transform="translate(0,308.26772)"><flowRegion
         id="flowRegion4219"><rect
           id="rect4221"
           width="833.37585"
           height="115.15739"
           x="288.90363"
           y="488.52588"
           style="font-size:25px" /></flowRegion><flowPara
         id="flowPara4223" /></flowRoot>    <flowRoot
       xml:space="preserve"
       id="flowRoot4225"
       style="font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"><flowRegion
         id="flowRegion4227"><rect
           id="rect4229"
           width="179.80716"
           height="113.13708"
           x="21.213203"
           y="136.93045" /></flowRegion><flowPara
         id="flowPara4231" /></flowRoot>    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:42.64072037px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="169.34126"
       y="828.91205"
       id="text5912-3-5-2"
       sodipodi:linespacing="125%"
       transform="scale(0.97118289,1.0296722)"><tspan
         sodipodi:role="line"
         id="tspan5914-1-9-5"
         x="184.33214"
         y="828.91205"
         style="text-align:end;text-anchor:end">data </tspan><tspan
         sodipodi:role="line"
         x="169.34126"
         y="882.21295"
         id="tspan4235"
         style="text-align:end;text-anchor:end">sources</tspan></text>
    <flowRoot
       xml:space="preserve"
       id="flowRoot4237"
       style="font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       transform="translate(0,846.85077)"><flowRegion
         id="flowRegion4239"><rect
           id="rect4241"
           width="1212.1831"
           height="392.94934"
           x="-63.63961"
           y="-103.59487" /></flowRegion><flowPara
         id="flowPara4243" /></flowRoot>    <rect
       style="fill:#ff5555;fill-opacity:1;stroke:#000000;stroke-width:1.56349313;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5630-6-8"
       width="46.712837"
       height="47.308537"
       x="181.60393"
       y="843.42072" />
    <rect
       style="fill:#ff5555;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1.20000005;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5794"
       width="29.7995"
       height="27.526657"
       x="230.81985"
       y="852.35223" />
    <rect
       style="fill:#eeffaa;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1.20000005;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5794-1"
       width="29.799496"
       height="27.526653"
       x="538.67163"
       y="854.31335" />
    <flowRoot
       xml:space="preserve"
       id="flowRoot4863"
       style="fill:black;stroke:none;stroke-opacity:1;stroke-width:1px;stroke-linejoin:miter;stroke-linecap:butt;fill-opacity:1;font-family:sans-serif;font-style:normal;font-weight:normal;font-size:40px;line-height:125%;letter-spacing:0px;word-spacing:0px;text-anchor:end;text-align:end"><flowRegion
         id="flowRegion4865"><rect
           id="rect4867"
           width="404.061"
           height="308.09653"
           x="238.396"
           y="45.099659" /></flowRegion><flowPara
         id="flowPara4869" /></flowRoot>    <rect
       style="opacity:1;fill:#000000;fill-opacity:0.09770115;stroke:#000000;stroke-width:1.84862089;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="rect4140"
       width="276.33292"
       height="111.89441"
       x="261.20605"
       y="842.93201" />
    <text
       sodipodi:linespacing="125%"
       id="text4250"
       y="908.17963"
       x="324.92932"
       style="font-style:normal;font-weight:normal;font-size:20.35821724px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       xml:space="preserve"><tspan
         y="908.17963"
         x="324.92932"
         id="tspan4252"
         sodipodi:role="line"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:22.49999809px;font-family:Helvetica;-inkscape-font-specification:'Helvetica Bold'">Displacement</tspan></text>
    <g
       id="svg-required-2"
       transform="matrix(0.33930361,0,0,0.33930361,385.39153,679.00623)"
       inkscape:label="#g4224-0">
      <rect
         style="opacity:1;fill:#008000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0-1"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="518.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="572.18774"
         id="text4205-8-3"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7-0"
           x="343.6933"
           y="572.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#ffffff;fill-opacity:1">pin 0</tspan></text>
    </g>
    <g
       id="svg-required-1"
       transform="matrix(0.33930361,0,0,0.33930361,179.39976,679.00623)"
       inkscape:label="#g4224">
      <rect
         style="opacity:1;fill:#870000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="518.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="572.18774"
         id="text4205-8"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7"
           x="343.6933"
           y="572.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#ffffff;fill-opacity:1">pin 0</tspan></text>
    </g>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:20.35821724px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#8b1485;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="261.1366"
       y="971.91827"
       id="text4463-1"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4465-5"
         x="261.1366"
         y="971.91827"
         style="font-size:16.96518135px;text-align:center;text-anchor:middle;fill:#8b1485;fill-opacity:1">inputs</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:20.35821724px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#8b1485;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="537.05084"
       y="971.66571"
       id="text4463-1-7"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4465-5-0"
         x="537.05084"
         y="971.66571"
         style="font-size:16.96518135px;text-align:center;text-anchor:middle;fill:#8b1485;fill-opacity:1">outputs</tspan></text>
    <rect
       style="fill:#ff5555;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1.20000005;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5794-6"
       width="29.799496"
       height="27.526653"
       x="645.89673"
       y="854.61816" />
    <rect
       style="fill:#eeffaa;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1.20000005;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
       id="rect5794-1-9"
       width="29.799492"
       height="27.526649"
       x="953.74847"
       y="856.57922" />
    <rect
       style="opacity:1;fill:#000000;fill-opacity:0.09770115;stroke:#000000;stroke-width:1.84862089;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
       id="rect4140-7"
       width="276.33289"
       height="111.89439"
       x="676.2829"
       y="845.19788" />
    <text
       sodipodi:linespacing="125%"
       id="text4250-5"
       y="908.83838"
       x="780.18475"
       style="font-style:normal;font-weight:normal;font-size:20.35821724px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       xml:space="preserve"><tspan
         y="908.83838"
         x="780.18475"
         id="tspan4252-9"
         sodipodi:role="line"
         style="font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:22.49999809px;font-family:Helvetica;-inkscape-font-specification:'Helvetica Bold'">Norm</tspan></text>
    <g
       id="svg-required-2-2"
       transform="matrix(0.33930361,0,0,0.33930361,800.46842,681.27225)"
       inkscape:label="#g4224-0">
      <rect
         style="opacity:1;fill:#008000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0-1-6"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="518.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="572.18774"
         id="text4205-8-3-9"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7-0-1"
           x="343.6933"
           y="572.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#ffffff;fill-opacity:1">pin 0</tspan></text>
    </g>
    <g
       id="svg-required-1-3"
       transform="matrix(0.33930361,0,0,0.33930361,594.47664,681.27225)"
       inkscape:label="#g4224">
      <rect
         style="opacity:1;fill:#870000;fill-opacity:1;stroke:none;stroke-width:10;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1"
         id="rect4192-0-3"
         width="173.28427"
         height="79.285713"
         x="257.85684"
         y="518.09174"
         ry="14.805184" />
      <text
         xml:space="preserve"
         style="font-style:normal;font-weight:normal;font-size:60px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
         x="343.6933"
         y="572.18774"
         id="text4205-8-31"
         sodipodi:linespacing="125%"><tspan
           sodipodi:role="line"
           id="tspan4207-7-9"
           x="343.6933"
           y="572.18774"
           style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:semi-condensed;font-size:50px;font-family:'Lucida Console';-inkscape-font-specification:'Lucida Console Semi-Condensed';text-align:center;text-anchor:middle;fill:#ffffff;fill-opacity:1">pin 0</tspan></text>
    </g>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:20.35821724px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#8b1485;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="676.21344"
       y="974.1842"
       id="text4463-1-5"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4465-5-9"
         x="676.21344"
         y="974.1842"
         style="font-size:16.96518135px;text-align:center;text-anchor:middle;fill:#8b1485;fill-opacity:1">inputs</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:20.35821724px;line-height:125%;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#8b1485;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="952.12769"
       y="973.93164"
       id="text4463-1-7-8"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4465-5-0-3"
         x="952.12769"
         y="973.93164"
         style="font-size:16.96518135px;text-align:center;text-anchor:middle;fill:#8b1485;fill-opacity:1">outputs</tspan></text>
    <text
       xml:space="preserve"
       style="font-style:normal;font-weight:normal;font-size:40px;line-height:125%;font-family:sans-serif;text-align:end;letter-spacing:0px;word-spacing:0px;text-anchor:end;fill:#000000;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
       x="901.05603"
       y="809.92584"
       id="text4208"
       sodipodi:linespacing="125%"><tspan
         sodipodi:role="line"
         id="tspan4210"
         x="901.05603"
         y="809.92584">Total deformation workflow</tspan></text>
  </g>
</svg>
</figure-types></div><div class="main_text" id="dataAPIs"><h1>Using DPF's entities in scripting</h1><div><h2 class="h2-main">Scoping</h2>
<h3 class="h3-main">Create a Scoping</h3>
<p class="p-main" id="des_APINewScoping">The Scoping is a set of entity ids defined on a location (the location is optional). </p>
<h3 class="h3-main">Get Scoping's data</h3>
<p class="p-main" id="des_APIAccessScoping">The Scoping's location and ids can be accessed with:</p>


<h2 class="h2-main">Field</h2>
<h3 class="h3-main">Create a Field</h3>
<p class="p-main" id="des_APINewField">The minimum requirement for a well defined Field is for it to have a dimensionality (scalar, 3 components vector, 6 components symmetrical matrix...), a location ("Nodal", "Elemental", "ElementalNodal", "Timefrq"...), a data vector and a scoping with ids. The user can also set the number of shell layers. If the field has one elementary data by entity (elementary data size = number of components for "Nodal" or "Elemental" field for example), then the data vector can be set directly. If a more complex field is required ("ElementalNodal" Field for example), the data can be set entity by entity. </p>
<h3 class="h3-main">Get Field's data</h3>
<p class="p-main" id="des_APIAccessField">The Field's side information as well as the data in itself can be accessed with:</p>


<h2 class="h2-main">Fields Container</h2>
<h3 class="h3-main">Get Fields Container's data</h3>
<p class="p-main" id="des_APIAccessFieldsContainer">The Fields Container is a vector of Fields and all the Fields are ordered with labels and ids. Most commonly, the Fields Container is scoped on "time" label and the ids are the time or frequency sets:</p>


<h2 class="h2-main">Data Sources</h2>
<h3 class="h3-main">Create Data Sources</h3>
<p class="p-main" id="des_APINewDataSources">Data Sources is the entity containing the different path to the result files of an analysis. An extension key ('rst' for example) is used to choose which files represent results files, the other one being accessory files. See more information for using Data Sources in mechanical in "How to use DPF's package / IPython" menu.</p>



<h2 class="h2-main">Meshed Region</h2>
<h3 class="h3-main">Get Meshed Region's data from DataSources</h3>
<p class="p-main" id="des_APIAccessMesh">A model is usually represented by a Meshed Region in DPF. The mesh provider operator allows to access an analysis' mesh. The user can then get different informations in the mesh like the coordinates of all the nodes and the connectivity between elements and nodes.</p>


<h2 class="h2-main">Time Freq Support</h2>
<h3 class="h3-main">Get Time Freq Support's data from DataSources</h3>
<p class="p-main" id="des_APIAccessTimeFreq">The time or frequency space of an analysis is described by the Time Freq Support entity in DPF. It gives access to real and imaginary sets.</p>

</div><apis-scripts id="script_APINewScoping" ipython="my_scoping = dpf.data.Scoping()<br>my_scoping.Location = 'Nodal' #optional<br>my_scoping.Ids = range(1,11)<br>" cpython= "my_scoping = dpf.Scoping()<br>my_scoping.location = 'Nodal' #optional<br>my_scoping.ids = list(range(1,11))<br>"></apis-scripts><apis-scripts id="script_APIAccessScoping" ipython="my_scoping.Location<br>my_scoping.Ids<br>" cpython= "my_scoping.location<br>my_scoping.ids<br>"></apis-scripts><apis-scripts id="script_APINewField" ipython="import mech_dpf<br>import Ans.DataProcessing as dpf<br><br>num_entities = 2<br><br>#create a field by RESERVING a size of num_entities<br># for the most common dimensionalities<br>my_field = dpf.data.FieldsFactory.CreateScalarField(num_entities, 'Nodal')<br>my_field = dpf.data.FieldsFactory.CreateVectorField(num_entities, 'Nodal')<br>my_field = dpf.data.FieldsFactory.CreateTensorField(num_entities, 'Elemental')<br><br><br>my_scoping = dpf.data.Scoping()<br>my_scoping.Location = 'Elemental'<br>my_scoping.Ids = range(1,3)<br><br>my_field.Scoping = my_scoping<br><br>#sym matrix are defined by 6 components in the order XX,YY,ZZ,XY,YZ,XZ<br>#all the data at once<br>my_data = [1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0] #2 sym identity tensors<br>my_field.Data = my_data<br><br>#or entity by entity once the scoping is already set<br>my_elem_data = [1.0,1.0,1.0,0.0,0.0,0.0]<br>my_field.UpdateEntityDataByEntityIndex(0,my_elem_data) #index, data<br>my_field.UpdateEntityDataByEntityIndex(1,my_elem_data) #index, data<br><br>#or entity by entity by pushing back the scoping ids and the data<br>my_field = dpf.data.FieldsFactory.CreateTensorField(num_entities, 'Elemental')<br>my_field.Add(1,my_elem_data) #id, data<br>my_field.Add(2,my_elem_data) #id, data<br>" cpython= "from ansys import dpf<br><br>num_entities = 2<br><br># for the most common dimensionalities<br>my_field = dpf.Field(num_entities, dpf.natures.scalar,'Nodal')<br>my_field = dpf.Field(num_entities, dpf.natures.vector,'ElementalNodal')<br>my_field = dpf.Field(num_entities, dpf.natures.symmatrix,'Elemental')<br><br><br>my_scoping = dpf.Scoping()<br>my_scoping.location = 'Elemental'<br>my_scoping.ids = list(range(1,3))<br><br>my_field.scoping = my_scoping<br><br>#sym matrix are defined by 6 components in the order XX,YY,ZZ,XY,YZ,XZ<br>#all the data at once<br>my_data = [1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0] #2 sym identity tensors<br>my_field.data = my_data<br><br>#or entity by entity<br>my_elem_data = [1.0,1.0,1.0,0.0,0.0,0.0]<br>my_field.set_entity_data(my_elem_data, index=0, scopingid=1)<br>my_field.set_entity_data(my_elem_data, index=1, scopingid=2)<br>"></apis-scripts><apis-scripts id="script_APIAccessField" ipython="my_field.ComponentCount #returns the nuber of component of the elementary data<br>my_field.Location<br>my_field.Scoping<br>my_field.unit<br><br>my_field.Data #returns the full list of data<br>my_field.GetEntityDataByIndex(0) #returns the data list for the first entity<br>my_field.GetEntityDataById(1) #returns the data list for the entity of scoping's id 1<br>" cpython= "my_field.component_count #returns the number of component of the elementary data<br>my_field.location<br>my_field.scoping<br>my_field.unit<br>my_field.shape #returns a tuple of data format<br><br>my_field.data #returns a numpy array of the data<br>my_field.get_entity_data(0) #returns the data numpy array for the first entity<br>my_field.get_entity_data_by_id(1) #returns the data numpy array for the entity of scoping's id 1<br>"></apis-scripts><apis-scripts id="script_APIAccessFieldsContainer" ipython="import Ans.DataProcessing as dpf <br><br>u_op = dpf.operators.result.displacement() <br>u_op.inputs.data_sources.Connect(my_data_sources) <br>my_fields_container = u_op.outputs.fields_container.GetData()<br><br>my_fields_container.FieldCount<br><br>index=0<br>#returns the labels and ids corresponding to the first field<br>my_fields_container.GetScoping(index) #ie. {'time',1} for the first time set<br>#return the real Fields on {'time',1}<br>my_field = my_fields_container.GetFieldByTimeId(1)<br>my_field = my_fields_container.Get({'time':1}) #same<br><br>my_field = my_fields_container[0] #returns the first Field<br>" cpython= "from ansys import dpf<br><br>model = dpf.Model(my_data_sources)<br>u_op = model.results.displacement()<br>my_fields_container = u_op.outputs.fields_container()<br><br>len(my_fields_container)<br><br>index=0<br>#returns the labels and ids corresponding to the first field<br>my_fields_container.get_label_space(index) #ie. {'time',1} for the first time set<br>#return the real Fields on {'time',1}<br>my_field = my_fields_container.get_fields_by_time_complex_ids(1,0) 	<br>my_field = my_fields_container.get_fields({'time':1},{'complex':0}) #same<br><br>my_field = my_fields_container[0] #returns the first Field<br>"></apis-scripts><apis-scripts id="script_APINewDataSources" ipython="my_data_sources = dpf.data.DataSources()<br>my_data_sources.SetResultFilePath(r'c:/temp/file.rst','rst')<br>my_data_sources.AddFilePath(r'c:/temp/ds.dat')<br>" cpython= "my_data_sources = dpf.DataSources()<br>my_data_sources.set_result_file_path(r'c:/temp/file.rst')<br>my_data_sources.add_file_path(r'c:/temp/ds.dat')<br>"></apis-scripts><apis-scripts id="script_APIAccessMesh" ipython="mesh_prov = dpf.operators.mesh.provider()<br>mesh_prov.inputs.data_sources.Connect(my_data_sources)<br>mesh = mesh_prov.outputs.mesh.GetData()<br><br>#access elements scoping<br>my_elements_scoping = mesh.ElementScoping<br><br>#access nodes scoping<br>my_nodes_scoping = mesh.NodeScoping<br><br>#get connectivity (ordered node ids) of one element<br>my_el_1 = mesh.ElementById(1)<br>my_el_1.NodeIds<br>#connectivity with only primary (corner) nodes<br>my_el_1.CornerNodeIds <br>#only secondary (mid side) nodes<br>my_el_1.MidNodeIds<br><br>#get coordinates<br>mesh.CoordinatesField #complete 3D field with scoping = mesh.NodesScoping<br>#or node by node<br>my_node_1 = mesh.NodeById(1)<br>my_node_1.X<br>my_node_1.Y<br>my_node_1.Z<br>" cpython= "from ansys import dpf<br><br>my_model = dpf.Model(my_data_sources)<br>mesh = my_model.metadata.meshed_region<br><br>#access elements scoping<br>my_elements_scoping = mesh.elements.scoping<br><br>#access nodes scoping<br>my_nodes_scoping = mesh.nodes.scoping<br><br>#get connectivity (ordered node ids) of one element<br>my_el_1 = mesh.elements.element_by_id(1)<br>my_el_1.node_ids<br>#element shape<br>my_el_1.element_shape #solid shell or beams<br><br>#get coordinates<br>mesh.nodes.coordinates_field #complete 3D field with scoping = mesh.nodes.scoping<br>#or node by node<br>my_node_1 = mesh.nodes.node_by_id(1)<br>my_node_1.coordinates #[x y z] coordinates <br>"></apis-scripts><apis-scripts id="script_APIAccessTimeFreq" ipython="time_freq_prov = dpf.operators.metadata.time_freq_provider()<br>time_freq_prov.inputs.data_sources.Connect(my_data_sources)<br>time_freq = time_freq_prov.outputs.time_freq_support.GetData()<br><br>#get number of time/freq sets<br>time_freq.NumberSets<br><br>#get field of real time freqs<br>my_time_freq_field = time_freq.TimeFreqs<br>my_time_freq_field.unit #usually s or Hz<br>#get time or freqs on the first load step<br>my_time_freq_field.GetEntityDataById(1)<br><br>#get field of imaginary time freqs<br>my_im_time_freq_field = time_freq.ImaginaryFreqs<br>" cpython= "from ansys import dpf<br><br>my_model = dpf.Model(my_data_sources)<br>time_freq = my_model.metadata.time_freq_support<br><br>#get number of time/freq sets<br>time_freq.n_sets<br><br>#get field of real time freqs<br>my_time_freq_field = time_freq.frequencies<br>my_time_freq_field.unit #usually s or Hz<br>#get time or freqs on the first load step<br>my_time_freq_field.get_entity_data_by_id(1)<br><br>#get field of imaginary time freqs<br>my_im_time_freq_field = time_freq.complex_frequencies<br>"></apis-scripts></div><div class="main_text" id="exampleWorkflows"><h1>Example of workflows and their script</h1><div><workflow-example id="Total deformation" description ="This elementary workflow allows the user to simply read a displacement vector from an analysis and compute its norm." ipython="import Ans.DataProcessing as dpf <br>my_data_sources = dpf.data.DataSources(my_file_path)<br>u_op = dpf.operators.result.displacement() <br>u_op.inputs.data_sources.Connect(my_data_sources) <br>norm_op = dpf.operators.math.norm() <br>norm_op.inputs.field.Connect(u_op.outputs.fields_container) <br>my_u_norm = norm_op.outputs.field.GetData()<br>" cpython="from ansys import dpf<br>dpf.start_local_server()<br><br>my_data_sources = dpf.DataSources(my_path)<br>my_model = dpf.Model(my_data_sources)<br><br>u_op = my_model.results.displacement()<br>norm_op = my_model.operator('norm_fc')<br>norm_op.inputs.connect(u_op.outputs)<br>my_u_norm = norm_op.outputs.fields_container()<br>" workflow_code="import mech_dpf <br>import Ans.DataProcessing as dpf <br><br>my_data_sources = dpf.data.DataSources(my_file_path)<br>u_op = dpf.operators.result.displacement()  <br>u_op.inputs.data_sources.Connect(my_data_sources)  <br>norm_op = dpf.operators.math.norm()  <br>norm_op.inputs.fields_container.Connect(u_op.outputs.fields_container) <br>wf = dpf.data.Workflow() <br>wf.Add(norm_op) <br>wf.SetOutputContour(norm_op)<br>wf.Record('wf_id', True) <br>"</worflow></div><div><workflow-example id="Min max over time of Von Mises stress" description ="This workflow allows the user to read the stress tensors for a range of time steps from an analysis, to implicitly average those elemental nodal tensors to a nodal location, to compute it's Von Mises equivalent and finally, to compute the minimum and the maximum over time for each component of the nodal equivalent tensors. This workflow is an example of use of the time scoping pin. This pin expects a scoping in input and allows the user to choose the time or frequency sets of his results." ipython="import Ans.DataProcessing as dpf <br>my_data_sources = dpf.data.DataSources(my_file_path)<br>s_eqv_op = dpf.operators.result.stress_von_mises() <br>s_eqv_op.inputs.data_sources.Connect(my_data_sources) <br>s_eqv_op.inputs.time_scoping.Connect(my_time_scoping) <br>min_max_op = dpf.operators.min_max.min_max_fc() <br>min_max_op.inputs.fields_container.Connect(s_eqv_op.outputs.fields_container) <br>my_min = min_max_op.outputs.field_min.GetData() <br>my_max = min_max_op.outputs.field_max.GetData()<br>" cpython="from ansys import dpf<br>dpf.start_local_server()<br><br>my_data_sources = dpf.DataSources(my_path)<br>my_model = dpf.Model(my_data_sources)<br><br>s_op = my_model.results.stress()<br>s_op.inputs.time_scoping.connect([1])<br>s_op.inputs.requested_location.connect('Nodal')<br>eqv_op = my_model.pperator('eqv_fc')<br>eqv_op.inputs.connect(s_op.outputs)<br><br>min_max_op = my_model.operator('min_max_fc')<br>min_max_op.inputs.connect(eqv_op.outputs)<br><br>my_min = min_max_op.outputs.field_min()<br>                   <br>my_max = min_max_op.outputs.field_max()<br>" workflow_code="import mech_dpf <br>import Ans.DataProcessing as dpf <br><br>my_data_sources = dpf.data.DataSources() <br>my_data_sources.SetResultFilePath(my_file_path, 'rst') <br>my_time_scoping = dpf.data.Scoping([1])# the first set <br>s_eqv_op=dpf.operators.result.stress_von_mises() <br>s_eqv_op.inputs.data_sources.Connect(my_data_sources) <br>s_eqv_op.inputs.time_scoping.Connect(my_time_scoping) <br>wf = dpf.data.Workflow() <br>wf.Add(s_eqv_op) <br>wf.SetOutputContour(s_eqv_op) <br>wf.Record('wf_id', True)  <br>"</worflow></div><div><workflow-example id="Strain tensors scoped on named selection" description ="This workflow is an example of use of the mesh scoping in input of a result reader. Here, the user can extract a mesh scoping (a set of spatial entities: node or elements for example) from a named selection created in mechanical or mapdl. This mesh scoping is then used as an input of a strain tensors reader. The output of this workflow is the strain tensors scoped only on the named selection. Two different versions of this workflow is available: the first one extracts the elements of the named selection and returns an elemental nodal field, the second extracts the nodes of the named selection, the strain reader will consequently average the tensors on the node to take into account the nodal mesh scoping in input." ipython="import Ans.DataProcessing as dpf <br>my_data_sources = dpf.data.DataSources(my_file_path) <br>ns_op=dpf.operators.scoping.on_named_selection() <br>ns_op.inputs.data_sources.Connect(my_data_sources)<br>ns_op.inputs.requested_location.Connect('Elemental') #first version with elemental scoping <br>ns_op.inputs.named_selection_name.Connect(my_named_selection_name)<br>strain_op = dpf.operators.result.elastic_strain() <br>strain_op.inputs.data_sources.Connect(my_data_sources) <br>strain_op.inputs.mesh_scoping.Connect(ns_op.outputs.mesh_scoping)<br>my_elemental_nodal_strains = strain_op.outputs.fields_container.GetData() <br><br>ns_op.inputs.requested_location.Connect('Nodal') #second version with nodal scoping <br>my_nodal_strains = strain_op.outputs.fields_container.GetData() <br>" cpython="from ansys import dpf<br>dpf.start_local_server()<br><br>my_data_sources = dpf.DataSources(my_path)<br>my_model = dpf.Model(my_data_sources)<br><br>strain_op = my_model.results.strain()<br><br>ns_op = my_model.operator('scoping_provider_by_ns')<br>ns_op.inputs.requested_location.connect('Elemental') #first version with elemental scoping <br>ns_op.inputs.named_selection_name.connect(my_named_selection_name)<br><br>strain_op.inputs.connect(ns_op.outputs)<br>my_elemental_nodal_strains = strain_op.outputs.fields_container()<br><br>ns_op.inputs.requested_location.connect('Nodal') #second version with nodal scoping <br>my_nodal_strains = strain_op.outputs.fields_container()<br>" workflow_code="import mech_dpf <br>import Ans.DataProcessing as dpf <br><br>my_data_sources = dpf.data.DataSources() <br>my_data_sources.SetResultFilePath(rmy_file_path, 'rst') <br>ns_op=dpf.operators.scoping.on_named_selection()   <br>ns_op.inputs.data_sources.Connect(my_data_sources)  <br>ns_op.inputs.requested_location.Connect('Elemental') #first version with elemental scoping   <br>ns_op.inputs.named_selection_name.Connect(my_named_selection_name)  <br>strain_op = dpf.operators.result.elastic_strain_X()  <br>strain_op.inputs.data_sources.Connect(my_data_sources)  <br>strain_op.inputs.mesh_scoping.Connect(ns_op.outputs.mesh_scoping)  <br>to_elemental_op = dpf.operators.averaging.to_elemental_fc() #make an elemental average on the elemental nodal field <br>to_elemental_op.Connect(strain_op)  <br>wf = dpf.data.Workflow() <br>wf.Add(ns_op) <br>wf.Add(strain_op) <br>wf.Add(to_elemental_op)  <br>wf.SetOutputContour(to_elemental_op) <br>wf.Record('wf_id', True) <br>"</worflow></div><div><workflow-example id="Stress tensors scoped on one element type" description ="This workflow is another example of use of the mesh scoping in input of a result reader. Here, the user requests a mesh scoping including all the elements of mapdl element type 186. This mesh scoping is then used as an input of a stress tensors reader. The output of this workflow is the stress tensors on all the elements of element type 186." ipython="import Ans.DataProcessing as dpf <br>my_data_sources = dpf.data.DataSources(my_file_path) <br>scop_extract_op = dpf.operators.scoping.on_property()<br>scop_extract_op.inputs.data_sources.Connect(my_data_sources)<br>scop_extract_op.inputs.requested_location.Connect('Elemental') # elemental scoping <br>scop_extract_op.inputs.property_name.Connect('mapdl_element_type')<br>scop_extract_op.inputs.scalar_int.Connect(186)<br>stress_op = dpf.operators.result.stress() <br>stress_op.inputs.data_sources.Connect(my_data_sources) <br>stress_op.inputs.mesh_scoping.Connect(scop_extract_op.outputs.mesh_scoping)<br>my_elemental_nodal_stress = stress_op.outputs.fields_container.GetData() <br>" cpython="from ansys import dpf<br>dpf.start_local_server()<br><br>my_data_sources = dpf.DataSources(my_path)<br>my_model = dpf.Model(my_data_sources)<br><br>stress_op = my_model.results.stress()<br><br>scop_extract_op = my_model.operator('scoping_provider_by_prop')<br>scop_extract_op.inputs.data_sources.connect(my_data_sources)<br>scop_extract_op.inputs.requested_location.connect('Elemental') # elemental scoping <br>scop_extract_op.inputs.property_name.connect('mapdl_element_type')<br>scop_extract_op.inputs.scalar_int.connect(186)<br><br>stress_op.inputs.mesh_scoping.connect(scop_extract_op.outputs)<br>my_elemental_nodal_stress = stress_op.outputs.fields_container() <br>" workflow_code="import mech_dpf <br>import Ans.DataProcessing as dpf  <br><br>my_data_sources = dpf.data.DataSources() <br>my_data_sources.SetResultFilePath(my_file_path, 'rst')   <br>scop_extract_op = dpf.operators.scoping.on_property() <br>scop_extract_op.inputs.data_sources.Connect(my_data_source) <br>scop_extract_op.inputs.requested_location.Connect('Elemental') <br>scop_extract_op.inputs.property_name.Connect('mapdl_element_type') <br>scop_extract_op.inputs.scalar_int.Connect(186)  <br>stress_op = dpf.operators.result.stress()  <br>stress_op.inputs.data_sources.Connect(my_data_source)  <br>stress_op.inputs.mesh_scoping.Connect(scop_extract_op.outputs.mesh_scoping)  <br>wf = dpf.data.Workflow() <br>wf.Add(scop_extract_op) <br>wf.Add(stress_op) <br>wf.SetOutputContour(stress_op) <br>wf.Record('wf_id', True)<br>"</worflow></div><div><workflow-example id="High pass filtering on elemental stress" description ="This advanced workflow computes the normal ZZ stress averaged on elements and apply a high pass filter keeping all the stress values higher than 0.5*maximum stress." ipython="import mech_dpf<br>import Ans.DataProcessing as dpf<br><br>my_data_source = dpf.data.DataSources() <br><br>#please set the result file path to the right path<br>my_data_source.SetResultFilePath(my_path,'rst')<br><br>s = dpf.operators.result.stress()<br>s.inputs.data_sources.Connect(my_data_source)<br><br>to_elemental = dpf.operators.averaging.to_elemental_fc()<br>to_elemental.inputs.fields_container.Connect(s.outputs.fields_container)<br><br>comp =dpf.operators.logic.component_selector_fc()	<br>comp.inputs.component_number.Connect(2)<br>comp.inputs.fields_container.Connect(to_elemental.outputs.fields_container)<br><br>min_max = dpf.operators.min_max.min_max_over_label_fc()<br>min_max.inputs.fields_container.Connect(comp.outputs.fields_container)<br>min_max.inputs.label.Connect('time')<br><br>scale = dpf.operators.math.scale()<br>scale.inputs.ponderation.Connect(0.5)<br>scale.inputs.field.Connect(min_max.outputs.field_max)<br><br>high_pass = dpf.operators.filter.field.high_pass_fc()<br>high_pass.inputs.fields_container.Connect(comp.outputs.fields_container)<br>high_pass.inputs.threshold.Connect(scale.outputs.field)<br><br>fields = high_pass.outputs.fields_container.GetData()<br>" cpython="from ansys import dpf<br>dpf.start_local_server()<br><br>#please set the result file path to the right path<br>my_data_source = dpf.DataSources(my_path) <br>my_model = dpf.Model(my_data_source)<br><br>s = my_model.results.stress()<br><br>to_elemental = my_model.operator('entity_average_fc')<br>to_elemental.inputs.connect(s.outputs)<br><br>comp = my_model.operator('component_selector_fc')<br>comp.inputs.component_number.connect(2)<br>comp.inputs.connect(to_elemental.outputs)<br><br>min_max =  my_model.operator('min_max_over_label_fc')<br>min_max.inputs.connect(comp.outputs)<br>min_max.inputs.label.connect('time')<br><br>scale = my_model.operator('scale')<br>scale.inputs.ponderation.connect(0.5)<br>scale.inputs.field.connect(min_max.outputs.field_max)<br><br>high_pass = my_model.operator('core::field::high_pass_fc')<br>high_pass.inputs.fields_container.connect(comp.outputs.fields_container)<br>high_pass.inputs.threshold.connect(scale.outputs.field)<br><br>fields = high_pass.outputs.fields_container()<br>" workflow_code="import mech_dpf<br>import Ans.DataProcessing as dpf<br><br>my_data_source = dpf.data.DataSources()<br><br>#please set the result file path to the right path<br>my_data_source.SetResultFilePath(my_path, 'rst')<br><br>s = dpf.operators.result.stress()<br>s.inputs.data_sources.Connect(my_data_source)<br><br>to_elemental = dpf.operators.averaging.to_elemental_fc()<br>to_elemental.inputs.fields_container.Connect(s.outputs.fields_container)<br><br>comp = dpf.operators.logic.component_selector_fc()<br>comp.inputs.component_number.Connect(2)<br>comp.inputs.fields_container.Connect(to_elemental.outputs.fields_container)<br><br>min_max = dpf.operators.min_max.min_max_over_label_fc()<br>min_max.inputs.fields_container.Connect(comp.outputs.fields_container)<br>min_max.inputs.label.Connect('time')<br><br>scale = dpf.operators.math.scale()<br>scale.inputs.ponderation.Connect(0.5)<br>scale.inputs.field.Connect(min_max.outputs.field_max)<br><br>high_pass = dpf.operators.filter.field.high_pass_fc()<br>high_pass.inputs.fields_container.Connect(comp.outputs.fields_container)<br>high_pass.inputs.threshold.Connect(scale.outputs.field)<br><br>wf = dpf.data.Workflow()<br>wf.Add(s)<br>wf.Add(to_elemental)<br>wf.Add(comp)<br>wf.Add(min_max)<br>wf.Add(scale)<br>wf.Add(high_pass)<br><br>wf.SetOutputContour(high_pass)<br><br><br>u = dpf.operators.result.displacement()<br>u.inputs.data_sources.Connect(my_data_source)<br><br>wf.SetOutputWarpField(u)<br>wf.Record('wf_id', True)<br><br>"</worflow></div></div><div class="operator" id="mass" scripting_name="mass"plugin="core"cat="geo"><h1 class="op-des-h1">geo: mass</h1><op-description description="Compute the mass of a set of elements."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="Mesh scoping, if not set, all the elements of the mesh are considered." types="scoping" optional="true"></pin-def><pin-def name="field" n="2" doc="Elemental or nodal ponderation used in computation." types="field" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mass" cat="geo" plugin="core" cpp-name="topology::mass"></scripting-part></div><div class="operator" id="unit convert (fields container)" scripting_name="unit_convert_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: unit convert (fields container)</h1><op-description description="Convert an input fields container of a given unit to another unit."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="unit_name" n="1" doc="unit as a string, ex 'm' for meter, 'Pa' for pascal,..." types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="unit_convert_fc" cat="math" plugin="core" cpp-name="unit_convert_fc"></scripting-part></div><div class="operator" id="time of min" scripting_name="time_of_min"plugin="core"cat="math"><h1 class="op-des-h1">math: time of min</h1><op-description description="Evaluates time/frequency of minimum."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="angle" n="1" doc="Phase angle used for complex field container" types="double" optional="true"></pin-def><pin-def name="unit_name" n="2" doc="Phase angle unit. Default is radian." types="string" optional="true"></pin-def><pin-def name="abs_value" n="3" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="compute_amplitude" n="4" doc="Do calculate amplitude." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="time_of_min" cat="math" plugin="core" cpp-name="time_of_min"></scripting-part></div><div class="operator" id="-" scripting_name="minus"plugin="core"cat="math"><h1 class="op-des-h1">math: -</h1><op-description description="Computes the difference of two fields. If one field's scoping has 'overall' location, then these field's values are applied on the entire other field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="minus" cat="math" plugin="core" cpp-name="minus"></scripting-part></div><div class="operator" id="plastic strain principal 1" scripting_name="plastic_strain_principal_1"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain principal 1</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component plastic strains 1st principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_principal_1" cat="result" plugin="core" cpp-name="EPPL1"></scripting-part></div><div class="operator" id="multiply (complex fields)" scripting_name="cplx_multiply"plugin="core"cat="math"><h1 class="op-des-h1">math: multiply (complex fields)</h1><op-description description="Computes multiply between two field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_containerA" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="1" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cplx_multiply" cat="math" plugin="core" cpp-name="cplx_multiply"></scripting-part></div><div class="operator" id="unit convert (field)" scripting_name="unit_convert"plugin="core"cat="math"><h1 class="op-des-h1">math: unit convert (field)</h1><op-description description="Convert an input field of a given unit to another unit."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="unit_name" n="1" doc="unit as a string, ex 'm' for meter, 'Pa' for pascal,..." types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="unit_convert" cat="math" plugin="core" cpp-name="unit_convert"></scripting-part></div><div class="operator" id="+" scripting_name="add"plugin="core"cat="math"><h1 class="op-des-h1">math: +</h1><op-description description="Computes the sum of two fields. If one field's scoping has 'overall' location, then these field's values are applied on the entire other field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="add" cat="math" plugin="core" cpp-name="add"></scripting-part></div><div class="operator" id="+ (fields container)" scripting_name="add_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: + (fields container)</h1><op-description description="Compute the field-wise sum of the input fields containers."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="add_fc" cat="math" plugin="core" cpp-name="add_fc"></scripting-part></div><div class="operator" id="phase of max" scripting_name="phase_of_max"plugin="core"cat="math"><h1 class="op-des-h1">math: phase of max</h1><op-description description="Evaluates phase of maximum."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="real_field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="imaginary_field" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="abs_value" n="2" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="phase_increment" n="3" doc="Phase increment." types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="phase_of_max" cat="math" plugin="core" cpp-name="phase_of_max"></scripting-part></div><div class="operator" id="sin (fields container)" scripting_name="sin_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: sin (fields container)</h1><op-description description="Computes element-wise sin(field[i])."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sin_fc" cat="math" plugin="core" cpp-name="sin_fc"></scripting-part></div><div class="operator" id="+ constant (field)" scripting_name="add_constant"plugin="core"cat="math"><h1 class="op-des-h1">math: + constant (field)</h1><op-description description="Computes the sum of a field (in 0) and a scalar (in 1)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="ponderation" n="1" doc="double or vector of double" types="double vector<double>" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="add_constant" cat="math" plugin="core" cpp-name="add_constant"></scripting-part></div><div class="operator" id="stl export" scripting_name="stl_export"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: stl export</h1><op-description description="export a mesh into a stl file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="file_path" n="1" doc="" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="data_sources" n="0" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stl_export" cat="mesh" plugin="core" cpp-name="stl_export"></scripting-part></div><div class="operator" id="bind support" scripting_name="bind_support"plugin="core"cat="utility"><h1 class="op-des-h1">utility: bind support</h1><op-description description="Tie a support to a field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="support" n="1" doc="meshed region or a support of the field" types="abstract_meshed_region abstract_field_support" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="bind_support" cat="utility" plugin="core" cpp-name="BindSupport"></scripting-part></div><div class="operator" id="+ constant (fields container)" scripting_name="add_constant_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: + constant (fields container)</h1><op-description description="Computes the sum of a field (in 0) and a scalar (in 1)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><pin-def name="ponderation" n="1" doc="double or vector of double" types="double vector<double>" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="add_constant_fc" cat="math" plugin="core" cpp-name="add_constant_fc"></scripting-part></div><div class="operator" id="extract field" scripting_name="extract_field"plugin="core"cat="utility"><h1 class="op-des-h1">utility: extract field</h1><op-description description="Extract the fields at the indeces defined in the vector (in 1) form the fields container (in:0)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="if a field is in input, it is passed on as output" types="field fields_container" optional="false"></pin-def><pin-def name="indeces" n="1" doc="default is the first field" types="vector<int32>" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="extract_field" cat="utility" plugin="core" cpp-name="ExtractFromFC"></scripting-part></div><div class="operator" id="^ (field)" scripting_name="pow"plugin="core"cat="math"><h1 class="op-des-h1">math: ^ (field)</h1><op-description description="Computes element-wise field[i]^p."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="factor" n="1" doc="" types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="pow" cat="math" plugin="core" cpp-name="Pow"></scripting-part></div><div class="operator" id="intersect scopings" scripting_name="intersect"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: intersect scopings</h1><op-description description="Intersect 2 scopings and return the intersection and the difference between the intersection and the first scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="scopingA" n="0" doc="" types="scoping" optional="false"></pin-def><pin-def name="scopingB" n="1" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="intersection" n="0" doc="" types="scoping" optional="false"></pin-def><pin-def name="scopingA_min_intersection" n="1" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="intersect" cat="scoping" plugin="core" cpp-name="scoping::intersect"></scripting-part></div><div class="operator" id="elements in mesh" scripting_name="elemental_from_mesh"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: elements in mesh</h1><op-description description="Get the elements ids scoping of a given input mesh."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_from_mesh" cat="scoping" plugin="core" cpp-name="GetElementScopingFromMesh"></scripting-part></div><div class="operator" id="scale (field)" scripting_name="scale"plugin="core"cat="math"><h1 class="op-des-h1">math: scale (field)</h1><op-description description="Scales a field by a constant factor."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="ponderation" n="1" doc="Double/Field scoped on overall" types="double field" optional="false"></pin-def><pin-def name="boolean" n="2" doc="bool(optional, default false) if set to true, output of scale is mane dimensionless" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scale" cat="math" plugin="core" cpp-name="scale"></scripting-part></div><div class="operator" id="^ (fields container)" scripting_name="pow_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: ^ (fields container)</h1><op-description description="Computes element-wise field[i]^p."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="factor" n="1" doc="" types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="pow_fc" cat="math" plugin="core" cpp-name="Pow_fc"></scripting-part></div><div class="operator" id="scale (fields container)" scripting_name="scale_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: scale (fields container)</h1><op-description description="Scales a field by a constant factor."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><pin-def name="ponderation" n="1" doc="Double/Field scoped on overall" types="double field" optional="false"></pin-def><pin-def name="boolean" n="2" doc="bool(optional, default false) if set to true, output of scale is mane dimensionless" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scale_fc" cat="math" plugin="core" cpp-name="scale_fc"></scripting-part></div><div class="operator" id="sweeping phase" scripting_name="sweeping_phase"plugin="core"cat="math"><h1 class="op-des-h1">math: sweeping phase</h1><op-description description="Shift the phase of a real and an imaginary fields (in 0 and 1) of a given angle (in 3) of unit (in 4)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="real_field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="imaginary_field" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="angle" n="2" doc="" types="double" optional="false"></pin-def><pin-def name="unit_name" n="3" doc="String Unit" types="string" optional="false"></pin-def><pin-def name="abs_value" n="4" doc="" types="bool" optional="false"></pin-def><pin-def name="imaginary_part_null" n="5" doc="if the imaginary part field is empty and this pin is true, then the imaginary part is supposed to be 0 (default is false)" types="bool" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sweeping_phase" cat="math" plugin="core" cpp-name="sweeping_phase"></scripting-part></div><div class="operator" id="centroid" scripting_name="centroid"plugin="core"cat="math"><h1 class="op-des-h1">math: centroid</h1><op-description description="Computes centroid of field1 and field2, using fieldOut = field1*(1.-fact)+field2*(fact)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="factor" n="2" doc="Scalar" types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="centroid" cat="math" plugin="core" cpp-name="centroid"></scripting-part></div><div class="operator" id="change location" scripting_name="change_location"plugin="core"cat="utility"><h1 class="op-des-h1">utility: change location</h1><op-description description="change the location of a field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="new_location" n="1" doc="new location of the output field ex: 'Nodal', 'ElementalNodal', 'Elemental'..." types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="change_location" cat="utility" plugin="core" cpp-name="change_location"></scripting-part></div><div class="operator" id="elemental fraction (fields container)" scripting_name="elemental_fraction_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental fraction (fields container)</h1><op-description description="Transform ElementalNodal fields into Elemental fields. Each elemental value is the fraction between the elemental difference and the entity average. Result is computed on a given elements scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these elements, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><pin-def name="denominator" n="6" doc="if a fields container is set in this pin, it is used as the denominator of the fraction instead of entity_average_fc" types="fields_container" optional="true"></pin-def><pin-def name="collapse_shell_layers" n="10" doc="the elemental difference and the entity average are taken through the different shell layers if true (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_fraction_fc" cat="averaging" plugin="core" cpp-name="elemental_fraction_fc"></scripting-part></div><div class="operator" id="sin (field)" scripting_name="sin"plugin="core"cat="math"><h1 class="op-des-h1">math: sin (field)</h1><op-description description="Computes element-wise sin(field[i])."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sin" cat="math" plugin="core" cpp-name="sin"></scripting-part></div><div class="operator" id="cos (field)" scripting_name="cos"plugin="core"cat="math"><h1 class="op-des-h1">math: cos (field)</h1><op-description description="Computes element-wise cos(field[i])."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cos" cat="math" plugin="core" cpp-name="cos"></scripting-part></div><div class="operator" id="rigid transformation" scripting_name="rigid_transformation"plugin="core"cat="result"><h1 class="op-des-h1">result: rigid transformation</h1><op-description description="Extracts rigid body motions from a displacement in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="rigid_transformation" cat="result" plugin="core" cpp-name="RigidTransformationProvider"></scripting-part></div><div class="operator" id="cos (fields container)" scripting_name="cos_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: cos (fields container)</h1><op-description description="Computes element-wise cos(field[i])."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cos_fc" cat="math" plugin="core" cpp-name="cos_fc"></scripting-part></div><div class="operator" id="convert to fields container" scripting_name="field_to_fc"plugin="core"cat="utility"><h1 class="op-des-h1">utility: convert to fields container</h1><op-description description="Create a field container containing the field in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="if a fields container is set in input, it is pass on as output." types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field_to_fc" cat="utility" plugin="core" cpp-name="InjectToFieldContainer"></scripting-part></div><div class="operator" id="sweeping phase (fields container)" scripting_name="sweeping_phase_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: sweeping phase (fields container)</h1><op-description description="Shift the phase of all the corresponding real and imaginary fields of a fields container for a given angle (in 2) of unit (in 4)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="angle" n="2" doc="" types="double" optional="false"></pin-def><pin-def name="unit_name" n="3" doc="String Unit" types="string" optional="false"></pin-def><pin-def name="abs_value" n="4" doc="" types="bool" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sweeping_phase_fc" cat="math" plugin="core" cpp-name="sweeping_phase_fc"></scripting-part></div><div class="operator" id="^2 (field)" scripting_name="sqr"plugin="core"cat="math"><h1 class="op-des-h1">math: ^2 (field)</h1><op-description description="Computes element-wise field[i]^2."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sqr" cat="math" plugin="core" cpp-name="sqr"></scripting-part></div><div class="operator" id="linear combination" scripting_name="linear_combination"plugin="core"cat="math"><h1 class="op-des-h1">math: linear combination</h1><op-description description="Computes aXY + bZ where a,b (in 0, in 3) are scalar and X,Y,Z (in 1,2,4) are complex numbers."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="a" n="0" doc="Double" types="double" optional="false"></pin-def><pin-def name="fields_containerA" n="1" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="b" n="3" doc="Double" types="double" optional="false"></pin-def><pin-def name="fields_containerC" n="4" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="linear_combination" cat="math" plugin="core" cpp-name="CplxOp"></scripting-part></div><div class="operator" id="^2 (fields container)" scripting_name="sqr_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: ^2 (fields container)</h1><op-description description="Computes element-wise field[i]^2."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sqr_fc" cat="math" plugin="core" cpp-name="sqr_fc"></scripting-part></div><div class="operator" id="voigt to standard strains" scripting_name="strain_from_voigt"plugin="core"cat="utility"><h1 class="op-des-h1">utility: voigt to standard strains</h1><op-description description="Put strain field from Voigt notation to standard format."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="strain_from_voigt" cat="utility" plugin="core" cpp-name="strain_from_voigt"></scripting-part></div><div class="operator" id="sqrt (field)" scripting_name="sqrt"plugin="core"cat="math"><h1 class="op-des-h1">math: sqrt (field)</h1><op-description description="Computes element-wise sqrt(field1)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sqrt" cat="math" plugin="core" cpp-name="sqrt"></scripting-part></div><div class="operator" id="norm (field)" scripting_name="norm"plugin="core"cat="math"><h1 class="op-des-h1">math: norm (field)</h1><op-description description="Computes the element-wise L2 norm of the field elementary data."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="norm" cat="math" plugin="core" cpp-name="norm"></scripting-part></div><div class="operator" id="sqrt (fields container)" scripting_name="sqrt_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: sqrt (fields container)</h1><op-description description="Computes element-wise sqrt(field1)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="sqrt_fc" cat="math" plugin="core" cpp-name="sqrt_fc"></scripting-part></div><div class="operator" id="norm (fields container)" scripting_name="norm_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: norm (fields container)</h1><op-description description="Computes the element-wise L2 norm of the field elementary data. This process is applied on eah field of the input fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="norm_fc" cat="math" plugin="core" cpp-name="norm_fc"></scripting-part></div><div class="operator" id="/ (component-wise field)" scripting_name="component_wise_divide"plugin="core"cat="math"><h1 class="op-des-h1">math: / (component-wise field)</h1><op-description description="Computes component-wise fraction between two fields of same dimensionality. If one field's scoping has overall location, then these field's values are applied on the entire other field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="component_wise_divide" cat="math" plugin="core" cpp-name="component_wise_divide"></scripting-part></div><div class="operator" id="convert to field" scripting_name="scalars_to_field"plugin="core"cat="utility"><h1 class="op-des-h1">utility: convert to field</h1><op-description description="take a double or a vector of double and transform it in a one entity field of location "numeric"."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="double_or_vector_double" n="0" doc="double or vector of double" types="double vector<double>" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scalars_to_field" cat="utility" plugin="core" cpp-name="fieldify"></scripting-part></div><div class="operator" id="/ (component-wise fields container)" scripting_name="component_wise_divide_fc"plugin="core"cat="math"><h1 class="op-des-h1">math: / (component-wise fields container)</h1><op-description description="For every two fields with the same label space (from the two input fields containers), computes component-wise fraction between two fields of same dimensionality. If one field's scoping has overall location, then these field's values are applied on the entire other field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_containerA" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="1" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="component_wise_divide_fc" cat="math" plugin="core" cpp-name="component_wise_divide_fc"></scripting-part></div><div class="operator" id="kronecker product" scripting_name="kronecker_prod"plugin="core"cat="math"><h1 class="op-des-h1">math: kronecker product</h1><op-description description="Computes element-wise Kronecker product between two tensor fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="kronecker_prod" cat="math" plugin="core" cpp-name="kronecker_prod"></scripting-part></div><div class="operator" id="html doc" scripting_name="html_doc"plugin="core"cat="utility"><h1 class="op-des-h1">utility: html doc</h1><op-description description="Create dpf's html documentation. Only on windows, use deprecated doc for linux"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="output_path" n="0" doc="default is {working directory}/dataProcessingDoc.html" types="string" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="html_doc" cat="utility" plugin="core" cpp-name="html_doc"></scripting-part></div><div class="operator" id="real part" scripting_name="real_part"plugin="core"cat="math"><h1 class="op-des-h1">math: real part</h1><op-description description="Extracts element-wise real part of field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="real_part" cat="math" plugin="core" cpp-name="realP_part"></scripting-part></div><div class="operator" id="conjugate" scripting_name="conjugate"plugin="core"cat="math"><h1 class="op-des-h1">math: conjugate</h1><op-description description="Computes element-wise conjugate of field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="conjugate" cat="math" plugin="core" cpp-name="conjugate"></scripting-part></div><div class="operator" id="nodal averaged elastic strains" scripting_name="nodal_averaged_elastic_strains"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged elastic strains</h1><op-description description="Read nodal averaged elastic strains as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_elastic_strains" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NPEL"></scripting-part></div><div class="operator" id="imaginary part" scripting_name="img_part"plugin="core"cat="math"><h1 class="op-des-h1">math: imaginary part</h1><op-description description="Extracts element-wise imaginary part of field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="img_part" cat="math" plugin="core" cpp-name="img_part"></scripting-part></div><div class="operator" id="modulus (fields container)" scripting_name="amplitude"plugin="core"cat="math"><h1 class="op-des-h1">math: modulus (fields container)</h1><op-description description="Computes amplitude of a real and an imaginary field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="amplitude" cat="math" plugin="core" cpp-name="amplitude"></scripting-part></div><div class="operator" id="+ (complex fields)" scripting_name="cplx_add"plugin="core"cat="math"><h1 class="op-des-h1">math: + (complex fields)</h1><op-description description="Computes addition between two field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_containerA" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="1" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cplx_add" cat="math" plugin="core" cpp-name="cplx_add"></scripting-part></div><div class="operator" id="dot (complex fields)" scripting_name="cplx_dot"plugin="core"cat="math"><h1 class="op-des-h1">math: dot (complex fields)</h1><op-description description="Computes product between two field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_containerA" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="1" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cplx_dot" cat="math" plugin="core" cpp-name="cplx_dot"></scripting-part></div><div class="operator" id="/ (complex fields)" scripting_name="cplx_divide"plugin="core"cat="math"><h1 class="op-des-h1">math: / (complex fields)</h1><op-description description="Computes division between two field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_containerA" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="1" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cplx_divide" cat="math" plugin="core" cpp-name="cplx_divide"></scripting-part></div><div class="operator" id="unitary field" scripting_name="unitary_field"plugin="core"cat="utility"><h1 class="op-des-h1">utility: unitary field</h1><op-description description="Take a field and returns an other field of scalars on the same location and scoping as the input field"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="unitary_field" cat="utility" plugin="core" cpp-name="make_unit"></scripting-part></div><div class="operator" id="dot (field)" scripting_name="dot"plugin="core"cat="math"><h1 class="op-des-h1">math: dot (field)</h1><op-description description="Computes element-wise dot product between two vector fields. If one field's scoping has 'overall' location, then these field's values are applied on the entire other field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="dot" cat="math" plugin="core" cpp-name="dot"></scripting-part></div><div class="operator" id="elastic strain Y" scripting_name="elastic_strain_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains YY normal component (11 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_Y" cat="result" plugin="core" cpp-name="EPELY"></scripting-part></div><div class="operator" id="derivate (complex fields)" scripting_name="cplx_derive"plugin="core"cat="math"><h1 class="op-des-h1">math: derivate (complex fields)</h1><op-description description="Derive field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cplx_derive" cat="math" plugin="core" cpp-name="cplx_derive"></scripting-part></div><div class="operator" id="polar to complex fields" scripting_name="polar_to_cplx"plugin="core"cat="math"><h1 class="op-des-h1">math: polar to complex fields</h1><op-description description="Convert complex number from polar form to complex."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="polar_to_cplx" cat="math" plugin="core" cpp-name="polar_to_cplx"></scripting-part></div><div class="operator" id="modulus (field)" scripting_name="modulus"plugin="core"cat="math"><h1 class="op-des-h1">math: modulus (field)</h1><op-description description="Computes element-wise modulus of field containers containing complex fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="modulus" cat="math" plugin="core" cpp-name="modulus"></scripting-part></div><div class="operator" id="elemental mass" scripting_name="elemental_mass"plugin="core"cat="result"><h1 class="op-des-h1">result: elemental mass</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element mass. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_mass" cat="result" plugin="core" cpp-name="ElementalMass"></scripting-part></div><div class="operator" id="min/max over time" scripting_name="min_max_over_time"plugin="core"cat="math"><h1 class="op-des-h1">math: min/max over time</h1><op-description description="Evaluates minimum/maximum over time/frequency."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="angle" n="1" doc="Phase angle used for complex field container" types="double" optional="true"></pin-def><pin-def name="unit_name" n="2" doc="Phase angle unit. Default is radian." types="string" optional="true"></pin-def><pin-def name="abs_value" n="3" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="compute_amplitude" n="4" doc="Do calculate amplitude." types="bool" optional="true"></pin-def><pin-def name="int32" n="5" doc="Define min or max." types="int32" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_max_over_time" cat="math" plugin="core" cpp-name="min_max_over_time"></scripting-part></div><div class="operator" id="total sum" scripting_name="accumulate"plugin="core"cat="math"><h1 class="op-des-h1">math: total sum</h1><op-description description="Sum all the elementary data of a field to get one elementary data at the end."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="accumulate" cat="math" plugin="core" cpp-name="accumulate"></scripting-part></div><div class="operator" id="co-energy" scripting_name="co_energy"plugin="core"cat="result"><h1 class="op-des-h1">result: co-energy</h1><op-description description="Load the appropriate operator based on the data sources and read/compute co-energy (magnetics). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="co_energy" cat="result" plugin="core" cpp-name="ENG_CO"></scripting-part></div><div class="operator" id="dot" scripting_name="generalized_inner_product"plugin="core"cat="math"><h1 class="op-des-h1">math: dot</h1><op-description description="Computes a general notion of inner product between two fields of possibly different dimensionality."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="generalized_inner_product" cat="math" plugin="core" cpp-name="generalized_inner_product"></scripting-part></div><div class="operator" id="nodal averaged equivalent thermal strains" scripting_name="nodal_averaged_equivalent_thermal_strains"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged equivalent thermal strains</h1><op-description description="Read nodal averaged equivalent thermal strains as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_equivalent_thermal_strains" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NTH_EQV"></scripting-part></div><div class="operator" id="overall dot" scripting_name="native::overall_dot"plugin="core"cat="math"><h1 class="op-des-h1">math: overall dot</h1><op-description description="Compute a sdot product between two fields and return a scalar."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="FieldA" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="FieldB" n="1" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="Field defined on over-all location, contains a unique scalar value" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="native::overall_dot" cat="math" plugin="core" cpp-name="native::overall_dot"></scripting-part></div><div class="operator" id="max over time" scripting_name="max_over_time"plugin="core"cat="math"><h1 class="op-des-h1">math: max over time</h1><op-description description="Evaluates maximum over time/frequency."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="angle" n="1" doc="Phase angle used for complex field container" types="double" optional="true"></pin-def><pin-def name="unit_name" n="2" doc="Phase angle unit. Default is radian." types="string" optional="true"></pin-def><pin-def name="abs_value" n="3" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="compute_amplitude" n="4" doc="Do calculate amplitude." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="max_over_time" cat="math" plugin="core" cpp-name="max_over_time"></scripting-part></div><div class="operator" id="same meshes?" scripting_name="identical_meshes"plugin="core"cat="logic"><h1 class="op-des-h1">logic: same meshes?</h1><op-description description="Take two meshes and compare them."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="meshA" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="meshB" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="small_value" n="2" doc="define what is a small value for numeric comparison." types="double" optional="false"></pin-def><pin-def name="tolerence" n="3" doc="define the relative tolerence ceil for numeric comparison." types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="are_identical" n="0" doc="" types="bool" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="identical_meshes" cat="logic" plugin="core" cpp-name="compare::mesh"></scripting-part></div><div class="operator" id="time of max" scripting_name="time_of_max"plugin="core"cat="math"><h1 class="op-des-h1">math: time of max</h1><op-description description="Evaluates time/frequency of maximum."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="angle" n="1" doc="Phase angle used for complex field container" types="double" optional="true"></pin-def><pin-def name="unit_name" n="2" doc="Phase angle unit. Default is radian." types="string" optional="true"></pin-def><pin-def name="abs_value" n="3" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="compute_amplitude" n="4" doc="Do calculate amplitude." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="time_of_max" cat="math" plugin="core" cpp-name="time_of_max"></scripting-part></div><div class="operator" id="low pass (fields container)" scripting_name="field.low_pass_fc"plugin="core"cat="filter"><h1 class="op-des-h1">filter: low pass (fields container)</h1><op-description description="The low pass filter returns all the values strictly inferior to the threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><pin-def name="threshold" n="1" doc="a threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field.low_pass_fc" cat="filter" plugin="core" cpp-name="core::field::low_pass_fc"></scripting-part></div><div class="operator" id="min over time" scripting_name="min_over_time"plugin="core"cat="math"><h1 class="op-des-h1">math: min over time</h1><op-description description="Evaluates minimum over time/frequency."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="angle" n="1" doc="Phase angle used for complex field container" types="double" optional="true"></pin-def><pin-def name="unit_name" n="2" doc="Phase angle unit. Default is radian." types="string" optional="true"></pin-def><pin-def name="abs_value" n="3" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="compute_amplitude" n="4" doc="Do calculate amplitude." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_over_time" cat="math" plugin="core" cpp-name="min_over_time"></scripting-part></div><div class="operator" id="max over phase" scripting_name="max_over_phase"plugin="core"cat="math"><h1 class="op-des-h1">math: max over phase</h1><op-description description="Returns, for each entity, the maximum value of (real value * cos(theta) - imaginary value * sin(theta)) for theta in [0, 360]° with the increment in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="real_field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="imaginary_field" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="abs_value" n="2" doc="Should use absolute value." types="bool" optional="true"></pin-def><pin-def name="phase_increment" n="3" doc="Phase increment (default is 10.0°)." types="double" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="max_over_phase" cat="math" plugin="core" cpp-name="max_over_phase"></scripting-part></div><div class="operator" id="dot (tensors)" scripting_name="dot_tensor"plugin="core"cat="math"><h1 class="op-des-h1">math: dot (tensors)</h1><op-description description="Computes element-wise dot product between two tensor fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="dot_tensor" cat="math" plugin="core" cpp-name="dot_tensor"></scripting-part></div><div class="operator" id="dot (by scalar field)" scripting_name="scale_by_field"plugin="core"cat="math"><h1 class="op-des-h1">math: dot (by scalar field)</h1><op-description description="Scales a field (in 0) by a scalar field (in 1). If one field's scoping has 'overall' location, then these field's values are applied on the entire other field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scale_by_field" cat="math" plugin="core" cpp-name="scale_by_field"></scripting-part></div><div class="operator" id="invert" scripting_name="invert"plugin="core"cat="math"><h1 class="op-des-h1">math: invert</h1><op-description description="Compute the element-wise, component-wise, inverse of a field (1./x)"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="invert" cat="math" plugin="core" cpp-name="invert"></scripting-part></div><div class="operator" id="component selector (fields container)" scripting_name="component_selector_fc"plugin="core"cat="logic"><h1 class="op-des-h1">logic: component selector (fields container)</h1><op-description description="Create a scalar fields container based on the selected component for each field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="component_number" n="1" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="component_selector_fc" cat="logic" plugin="core" cpp-name="component_selector_fc"></scripting-part></div><div class="operator" id="component selector (field)" scripting_name="component_selector"plugin="core"cat="logic"><h1 class="op-des-h1">logic: component selector (field)</h1><op-description description="Create a scalar/vector field based on the selected component."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field fields_container" optional="false"></pin-def><pin-def name="component_number" n="1" doc="one or several component index that will be extracted from the initial field." types="int32 vector<int32>" optional="false"></pin-def><pin-def name="default_value" n="2" doc="set a default value for components that do not exist" types="double" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="component_selector" cat="logic" plugin="core" cpp-name="component_selector"></scripting-part></div><div class="operator" id="on property" scripting_name="on_property"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: on property</h1><op-description description="Provides a scoping at a given location based on a given property name and a property number."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="requested_location" n="0" doc="Nodal or Elemental location are expected" types="string" optional="false"></pin-def><pin-def name="property_name" n="1" doc="ex: "mapdl_element_type", "apdl_type_index", "mapdl_type_id", "material", "apdl_section_id", "apdl_real_id", "shell_axi", "volume_axi"..." types="string" optional="false"></pin-def><pin-def name="property_id" n="2" doc="" types="int32" optional="false"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><pin-def name="inclusive" n="5" doc="If element scoping is requested on a nodal named selection, if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="Scoping" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="on_property" cat="scoping" plugin="core" cpp-name="scoping_provider_by_prop"></scripting-part></div><div class="operator" id="set property" scripting_name="set_property"plugin="core"cat="utility"><h1 class="op-des-h1">utility: set property</h1><op-description description="Set a property to an input field/field container"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field fields_container" optional="false"></pin-def><pin-def name="property_name" n="1" doc="Property to set" types="string" optional="false"></pin-def><pin-def name="property_value" n="2" doc="Property to set" types="string int32 double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="set_property" cat="utility" plugin="core" cpp-name="field::set_property"></scripting-part></div><div class="operator" id="forward field" scripting_name="forward_field"plugin="core"cat="utility"><h1 class="op-des-h1">utility: forward field</h1><op-description description="Return the input field or fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="forward_field" cat="utility" plugin="core" cpp-name="forward"></scripting-part></div><div class="operator" id="forward fields container" scripting_name="forward_fields_container"plugin="core"cat="utility"><h1 class="op-des-h1">utility: forward fields container</h1><op-description description="Return the input field or fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields" n="0" doc="" types="fields_container field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="forward_fields_container" cat="utility" plugin="core" cpp-name="forward_fc"></scripting-part></div><div class="operator" id="txt file to dpf" scripting_name="txt_file_to_dpf"plugin="core"cat="utility"><h1 class="op-des-h1">utility: txt file to dpf</h1><op-description description="Take an input string and parse it into dataProcessing type."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="input_string" n="0" doc="ex: "double:1.0", "int:1", "vector<double>:1.0;1.0"" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="any_output" n="0" doc="any output" types="" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="txt_file_to_dpf" cat="utility" plugin="core" cpp-name="text_parser"></scripting-part></div><div class="operator" id="bind support (fields container)" scripting_name="bind_support_fc"plugin="core"cat="utility"><h1 class="op-des-h1">utility: bind support (fields container)</h1><op-description description="Tie a support to a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="support" n="1" doc="meshed region or a support of the field" types="abstract_meshed_region abstract_field_support" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="bind_support_fc" cat="utility" plugin="core" cpp-name="BindSupportFC"></scripting-part></div><div class="operator" id="extract from field" scripting_name="from_field"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: extract from field</h1><op-description description="Returns the meshed region contained in the support of the mesh."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="from_field" cat="mesh" plugin="core" cpp-name="GetSupportFromField"></scripting-part></div><div class="operator" id="pres to field" scripting_name="mapdl.pres_to_field"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: pres to field</h1><op-description description="Read the presol generated file from mapdl."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="filepath" n="0" doc="filepath" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mapdl.pres_to_field" cat="result" plugin="mapdl" cpp-name="PRES_Reader"></scripting-part></div><div class="operator" id="extend to mid nodes (fields container)" scripting_name="extend_to_mid_nodes_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: extend to mid nodes (fields container)</h1><op-description description="Extends ElementalNodal fields defined on corner nodes to ElementalNodal fields defined also on the mid nodes."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="extend_to_mid_nodes_fc" cat="averaging" plugin="core" cpp-name="extend_to_mid_nodes_fc"></scripting-part></div><div class="operator" id="elemental nodal to nodal elemental (fields container)" scripting_name="elemental_nodal_to_nodal_elemental_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental nodal to nodal elemental (fields container)</h1><op-description description="Transform ElementalNodal fields to NodalElemental fields, compute result on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_nodal_to_nodal_elemental_fc" cat="averaging" plugin="core" cpp-name="ElementalNodal_To_NodalElemental_fc"></scripting-part></div><div class="operator" id="cyclic expanded acceleration" scripting_name="cyclic_expanded_acceleration"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cyclic expanded acceleration</h1><op-description description="Read acceleration from an rst file and expand it with cyclic symmetry."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="sector_mesh" n="7" doc="mesh of the base sector (can be a skin)." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="location needed in output" types="string" optional="true"></pin-def><pin-def name="modal_damping_coefs" n="10" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="global_damping_coefs" n="11" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="freq" n="12" doc="" types="double" optional="false"></pin-def><pin-def name="read_cyclic" n="14" doc="if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)" types="enum dataProcessing::ECyclicReading int32" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="mesh expanded." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="vector<int32> scoping scopings_container" optional="true"></pin-def><pin-def name="phi" n="19" doc="angle phi (default value 0.0)" types="double" optional="true"></pin-def><pin-def name="filter_degenerated_elements" n="20" doc="if it's set to true, results are filtered to handle degenerated elements (default is true)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="static_matrix" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><pin-def name="expanded_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="inertia_matrix" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="remote_point_id" n="3" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_expanded_acceleration" cat="result" plugin="mapdl" cpp-name="mapdl::rst::A_cyclic"></scripting-part></div><div class="operator" id="elastic strain Z" scripting_name="elastic_strain_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains ZZ normal component (22 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_Z" cat="result" plugin="core" cpp-name="EPELZ"></scripting-part></div><div class="operator" id="result info provider" scripting_name="result_info_provider"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: result info provider</h1><op-description description="Read the result info with information sucha as available results or unit system from the results files contained in the streams or data sources."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="result_info" n="0" doc="" types="result_info" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="result_info_provider" cat="metadata" plugin="core" cpp-name="ResultInfoProvider"></scripting-part></div><div class="operator" id="stress" scripting_name="stress"plugin="core"cat="result"><h1 class="op-des-h1">result: stress</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal component stresses. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress" cat="result" plugin="core" cpp-name="S"></scripting-part></div><div class="operator" id="wrap in topology" scripting_name="wrap_in_topology"><h1 class="op-des-h1">other: wrap in topology</h1><op-description description="Take various input, and wrap in geometry if necessary."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region abstract_topology_entity" optional="false"></pin-def><pin-def name="id" n="1" doc="Id that must be attributed to the generated geometry (default is 0)." types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_topology_entity" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="wrap_in_topology" cat="other" plugin="core" cpp-name="topology::topology_from_mesh"></scripting-part></div><div class="operator" id="stress X" scripting_name="stress_X"plugin="core"cat="result"><h1 class="op-des-h1">result: stress X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component stresses XX normal component (00 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_X" cat="result" plugin="core" cpp-name="SX"></scripting-part></div><div class="operator" id="stress Y" scripting_name="stress_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: stress Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component stresses YY normal component (11 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_Y" cat="result" plugin="core" cpp-name="SY"></scripting-part></div><div class="operator" id="stress Z" scripting_name="stress_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: stress Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component stresses ZZ normal component (22 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_Z" cat="result" plugin="core" cpp-name="SZ"></scripting-part></div><div class="operator" id="stress XY" scripting_name="stress_XY"plugin="core"cat="result"><h1 class="op-des-h1">result: stress XY</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component stresses XY shear component (01 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_XY" cat="result" plugin="core" cpp-name="SXY"></scripting-part></div><div class="operator" id="stress YZ" scripting_name="stress_YZ"plugin="core"cat="result"><h1 class="op-des-h1">result: stress YZ</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component stresses YZ shear component (12 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_YZ" cat="result" plugin="core" cpp-name="SYZ"></scripting-part></div><div class="operator" id="stress XZ" scripting_name="stress_XZ"plugin="core"cat="result"><h1 class="op-des-h1">result: stress XZ</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component stresses XZ shear component (02 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_XZ" cat="result" plugin="core" cpp-name="SXZ"></scripting-part></div><div class="operator" id="modal basis" scripting_name="modal_basis"plugin="core"cat="result"><h1 class="op-des-h1">result: modal basis</h1><op-description description="Load the appropriate operator based on the data sources and read/compute modal basis. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="modal_basis" cat="result" plugin="core" cpp-name="ModalBasis"></scripting-part></div><div class="operator" id="stress principal 1" scripting_name="stress_principal_1"plugin="core"cat="result"><h1 class="op-des-h1">result: stress principal 1</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component stresses 1st principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_principal_1" cat="result" plugin="core" cpp-name="S1"></scripting-part></div><div class="operator" id="stress principal 2" scripting_name="stress_principal_2"plugin="core"cat="result"><h1 class="op-des-h1">result: stress principal 2</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component stresses 2nd principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_principal_2" cat="result" plugin="core" cpp-name="S2"></scripting-part></div><div class="operator" id="stress principal 3" scripting_name="stress_principal_3"plugin="core"cat="result"><h1 class="op-des-h1">result: stress principal 3</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component stresses 3rd principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_principal_3" cat="result" plugin="core" cpp-name="S3"></scripting-part></div><div class="operator" id="nodal solution to global cs" scripting_name="nodal_rotation_by_euler_nodes"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal solution to global cs</h1><op-description description="read Euler angles on nodes from the rst file and rotate the fields in the fieldsContainer."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="2" doc="" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container stream class dataProcessing::CRstFileWrapper" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_rotation_by_euler_nodes" cat="result" plugin="mapdl" cpp-name="mapdl::rst::RotateNodalFCByEulerNodes"></scripting-part></div><div class="operator" id="elastic strain" scripting_name="elastic_strain"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain" cat="result" plugin="core" cpp-name="EPEL"></scripting-part></div><div class="operator" id="elastic strain X" scripting_name="elastic_strain_X"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains XX normal component (00 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_X" cat="result" plugin="core" cpp-name="EPELX"></scripting-part></div><div class="operator" id="elastic strain XY" scripting_name="elastic_strain_XY"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain XY</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains XY shear component (01 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_XY" cat="result" plugin="core" cpp-name="EPELXY"></scripting-part></div><div class="operator" id="elastic strain YZ" scripting_name="elastic_strain_YZ"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain YZ</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains YZ shear component (12 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_YZ" cat="result" plugin="core" cpp-name="EPELYZ"></scripting-part></div><div class="operator" id="elastic strain XZ" scripting_name="elastic_strain_XZ"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain XZ</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component elastic strains XZ shear component (02 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_XZ" cat="result" plugin="core" cpp-name="EPELXZ"></scripting-part></div><div class="operator" id="eigen values (fields container)" scripting_name="eigen_values_fc"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: eigen values (fields container)</h1><op-description description="Computes the element-wise eigen values of all the tensor fields of a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="eigen_values_fc" cat="invariant" plugin="core" cpp-name="eig_values_fc"></scripting-part></div><div class="operator" id="elastic strain principal 1" scripting_name="elastic_strain_principal_1"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain principal 1</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component elastic strains 1st principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_principal_1" cat="result" plugin="core" cpp-name="EPEL1"></scripting-part></div><div class="operator" id="scoping normals" scripting_name="normals"plugin="core"cat="geo"><h1 class="op-des-h1">geo: scoping normals</h1><op-description description="compute the normals at the given nodes or element scoping based on the given mesh (first version, the element normal is only handled on the shell elements)"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><pin-def name="field" n="3" doc="" types="field" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="normals" cat="geo" plugin="core" cpp-name="normals_provider"></scripting-part></div><div class="operator" id="elastic strain principal 2" scripting_name="elastic_strain_principal_2"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain principal 2</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component elastic strains 2nd principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_principal_2" cat="result" plugin="core" cpp-name="EPEL2"></scripting-part></div><div class="operator" id="elastic strain principal 3" scripting_name="elastic_strain_principal_3"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain principal 3</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component elastic strains 3rd principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_principal_3" cat="result" plugin="core" cpp-name="EPEL3"></scripting-part></div><div class="operator" id="to elemental (fields container)" scripting_name="to_elemental_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: to elemental (fields container)</h1><op-description description="Transform input fields into Elemental fields using an averaging process, result is computed on a given elements scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="mesh_scoping" n="3" doc="" types="scoping" optional="true"></pin-def><pin-def name="smoothen_values" n="7" doc="if it is set to true, elemental nodal fields are first averaged on nodes and then averaged on elements (default is false)" types="bool" optional="true"></pin-def><pin-def name="collapse_shell_layers" n="10" doc="if true shell layers are averaged as well (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="to_elemental_fc" cat="averaging" plugin="core" cpp-name="to_elemental_fc"></scripting-part></div><div class="operator" id="plastic strain" scripting_name="plastic_strain"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain" cat="result" plugin="core" cpp-name="EPPL"></scripting-part></div><div class="operator" id="transpose" scripting_name="transpose"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: transpose</h1><op-description description="Transposes the input scoping or scopings container (Elemental --> Nodal, or Nodal ---> Elemental), based on the input mesh region."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh_scoping" n="0" doc="Scoping or scopings container (the input type is the output type)" types="scoping scopings_container" optional="false"></pin-def><pin-def name="meshed_region" n="1" doc="" types="meshed_region" optional="false"></pin-def><pin-def name="inclusive" n="2" doc="if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="Scoping or scopings container (the input type is the output type)" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="transpose" cat="scoping" plugin="core" cpp-name="transpose_scoping"></scripting-part></div><div class="operator" id="plastic strain X" scripting_name="plastic_strain_X"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains XX normal component (00 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_X" cat="result" plugin="core" cpp-name="EPPLX"></scripting-part></div><div class="operator" id="plastic strain Y" scripting_name="plastic_strain_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains YY normal component (11 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_Y" cat="result" plugin="core" cpp-name="EPPLY"></scripting-part></div><div class="operator" id="band pass (fields container)" scripting_name="field.band_pass_fc"plugin="core"cat="filter"><h1 class="op-des-h1">filter: band pass (fields container)</h1><op-description description="The band pass filter returns all the values strictly superior to the min threshold value and stricly inferior to the max threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><pin-def name="min_threshold" n="1" doc="a min threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><pin-def name="max_threshold" n="2" doc="a max threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field.band_pass_fc" cat="filter" plugin="core" cpp-name="core::field::band_pass_fc"></scripting-part></div><div class="operator" id="plastic strain Z" scripting_name="plastic_strain_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains ZZ normal component (22 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_Z" cat="result" plugin="core" cpp-name="EPPLZ"></scripting-part></div><div class="operator" id="vtk export" scripting_name="vtk_export"plugin="vtk"cat="serialization"><h1 class="op-des-h1">serialization: vtk export</h1><op-description description="Write the input field and fields container into a given vtk path"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="file_path" n="0" doc="path with vtk extension were the export occurs" types="string" optional="false"></pin-def><pin-def name="mesh" n="1" doc="necessary if the first field or fields container don't have a mesh in their support" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="fields" n="2" doc="fields exported" types="fields_container field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="vtk_export" cat="serialization" plugin="vtk" cpp-name="vtk_export"></scripting-part></div><div class="operator" id="plastic strain XY" scripting_name="plastic_strain_XY"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain XY</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains XY shear component (01 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_XY" cat="result" plugin="core" cpp-name="EPPLXY"></scripting-part></div><div class="operator" id="hydrostatic pressure" scripting_name="hydrostatic_pressure"plugin="core"cat="result"><h1 class="op-des-h1">result: hydrostatic pressure</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal hydrostatic pressure. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="hydrostatic_pressure" cat="result" plugin="core" cpp-name="ENL_HPRES"></scripting-part></div><div class="operator" id="plastic strain YZ" scripting_name="plastic_strain_YZ"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain YZ</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains YZ shear component (12 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_YZ" cat="result" plugin="core" cpp-name="EPPLYZ"></scripting-part></div><div class="operator" id="low pass (only scoping)" scripting_name="scoping.low_pass"plugin="core"cat="filter"><h1 class="op-des-h1">filter: low pass (only scoping)</h1><op-description description="The low pass filter returns all the values strictly inferior to the threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="threshold" n="1" doc="a threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scoping.low_pass" cat="filter" plugin="core" cpp-name="core::scoping::low_pass"></scripting-part></div><div class="operator" id="plastic strain XZ" scripting_name="plastic_strain_XZ"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain XZ</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute element nodal component plastic strains XZ shear component (02 component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_XZ" cat="result" plugin="core" cpp-name="EPPLXZ"></scripting-part></div><div class="operator" id="plastic strain principal 2" scripting_name="plastic_strain_principal_2"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain principal 2</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component plastic strains 2nd principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_principal_2" cat="result" plugin="core" cpp-name="EPPL2"></scripting-part></div><div class="operator" id="integrate over elements" scripting_name="integrate_over_elements"plugin="core"cat="geo"><h1 class="op-des-h1">geo: integrate over elements</h1><op-description description="Integration of an input field over mesh."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="scoping" n="1" doc="Integrate the input field over a specific scoping." types="scoping" optional="true"></pin-def><pin-def name="mesh" n="2" doc="Mesh to integrate on, if not provided the one from input field is provided." types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="integrate_over_elements" cat="geo" plugin="core" cpp-name="element::integrate"></scripting-part></div><div class="operator" id="center of gravity" scripting_name="center_of_gravity"plugin="core"cat="geo"><h1 class="op-des-h1">geo: center of gravity</h1><op-description description="Compute the center of gravity of a set of elements"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="Mesh scoping, if not set, all the elements of the mesh are considered." types="scoping" optional="true"></pin-def><pin-def name="field" n="2" doc="Elemental or nodal ponderation used in computation." types="field" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="mesh" n="1" doc="Center of gravity as a mesh" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="center_of_gravity" cat="geo" plugin="core" cpp-name="topology::center_of_gravity"></scripting-part></div><div class="operator" id="plastic strain principal 3" scripting_name="plastic_strain_principal_3"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain principal 3</h1><op-description description=" Load the appropriate operator based on the data sources, reads/computes the result and find its eigen values (element nodal component plastic strains 3rd principal component)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_principal_3" cat="result" plugin="core" cpp-name="EPPL3"></scripting-part></div><div class="operator" id="acceleration" scripting_name="acceleration"plugin="core"cat="result"><h1 class="op-des-h1">result: acceleration</h1><op-description description="Load the appropriate operator based on the data sources and read/compute nodal accelerations. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="acceleration" cat="result" plugin="core" cpp-name="A"></scripting-part></div><div class="operator" id="acceleration X" scripting_name="acceleration_X"plugin="core"cat="result"><h1 class="op-des-h1">result: acceleration X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal accelerations X component of the vector (1st component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="acceleration_X" cat="result" plugin="core" cpp-name="AX"></scripting-part></div><div class="operator" id="acceleration Y" scripting_name="acceleration_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: acceleration Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal accelerations Y component of the vector (2nd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="acceleration_Y" cat="result" plugin="core" cpp-name="AY"></scripting-part></div><div class="operator" id="acceleration Z" scripting_name="acceleration_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: acceleration Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal accelerations Z component of the vector (3rd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="acceleration_Z" cat="result" plugin="core" cpp-name="AZ"></scripting-part></div><div class="operator" id="velocity" scripting_name="velocity"plugin="core"cat="result"><h1 class="op-des-h1">result: velocity</h1><op-description description="Load the appropriate operator based on the data sources and read/compute nodal velocities. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="velocity" cat="result" plugin="core" cpp-name="V"></scripting-part></div><div class="operator" id="reaction force" scripting_name="reaction_force"plugin="core"cat="result"><h1 class="op-des-h1">result: reaction force</h1><op-description description="Load the appropriate operator based on the data sources and read/compute nodal reaction forces. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="reaction_force" cat="result" plugin="core" cpp-name="RF"></scripting-part></div><div class="operator" id="serializer" scripting_name="serializer"plugin="core"cat="serialization"><h1 class="op-des-h1">serialization: serializer</h1><op-description description="Take any input and serialize them in a file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="file_path" n="0" doc="" types="string" optional="false"></pin-def><pin-def name="any_input" n="1" doc="any input" types="" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="file_path" n="0" doc="" types="string" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="serializer" cat="serialization" plugin="core" cpp-name="serializer"></scripting-part></div><div class="operator" id="velocity X" scripting_name="velocity_X"plugin="core"cat="result"><h1 class="op-des-h1">result: velocity X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal velocities X component of the vector (1st component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="velocity_X" cat="result" plugin="core" cpp-name="VX"></scripting-part></div><div class="operator" id="velocity Y" scripting_name="velocity_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: velocity Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal velocities Y component of the vector (2nd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="velocity_Y" cat="result" plugin="core" cpp-name="VY"></scripting-part></div><div class="operator" id="velocity Z" scripting_name="velocity_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: velocity Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal velocities Z component of the vector (3rd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="velocity_Z" cat="result" plugin="core" cpp-name="VZ"></scripting-part></div><div class="operator" id="displacement" scripting_name="displacement"plugin="core"cat="result"><h1 class="op-des-h1">result: displacement</h1><op-description description="Load the appropriate operator based on the data sources and read/compute nodal displacements. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="displacement" cat="result" plugin="core" cpp-name="U"></scripting-part></div><div class="operator" id="displacement X" scripting_name="displacement_X"plugin="core"cat="result"><h1 class="op-des-h1">result: displacement X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal displacements X component of the vector (1st component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="displacement_X" cat="result" plugin="core" cpp-name="UX"></scripting-part></div><div class="operator" id="displacement Y" scripting_name="displacement_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: displacement Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal displacements Y component of the vector (2nd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="displacement_Y" cat="result" plugin="core" cpp-name="UY"></scripting-part></div><div class="operator" id="displacement Z" scripting_name="displacement_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: displacement Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute nodal displacements Z component of the vector (3rd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="displacement_Z" cat="result" plugin="core" cpp-name="UZ"></scripting-part></div><div class="operator" id="heat flux" scripting_name="heat_flux"plugin="core"cat="result"><h1 class="op-des-h1">result: heat flux</h1><op-description description="Load the appropriate operator based on the data sources and read/compute heat flux. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="heat_flux" cat="result" plugin="core" cpp-name="TF"></scripting-part></div><div class="operator" id="heat flux X" scripting_name="heat_flux_X"plugin="core"cat="result"><h1 class="op-des-h1">result: heat flux X</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute heat flux X component of the vector (1st component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="heat_flux_X" cat="result" plugin="core" cpp-name="TFX"></scripting-part></div><div class="operator" id="heat flux Y" scripting_name="heat_flux_Y"plugin="core"cat="result"><h1 class="op-des-h1">result: heat flux Y</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute heat flux Y component of the vector (2nd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="heat_flux_Y" cat="result" plugin="core" cpp-name="TFY"></scripting-part></div><div class="operator" id="electric field" scripting_name="electric_field"plugin="core"cat="result"><h1 class="op-des-h1">result: electric field</h1><op-description description="Load the appropriate operator based on the data sources and read/compute electric field. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="electric_field" cat="result" plugin="core" cpp-name="EF"></scripting-part></div><div class="operator" id="heat flux Z" scripting_name="heat_flux_Z"plugin="core"cat="result"><h1 class="op-des-h1">result: heat flux Z</h1><op-description description=" Load the appropriate operator based on the data sources and read/compute heat flux Z component of the vector (3rd component). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources // if stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="requested location, default is Nodal" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="heat_flux_Z" cat="result" plugin="core" cpp-name="TFZ"></scripting-part></div><div class="operator" id="element nodal forces" scripting_name="element_nodal_forces"plugin="core"cat="result"><h1 class="op-des-h1">result: element nodal forces</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal forces. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="element_nodal_forces" cat="result" plugin="core" cpp-name="ENF"></scripting-part></div><div class="operator" id="structural temperature" scripting_name="structural_temperature"plugin="core"cat="result"><h1 class="op-des-h1">result: structural temperature</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element structural nodal temperatures. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="structural_temperature" cat="result" plugin="core" cpp-name="BFE"></scripting-part></div><div class="operator" id="thermal strain" scripting_name="thermal_strain"plugin="core"cat="result"><h1 class="op-des-h1">result: thermal strain</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal component thermal strains. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="thermal_strain" cat="result" plugin="core" cpp-name="ETH"></scripting-part></div><div class="operator" id="incremental energy" scripting_name="incremental_energy"plugin="core"cat="result"><h1 class="op-des-h1">result: incremental energy</h1><op-description description="Load the appropriate operator based on the data sources and read/compute incremental energy (magnetics). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="incremental_energy" cat="result" plugin="core" cpp-name="ENG_INC"></scripting-part></div><div class="operator" id="mechanical csv to field" scripting_name="mechanical_csv_to_field"plugin="csv"cat="serialization"><h1 class="op-des-h1">serialization: mechanical csv to field</h1><op-description description="Reads mechanical exported csv file"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="unit" n="0" doc="" types="class dataProcessing::unit::CUnit" optional="false"></pin-def><pin-def name="mesh" n="1" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><pin-def name="requested_location" n="9" doc="" types="string field_definition" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mechanical_csv_to_field" cat="serialization" plugin="csv" cpp-name="mechanical_csv_to_field"></scripting-part></div><div class="operator" id="stiffness matrix energy" scripting_name="stiffness_matrix_energy"plugin="core"cat="result"><h1 class="op-des-h1">result: stiffness matrix energy</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element energy associated with the stiffness matrix. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stiffness_matrix_energy" cat="result" plugin="core" cpp-name="ENG_SE"></scripting-part></div><div class="operator" id="equivalent stress parameter" scripting_name="eqv_stress_parameter"plugin="core"cat="result"><h1 class="op-des-h1">result: equivalent stress parameter</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal equivalent stress parameter. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="eqv_stress_parameter" cat="result" plugin="core" cpp-name="ENL_SEPL"></scripting-part></div><div class="operator" id="skin (tri mesh)" scripting_name="tri_mesh_skin"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: skin (tri mesh)</h1><op-description description="Extracts a skin of the mesh in triangles (2D elements) in a new meshed region"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="nodes_mesh_scoping" n="1" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="tri_mesh_skin" cat="mesh" plugin="core" cpp-name="meshed_skin_sector_triangle"></scripting-part></div><div class="operator" id="stress ratio" scripting_name="stress_ratio"plugin="core"cat="result"><h1 class="op-des-h1">result: stress ratio</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal stress ratio. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_ratio" cat="result" plugin="core" cpp-name="ENL_SRAT"></scripting-part></div><div class="operator" id="accu eqv plastic strain" scripting_name="accu_eqv_plastic_strain"plugin="core"cat="result"><h1 class="op-des-h1">result: accu eqv plastic strain</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal accumulated equivalent plastic strain. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="accu_eqv_plastic_strain" cat="result" plugin="core" cpp-name="ENL_EPEQ"></scripting-part></div><div class="operator" id="plastic state variable" scripting_name="plastic_state_variable"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic state variable</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal plastic state variable. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_state_variable" cat="result" plugin="core" cpp-name="ENL_PSV"></scripting-part></div><div class="operator" id="accu eqv creep strain" scripting_name="accu_eqv_creep_strain"plugin="core"cat="result"><h1 class="op-des-h1">result: accu eqv creep strain</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal accumulated equivalent creep strain. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="accu_eqv_creep_strain" cat="result" plugin="core" cpp-name="ENL_CREQ"></scripting-part></div><div class="operator" id="scoping on coordinates" scripting_name="scoping_on_coordinates"plugin="core"cat="mapping"><h1 class="op-des-h1">mapping: scoping on coordinates</h1><op-description description="Finds the Elemental scoping of a set of coordinates."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="coordinates" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scoping_on_coordinates" cat="mapping" plugin="core" cpp-name="scoping::on_coordinates"></scripting-part></div><div class="operator" id="plastic strain energy density" scripting_name="plastic_strain_energy_density"plugin="core"cat="result"><h1 class="op-des-h1">result: plastic strain energy density</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal plastic strain energy density. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_energy_density" cat="result" plugin="core" cpp-name="ENL_PLWK"></scripting-part></div><div class="operator" id="cyclic expanded el strain" scripting_name="cyclic_expanded_el_strain"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cyclic expanded el strain</h1><op-description description="Read mapdl::rst::EPEL from an rst file and expand it with cyclic symmetry."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="sector_mesh" n="7" doc="mesh of the base sector (can be a skin)." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="location needed in output" types="string" optional="true"></pin-def><pin-def name="modal_damping_coefs" n="10" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="global_damping_coefs" n="11" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="freq" n="12" doc="" types="double" optional="false"></pin-def><pin-def name="read_cyclic" n="14" doc="if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)" types="enum dataProcessing::ECyclicReading int32" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="mesh expanded." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="vector<int32> scoping scopings_container" optional="true"></pin-def><pin-def name="phi" n="19" doc="phi angle (default value 0.0)" types="double" optional="true"></pin-def><pin-def name="filter_degenerated_elements" n="20" doc="if it's set to true, results are filtered to handle degenerated elements (default is true)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="static_matrix" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><pin-def name="expanded_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="inertia_matrix" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="remote_point_id" n="3" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_expanded_el_strain" cat="result" plugin="mapdl" cpp-name="mapdl::rst::EPEL_cyclic"></scripting-part></div><div class="operator" id="creep strain energy density" scripting_name="creep_strain_energy_density"plugin="core"cat="result"><h1 class="op-des-h1">result: creep strain energy density</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal creep strain energy density. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="creep_strain_energy_density" cat="result" plugin="core" cpp-name="ENL_CRWK"></scripting-part></div><div class="operator" id="material property of element" scripting_name="material_property_of_element"plugin="core"cat="result"><h1 class="op-des-h1">result: material property of element</h1><op-description description=" Load the appropriate operator based on the data sources and get material properties"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="material_properties" n="0" doc="material properties" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="material_property_of_element" cat="result" plugin="core" cpp-name="MaterialPropertyOfElement"></scripting-part></div><div class="operator" id="elastic strain energy density" scripting_name="elastic_strain_energy_density"plugin="core"cat="result"><h1 class="op-des-h1">result: elastic strain energy density</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element nodal elastic strain energy density. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_energy_density" cat="result" plugin="core" cpp-name="ENL_ELENG"></scripting-part></div><div class="operator" id="contact status" scripting_name="contact_status"plugin="core"cat="result"><h1 class="op-des-h1">result: contact status</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact status. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_status" cat="result" plugin="core" cpp-name="ECT_STAT"></scripting-part></div><div class="operator" id="field to csv" scripting_name="field_to_csv"plugin="csv"cat="serialization"><h1 class="op-des-h1">serialization: field to csv</h1><op-description description="Exports a field or a fields container into a csv file"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field_or_fields_container" n="0" doc="field_or_fields_container" types="fields_container field" optional="false"></pin-def><pin-def name="file_path" n="1" doc="" types="string" optional="false"></pin-def><pin-def name="storage_type" n="2" doc="storage type : if matrices (without any particularity) are included in the fields container, the storage format can be chosen. 0 : flat/line format, 1 : ranked format. If 1 is chosen, the csv can not be read by "csv to field" operator anymore. Default : 0." types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field_to_csv" cat="serialization" plugin="csv" cpp-name="field_to_csv"></scripting-part></div><div class="operator" id="contact penetration" scripting_name="contact_penetration"plugin="core"cat="result"><h1 class="op-des-h1">result: contact penetration</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact penetration. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_penetration" cat="result" plugin="core" cpp-name="ECT_PENE"></scripting-part></div><div class="operator" id="contact pressure" scripting_name="contact_pressure"plugin="core"cat="result"><h1 class="op-des-h1">result: contact pressure</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact pressure. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_pressure" cat="result" plugin="core" cpp-name="ECT_PRES"></scripting-part></div><div class="operator" id="moment of inertia" scripting_name="moment_of_inertia"plugin="core"cat="geo"><h1 class="op-des-h1">geo: moment of inertia</h1><op-description description="Compute the inertia tensor of a set of elements."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="Mesh scoping, if not set, all the elements of the mesh are considered." types="scoping" optional="true"></pin-def><pin-def name="field" n="2" doc="Elemental or nodal ponderation used in computation." types="field" optional="true"></pin-def><pin-def name="boolean" n="3" doc="default true, compute inertia tensor at center of gravity." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="moment_of_inertia" cat="geo" plugin="core" cpp-name="topology::moment_of_inertia"></scripting-part></div><div class="operator" id="contact friction stress" scripting_name="contact_friction_stress"plugin="core"cat="result"><h1 class="op-des-h1">result: contact friction stress</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact friction stress. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_friction_stress" cat="result" plugin="core" cpp-name="ECT_SFRIC"></scripting-part></div><div class="operator" id="contact total stress" scripting_name="contact_total_stress"plugin="core"cat="result"><h1 class="op-des-h1">result: contact total stress</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact total stress (pressure plus friction). Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_total_stress" cat="result" plugin="core" cpp-name="ECT_STOT"></scripting-part></div><div class="operator" id="contact sliding distance" scripting_name="contact_sliding_distance"plugin="core"cat="result"><h1 class="op-des-h1">result: contact sliding distance</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact sliding distance. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_sliding_distance" cat="result" plugin="core" cpp-name="ECT_SLIDE"></scripting-part></div><div class="operator" id="to field" scripting_name="to_field"plugin="vtk"cat="result"><h1 class="op-des-h1">result: to field</h1><op-description description="Write a field based on a vtk file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams" n="3" doc="streams" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data_sources" types="data_sources" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="fields_container" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="to_field" cat="result" plugin="vtk" cpp-name="vtk::vtk::FieldProvider"></scripting-part></div><div class="operator" id="contact gap distance" scripting_name="contact_gap_distance"plugin="core"cat="result"><h1 class="op-des-h1">result: contact gap distance</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element contact gap distance. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_gap_distance" cat="result" plugin="core" cpp-name="ECT_GAP"></scripting-part></div><div class="operator" id="contact surface heat flux" scripting_name="contact_surface_heat_flux"plugin="core"cat="result"><h1 class="op-des-h1">result: contact surface heat flux</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element total heat flux at contact surface. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_surface_heat_flux" cat="result" plugin="core" cpp-name="ECT_FLUX"></scripting-part></div><div class="operator" id="num surface status changes" scripting_name="num_surface_status_changes"plugin="core"cat="result"><h1 class="op-des-h1">result: num surface status changes</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element total number of contact status changes during substep. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="num_surface_status_changes" cat="result" plugin="core" cpp-name="ECT_CNOS"></scripting-part></div><div class="operator" id="contact fluid penetration pressure" scripting_name="contact_fluid_penetration_pressure"plugin="core"cat="result"><h1 class="op-des-h1">result: contact fluid penetration pressure</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element actual applied fluid penetration pressure. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="contact_fluid_penetration_pressure" cat="result" plugin="core" cpp-name="ECT_FRES"></scripting-part></div><div class="operator" id="elemental volume" scripting_name="elemental_volume"plugin="core"cat="result"><h1 class="op-des-h1">result: elemental volume</h1><op-description description="Load the appropriate operator based on the data sources and read/compute element volume. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_volume" cat="result" plugin="core" cpp-name="ENG_VOL"></scripting-part></div><div class="operator" id="artificial hourglass energy" scripting_name="artificial_hourglass_energy"plugin="core"cat="result"><h1 class="op-des-h1">result: artificial hourglass energy</h1><op-description description="Load the appropriate operator based on the data sources and read/compute artificial hourglass energy. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="artificial_hourglass_energy" cat="result" plugin="core" cpp-name="ENG_AHO"></scripting-part></div><div class="operator" id="kinetic energy" scripting_name="kinetic_energy"plugin="core"cat="result"><h1 class="op-des-h1">result: kinetic energy</h1><op-description description="Load the appropriate operator based on the data sources and read/compute kinetic energy. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="kinetic_energy" cat="result" plugin="core" cpp-name="ENG_KE"></scripting-part></div><div class="operator" id="thermal dissipation energy" scripting_name="thermal_dissipation_energy"plugin="core"cat="result"><h1 class="op-des-h1">result: thermal dissipation energy</h1><op-description description="Load the appropriate operator based on the data sources and read/compute thermal dissipation energy. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="thermal_dissipation_energy" cat="result" plugin="core" cpp-name="ENG_TH"></scripting-part></div><div class="operator" id="nodal force" scripting_name="nodal_force"plugin="core"cat="result"><h1 class="op-des-h1">result: nodal force</h1><op-description description="Load the appropriate operator based on the data sources and read/compute nodal forces. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_force" cat="result" plugin="core" cpp-name="F"></scripting-part></div><div class="operator" id="nodal moment" scripting_name="nodal_moment"plugin="core"cat="result"><h1 class="op-des-h1">result: nodal moment</h1><op-description description="Load the appropriate operator based on the data sources and read/compute nodal moment. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_moment" cat="result" plugin="core" cpp-name="M"></scripting-part></div><div class="operator" id="temperature" scripting_name="temperature"plugin="core"cat="result"><h1 class="op-des-h1">result: temperature</h1><op-description description="Load the appropriate operator based on the data sources and read/compute temperature field. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="temperature" cat="result" plugin="core" cpp-name="TEMP"></scripting-part></div><div class="operator" id="nodal averaged equivalent plastic strain" scripting_name="nodal_averaged_equivalent_plastic_strain"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged equivalent plastic strain</h1><op-description description="Read nodal averaged equivalent plastic strain as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_equivalent_plastic_strain" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NPPL_EQV"></scripting-part></div><div class="operator" id="raw displacement" scripting_name="raw_displacement"plugin="core"cat="result"><h1 class="op-des-h1">result: raw displacement</h1><op-description description="Load the appropriate operator based on the data sources and read/compute U vector from the finite element problem KU=F. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="raw_displacement" cat="result" plugin="core" cpp-name="UTOT"></scripting-part></div><div class="operator" id="raw reaction force" scripting_name="raw_reaction_force"plugin="core"cat="result"><h1 class="op-des-h1">result: raw reaction force</h1><op-description description="Load the appropriate operator based on the data sources and read/compute F vector from the finite element problem KU=F. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="raw_reaction_force" cat="result" plugin="core" cpp-name="RFTOT"></scripting-part></div><div class="operator" id="electric potential" scripting_name="electric_potential"plugin="core"cat="result"><h1 class="op-des-h1">result: electric potential</h1><op-description description="Load the appropriate operator based on the data sources and read/compute electric Potential. Regarding the requested location and the input mesh scoping, the result location can be Nodal/ElementalNodal/Elemental."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="Fields container already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="electric_potential" cat="result" plugin="core" cpp-name="VOLT"></scripting-part></div><div class="operator" id="stress von mises" scripting_name="stress_von_mises"plugin="core"cat="result"><h1 class="op-des-h1">result: stress von mises</h1><op-description description="Reads/computes element nodal component stresses, average it one nodes and computes its element nodal component stresses nodal / elemental Mises equivalent"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="mesh entities scoping, unordered_map<int, int> id to index (optional) (index is optional, to be set if a user wants the results at a given order)" types="scopings_container scoping" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="" types="string" optional="true"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_von_mises" cat="result" plugin="core" cpp-name="S_eqv"></scripting-part></div><div class="operator" id="time freq provider" scripting_name="time_freq_provider"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: time freq provider</h1><op-description description="Read the time freq support from the results files contained in the streams or data sources."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="time_freq_support" n="0" doc="" types="time_freq_support" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="time_freq_provider" cat="metadata" plugin="core" cpp-name="TimeFreqSupportProvider"></scripting-part></div><div class="operator" id="material provider" scripting_name="material_provider"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: material provider</h1><op-description description="Read available materials and properties from the results files contained in the streams or data sources."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="streams (result file container)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="materials" n="0" doc="" types="materials" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="material_provider" cat="metadata" plugin="core" cpp-name="MaterialsProvider"></scripting-part></div><div class="operator" id="streams provider" scripting_name="streams_provider"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: streams provider</h1><op-description description="Creates streams (files with cache) from the data sources."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="streams_container" n="0" doc="" types="streams_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="streams_provider" cat="metadata" plugin="core" cpp-name="stream_provider"></scripting-part></div><div class="operator" id="mesh provider" scripting_name="mesh_provider"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: mesh provider</h1><op-description description="Read a mesh from result files and cure degenerated elements"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mesh_provider" cat="mesh" plugin="core" cpp-name="MeshProvider"></scripting-part></div><div class="operator" id="mesh selection manager provider" scripting_name="mesh_selection_manager_provider"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: mesh selection manager provider</h1><op-description description="Read mesh properties from the results files contained in the streams or data sources and make those properties available through a mesh selection manager in output."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_selection_manager" n="0" doc="" types="class dataProcessing::CMeshSelectionManager" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mesh_selection_manager_provider" cat="metadata" plugin="core" cpp-name="MeshSelectionManagerProvider"></scripting-part></div><div class="operator" id="nodal averaged thermal strains" scripting_name="nodal_averaged_thermal_strains"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged thermal strains</h1><op-description description="Read nodal averaged thermal strains as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_thermal_strains" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NTH"></scripting-part></div><div class="operator" id="boundary condition provider" scripting_name="boundary_condition_provider"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: boundary condition provider</h1><op-description description="Read boundary conditions from the results files contained in the streams or data sources."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="results_info" n="0" doc="results info" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="boundary_condition_provider" cat="metadata" plugin="core" cpp-name="boundary_conditions"></scripting-part></div><div class="operator" id="cyclic analysis?" scripting_name="is_cyclic"plugin="core"cat="metadata"><h1 class="op-des-h1">metadata: cyclic analysis?</h1><op-description description="Read if the model is cyclic form the result file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="streams (result file container) (optional)" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="if the stream is null then we need to get the file path from the data sources" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="file_path" n="0" doc="returns 'single_stage' or 'multi_stage' or an empty string for non cyclic model" types="string" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="is_cyclic" cat="metadata" plugin="core" cpp-name="is_cyclic"></scripting-part></div><div class="operator" id="deserializer" scripting_name="deserializer"plugin="core"cat="serialization"><h1 class="op-des-h1">serialization: deserializer</h1><op-description description="Takes a file generated by the serializer and deserializes it into DPF's enitities."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="file_path" n="0" doc="file path" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="any_ouptut" n="1" doc="number and types of outputs corresponding of the inputs used in the serialization" types="" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="deserializer" cat="serialization" plugin="core" cpp-name="deserializer"></scripting-part></div><div class="operator" id="cyclic expanded velocity" scripting_name="cyclic_expanded_velocity"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cyclic expanded velocity</h1><op-description description="Read velocity from an rst file and expand it with cyclic symmetry."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="sector_mesh" n="7" doc="mesh of the base sector (can be a skin)." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="location needed in output" types="string" optional="true"></pin-def><pin-def name="modal_damping_coefs" n="10" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="global_damping_coefs" n="11" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="freq" n="12" doc="" types="double" optional="false"></pin-def><pin-def name="read_cyclic" n="14" doc="if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)" types="enum dataProcessing::ECyclicReading int32" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="mesh expanded." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="vector<int32> scoping scopings_container" optional="true"></pin-def><pin-def name="phi" n="19" doc="angle phi (default value 0.0)" types="double" optional="true"></pin-def><pin-def name="filter_degenerated_elements" n="20" doc="if it's set to true, results are filtered to handle degenerated elements (default is true)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="static_matrix" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><pin-def name="expanded_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="inertia_matrix" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="remote_point_id" n="3" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_expanded_velocity" cat="result" plugin="mapdl" cpp-name="mapdl::rst::V_cyclic"></scripting-part></div><div class="operator" id="same property fields?" scripting_name="identical_property_fields"plugin="core"cat="logic"><h1 class="op-des-h1">logic: same property fields?</h1><op-description description="Take two property fields and compare them."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="property_fieldA" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="property_fieldB" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="are_identical" n="0" doc="" types="bool" optional="false"></pin-def><pin-def name="informations" n="1" doc="" types="string" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="identical_property_fields" cat="logic" plugin="core" cpp-name="compare::property_field"></scripting-part></div><div class="operator" id="over field" scripting_name="min_max"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: over field</h1><op-description description="Compute the component-wise minimum (out 0) and maximum (out 1) over a field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field_min" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="field_max" n="1" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_max" cat="min_max" plugin="core" cpp-name="min_max"></scripting-part></div><div class="operator" id="over fields container" scripting_name="min_max_fc"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: over fields container</h1><op-description description="Compute the component-wise minimum (out 0) and maximum (out 1) over a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field_min" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="field_max" n="1" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_max_fc" cat="min_max" plugin="core" cpp-name="min_max_fc"></scripting-part></div><div class="operator" id="over label" scripting_name="min_max_over_label_fc"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: over label</h1><op-description description="Compute the component-wise minimum (out 0) and maximum (out 1) over all the fields having the same id for the label set in input in the fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="label" n="1" doc="label name from the fields container" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field_min" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="field_max" n="1" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_max_over_label_fc" cat="min_max" plugin="core" cpp-name="min_max_over_label_fc"></scripting-part></div><div class="operator" id="min by component" scripting_name="min_by_component"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: min by component</h1><op-description description="Give the minimum for each element rank by comparing several fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="use_absolute_value" n="0" doc="use_absolute_value" types="bool" optional="false"></pin-def><pin-def name="fieldA" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="2" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_by_component" cat="min_max" plugin="core" cpp-name="min_by_component"></scripting-part></div><div class="operator" id="max by component" scripting_name="max_by_component"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: max by component</h1><op-description description="Give the maximum for each element rank by comparing several fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="use_absolute_value" n="0" doc="use_absolute_value" types="bool" optional="false"></pin-def><pin-def name="fieldA" n="1" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="fieldB" n="2" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="max_by_component" cat="min_max" plugin="core" cpp-name="max_by_component"></scripting-part></div><div class="operator" id="merge fields by label" scripting_name="merge_fields_by_label"plugin="core"cat="logic"><h1 class="op-des-h1">logic: merge fields by label</h1><op-description description="Take a fields container and merge its fields that share the same label value."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="label" n="1" doc="Label identifier that should be merged." types="string" optional="false"></pin-def><pin-def name="merged_field_support" n="2" doc="The FieldsContainer's support that has already been merged." types="abstract_field_support" optional="true"></pin-def><pin-def name="sumMerge" n="3" doc="Default is false. If true redundant quantities are summed instead of being ignored." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="merged_field_support" n="1" doc="" types="abstract_field_support" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="merge_fields_by_label" cat="logic" plugin="core" cpp-name="merge::fields_container_label"></scripting-part></div><div class="operator" id="incremental over fields container" scripting_name="min_max_fc_inc"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: incremental over fields container</h1><op-description description="Compute the component-wise minimum (out 0) and maximum (out 1) over a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field_min" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="field_max" n="1" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_max_fc_inc" cat="min_max" plugin="core" cpp-name="min_max_fc_inc"></scripting-part></div><div class="operator" id="splitted on property type" scripting_name="splitted_on_property_type"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: splitted on property type</h1><op-description description="Splits a given scoping or the mesh scoping (nodal or elemental) on given properties (elshape and/or material) and returns a scopings container with those splitted scopings."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh_scoping" n="1" doc="Scoping" types="scoping" optional="true"></pin-def><pin-def name="mesh" n="7" doc="mesh region" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="requested_location" n="9" doc="location (default is elemental)" types="string" optional="false"></pin-def><pin-def name="label" n="13" doc="properties to apply the filtering 'mat' and/or 'elshape' (default is 'elshape)" types="string vector<string>" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="Scoping" types="scopings_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="splitted_on_property_type" cat="scoping" plugin="core" cpp-name="scoping::by_property"></scripting-part></div><div class="operator" id="incremental over field" scripting_name="min_max_inc"plugin="core"cat="min_max"><h1 class="op-des-h1">min_max: incremental over field</h1><op-description description="Compute the component-wise minimum (out 0) and maximum (out 1) over coming fields."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="domain_id" n="17" doc="" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field_min" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="field_max" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="domain_ids_min" n="2" doc="" types="scoping" optional="false"></pin-def><pin-def name="domain_ids_max" n="3" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="min_max_inc" cat="min_max" plugin="core" cpp-name="min_max_inc"></scripting-part></div><div class="operator" id="stress solution to global cs" scripting_name="stress_rotation_by_euler_nodes"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: stress solution to global cs</h1><op-description description="read Euler angles on elements from the rst file and rotate the fields in the fieldsContainer."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="2" doc="" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container stream class dataProcessing::CRstFileWrapper" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="stress_rotation_by_euler_nodes" cat="result" plugin="mapdl" cpp-name="mapdl::rst::S_rotation_by_euler_nodes"></scripting-part></div><div class="operator" id="rescope" scripting_name="rescope"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: rescope</h1><op-description description="Rescope a field on the given scoping. If an id does not exists in the original field, default value (in 2) is used if defined."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="rescope" cat="scoping" plugin="core" cpp-name="Rescope"></scripting-part></div><div class="operator" id="on named selection" scripting_name="on_named_selection"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: on named selection</h1><op-description description="provides a scoping at a given location based on a given named selection"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="requested_location" n="0" doc="" types="string" optional="false"></pin-def><pin-def name="named_selection_name" n="1" doc="the string is expected to be in upper case" types="string" optional="false"></pin-def><pin-def name="int_inclusive" n="2" doc="If element scoping is requested on a nodal named selection, if Inclusive == 1 then add all the elements adjacent to the nodes.If Inclusive == 0, only the elements which have all their nodes in the named selection are included" types="int32" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="on_named_selection" cat="scoping" plugin="core" cpp-name="scoping_provider_by_ns"></scripting-part></div><div class="operator" id="connectivity ids" scripting_name="connectivity_ids"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: connectivity ids</h1><op-description description="Returns the ordered node ids corresponding to the element ids scoping in input. For each element the node ids are its connectivity."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh_scoping" n="1" doc="Elemental scoping" types="scoping" optional="false"></pin-def><pin-def name="mesh" n="7" doc="the support of the scoping is expected if there is no mesh in input" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="take_mid_nodes" n="10" doc="default is true" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="" types="scoping" optional="false"></pin-def><pin-def name="elemental_scoping" n="1" doc="same as the input scoping but with ids dupplicated to havve the same size as nodal output scoping" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="connectivity_ids" cat="scoping" plugin="core" cpp-name="scoping::connectivity_ids"></scripting-part></div><div class="operator" id="cyclic support provider" scripting_name="cyclic_support_provider"plugin="mapdl"cat="metadata"><h1 class="op-des-h1">metadata: cyclic support provider</h1><op-description description="Read the cyclic support (DPF entity containing necessary informations for expansions) and expands the mesh."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="sector_meshed_region" n="7" doc="mesh of the first sector." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="if this pin is set, expanding the mesh is not necessary." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="scoping scopings_container vector<int32>" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="cyclic_support" n="0" doc="" types="cyclic_support" optional="false"></pin-def><pin-def name="sector_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_support_provider" cat="metadata" plugin="mapdl" cpp-name="mapdl::rst::support_provider_cyclic"></scripting-part></div><div class="operator" id="nodes in mesh" scripting_name="nodal_from_mesh"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: nodes in mesh</h1><op-description description="Get the nodes ids scoping of an input mesh."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_from_mesh" cat="scoping" plugin="core" cpp-name="GetNodeScopingFromMesh"></scripting-part></div><div class="operator" id="adapt with scopings container" scripting_name="change_fc"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: adapt with scopings container</h1><op-description description="Rescope a fields container to correspond to a scopings container"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="scopings_container" n="1" doc="" types="scopings_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="change_fc" cat="scoping" plugin="core" cpp-name="rescope_fc"></scripting-part></div><div class="operator" id="elemental nodal to nodal elemental (field)" scripting_name="elemental_nodal_to_nodal_elemental"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental nodal to nodal elemental (field)</h1><op-description description="Transform ElementalNodal field to NodalElemental, compute result on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_nodal_to_nodal_elemental" cat="averaging" plugin="core" cpp-name="ElementalNodal_To_NodalElemental"></scripting-part></div><div class="operator" id="change shell layers" scripting_name="change_shell_layers"plugin="core"cat="utility"><h1 class="op-des-h1">utility: change shell layers</h1><op-description description="Extract the expected shell layers from the input fields, if the fields contain only one layer then it returns the input fields"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="e_shell_layer" n="1" doc="0:Top, 1: Bottom, 2: BottomTop, 3:Mid, 4:BottomTopMid" types="int32 enum dataProcessing::EShellLayers" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="change_shell_layers" cat="utility" plugin="core" cpp-name="change_shellLayers"></scripting-part></div><div class="operator" id="merge solid and shell fields" scripting_name="merge::solid_shell_fields"plugin="core"cat="logic"><h1 class="op-des-h1">logic: merge solid and shell fields</h1><op-description description="Makes a fields based on fields container containing shell and solid fields with respect to time steps/frequencies."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="merge::solid_shell_fields" cat="logic" plugin="core" cpp-name="merge::solid_shell_fields"></scripting-part></div><div class="operator" id="same fields?" scripting_name="identical_fields"plugin="core"cat="logic"><h1 class="op-des-h1">logic: same fields?</h1><op-description description="Check if two fields are identical."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="double_value" n="2" doc="Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)." types="double" optional="true"></pin-def><pin-def name="double_tolerance" n="3" doc="Double relative tolerance.Maximum tolerance gap between to compared values : values within relative tolerance are considered identical(v1 - v2) / v2 < relativeTol(default is 0.001)." types="double" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="boolean" n="0" doc="bool (true if identical...)" types="bool" optional="false"></pin-def><pin-def name="message" n="1" doc="" types="string" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="identical_fields" cat="logic" plugin="core" cpp-name="AreFieldsIdentical"></scripting-part></div><div class="operator" id="fields included?" scripting_name="included_fields"plugin="core"cat="logic"><h1 class="op-des-h1">logic: fields included?</h1><op-description description="Check if one field belongs to another."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fieldA" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="fieldB" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="double_value" n="2" doc="Double positive small value. Smallest value which will be considered during the comparison step: all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)." types="double" optional="false"></pin-def><pin-def name="double_tolerance" n="3" doc="Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001)." types="double" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="included" n="0" doc="bool (true if belongs...)" types="bool" optional="false"></pin-def><pin-def name="message" n="1" doc="" types="string" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="included_fields" cat="logic" plugin="core" cpp-name="Are_fields_included"></scripting-part></div><div class="operator" id="same fields container?" scripting_name="identical_fc"plugin="core"cat="logic"><h1 class="op-des-h1">logic: same fields container?</h1><op-description description="Check if two fields container are identical."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_containerA" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="fields_containerB" n="1" doc="" types="fields_container" optional="false"></pin-def><pin-def name="tolerance" n="2" doc="Double relative tolerance. Maximum tolerance gap between to compared values: values within relative tolerance are considered identical (v1-v2)/v2 < relativeTol (default is 0.001)." types="double" optional="false"></pin-def><pin-def name="small_value" n="3" doc="Double positive small value.Smallest value which will be considered during the comparison step : all the abs(values) in field less than this value is considered as null, (default value:1.0e-14)." types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="boolean" n="0" doc="bool (true if identical...)" types="bool" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="identical_fc" cat="logic" plugin="core" cpp-name="AreFieldsIdentical_fc"></scripting-part></div><div class="operator" id="high pass (field)" scripting_name="field.high_pass"plugin="core"cat="filter"><h1 class="op-des-h1">filter: high pass (field)</h1><op-description description="The high pass filter returns all the values strictly superior to the threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="threshold" n="1" doc="a threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field.high_pass" cat="filter" plugin="core" cpp-name="core::field::high_pass"></scripting-part></div><div class="operator" id="high pass (only scoping)" scripting_name="scoping.high_pass"plugin="core"cat="filter"><h1 class="op-des-h1">filter: high pass (only scoping)</h1><op-description description="The high pass filter returns all the values strictly superior to the threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="threshold" n="1" doc="a threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scoping.high_pass" cat="filter" plugin="core" cpp-name="core::scoping::high_pass"></scripting-part></div><div class="operator" id="high pass (fields container)" scripting_name="field.high_pass_fc"plugin="core"cat="filter"><h1 class="op-des-h1">filter: high pass (fields container)</h1><op-description description="The high pass filter returns all the values strictly superior to the threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><pin-def name="threshold" n="1" doc="a threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field.high_pass_fc" cat="filter" plugin="core" cpp-name="core::field::high_pass_fc"></scripting-part></div><div class="operator" id="low pass (field)" scripting_name="field.low_pass"plugin="core"cat="filter"><h1 class="op-des-h1">filter: low pass (field)</h1><op-description description="The low pass filter returns all the values strictly inferior to the threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="threshold" n="1" doc="a threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field.low_pass" cat="filter" plugin="core" cpp-name="core::field::low_pass"></scripting-part></div><div class="operator" id="band pass (field)" scripting_name="field.band_pass"plugin="core"cat="filter"><h1 class="op-des-h1">filter: band pass (field)</h1><op-description description="The band pass filter returns all the values strictly superior to the min threshold value and stricly inferior to the max threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="min_threshold" n="1" doc="a min threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><pin-def name="max_threshold" n="2" doc="a max threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="field.band_pass" cat="filter" plugin="core" cpp-name="core::field::band_pass"></scripting-part></div><div class="operator" id="to cylindrical coordinates" scripting_name="to_cylindrical_cs"plugin="core"cat="geo"><h1 class="op-des-h1">geo: to cylindrical coordinates</h1><op-description description="Transform a field (not defined with a cynlindrical coordinate system) to its corresponding values into the specified cylindrical coordinate system (corresponding to the field position). If no coordinate system is set in the coordinate_system pin, field is rotated on each node following the local polar coordinate system."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="coordinate_system" n="1" doc="3-3 rotation matrix and origin coordinates must be set here to define a coordinate system." types="field" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="to_cylindrical_cs" cat="geo" plugin="core" cpp-name="transform_cylindricalCS"></scripting-part></div><div class="operator" id="band pass (only scoping)" scripting_name="scoping.band_pass"plugin="core"cat="filter"><h1 class="op-des-h1">filter: band pass (only scoping)</h1><op-description description="The band pass filter returns all the values strictly superior to the min threshold value and stricly inferior to the max threshold value in input."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="min_threshold" n="1" doc="a min threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><pin-def name="max_threshold" n="2" doc="a max threshold scalar or a field containing one value is expected" types="double field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="scoping.band_pass" cat="filter" plugin="core" cpp-name="core::scoping::band_pass"></scripting-part></div><div class="operator" id="mapdl run" scripting_name="mapdl.run"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: mapdl run</h1><op-description description="Solve in mapdl a dat/inp file and returns a datasources with the rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mapdl_exe_path" n="0" doc="" types="string" optional="true"></pin-def><pin-def name="working_dir" n="1" doc="" types="string" optional="true"></pin-def><pin-def name="number_of_processes" n="2" doc="Set the number of MPI processes used for resolution (default is 2)" types="int32" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the input file." types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="data_sources" n="0" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mapdl.run" cat="result" plugin="mapdl" cpp-name="mapdl::run"></scripting-part></div><div class="operator" id="csv to field" scripting_name="csv_to_field"plugin="csv"cat="serialization"><h1 class="op-des-h1">serialization: csv to field</h1><op-description description="transform csv file to a field or fields container"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing a file with csv extension" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="csv_to_field" cat="serialization" plugin="csv" cpp-name="csv_to_field"></scripting-part></div><div class="operator" id="rotate" scripting_name="rotate"plugin="core"cat="geo"><h1 class="op-des-h1">geo: rotate</h1><op-description description="Apply a transformation (rotation) matrix on field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="field_rotation_matrix" n="1" doc="3-3 rotation matrix" types="field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="rotate" cat="geo" plugin="core" cpp-name="rotate"></scripting-part></div><div class="operator" id="elemental nodal to nodal (field)" scripting_name="elemental_nodal_to_nodal"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental nodal to nodal (field)</h1><op-description description="Transform ElementalNodal field into Nodal field using an averaging process, result is computed on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="should_average" n="2" doc="each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)" types="bool" optional="true"></pin-def><pin-def name="mesh_scoping" n="3" doc="average only on these entities" types="scoping" optional="false"></pin-def><pin-def name="through_layers" n="10" doc="the max elemental difference is taken through the different shell layers if true (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_nodal_to_nodal" cat="averaging" plugin="core" cpp-name="elemental_nodal_To_nodal"></scripting-part></div><div class="operator" id="elemental nodal to nodal (fields container)" scripting_name="elemental_nodal_to_nodal_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental nodal to nodal (fields container)</h1><op-description description="Transform ElementalNodal fields into Nodal fields using an averaging process, result is computed on a given node scoping. If the input fields are mixed shell/solid, then the fields are splitted by element shape and the output fields container has elshape label."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="should_average" n="2" doc="each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)" types="bool" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_nodal_to_nodal_fc" cat="averaging" plugin="core" cpp-name="elemental_nodal_To_nodal_fc"></scripting-part></div><div class="operator" id="elemental to nodal (field)" scripting_name="elemental_to_nodal"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental to nodal (field)</h1><op-description description="Transform ElementalNodal field to Nodal field, compute result on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><pin-def name="force_averaging" n="2" doc="averaging on nodes is used if this pin is set to 1 (default is 1 for integrated results and 0 for dicrete ones)" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_to_nodal" cat="averaging" plugin="core" cpp-name="elemental_to_nodal"></scripting-part></div><div class="operator" id="elemental to nodal (fields container)" scripting_name="elemental_to_nodal_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental to nodal (fields container)</h1><op-description description="Transform ElementalNodal fields to Nodal fields, compute result on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><pin-def name="force_averaging" n="2" doc="averaging on nodes is used if this pin is set to 1 (default is one for integrated results and 0 for dicrete ones)" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_to_nodal_fc" cat="averaging" plugin="core" cpp-name="elemental_to_nodal_fc"></scripting-part></div><div class="operator" id="nodal difference (field)" scripting_name="nodal_difference"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: nodal difference (field)</h1><op-description description="Transform ElementalNodal field into Nodal field. Each nodal value is the maximum difference between the unaveraged computed result for all elements that share this particular node. Result is computed on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="should_average" n="2" doc="each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)" types="bool" optional="true"></pin-def><pin-def name="mesh_scoping" n="3" doc="average only on these entities" types="scoping" optional="false"></pin-def><pin-def name="through_layers" n="10" doc="the max elemental difference is taken through the different shell layers if true (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_difference" cat="averaging" plugin="core" cpp-name="nodal_difference"></scripting-part></div><div class="operator" id="eigen vectors" scripting_name="eigen_vectors"plugin="mapdl"cat="invariant"><h1 class="op-des-h1">invariant: eigen vectors</h1><op-description description="Computes the element-wise eigen vectors for each tensor in the fields of the field container"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields" n="0" doc="" types="fields_container field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="eigen_vectors" cat="invariant" plugin="mapdl" cpp-name="eig_vectors"></scripting-part></div><div class="operator" id="nodal difference (fields container)" scripting_name="nodal_difference_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: nodal difference (fields container)</h1><op-description description="Transform ElementalNodal fields into Nodal fields. Each nodal value is the maximum difference between the unaveraged computed result for all elements that share this particular node. Result is computed on a given node scoping. If the input fields are mixed shell/solid, then the fields are splitted by element shape and the output fields container has elshape label."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_difference_fc" cat="averaging" plugin="core" cpp-name="nodal_difference_fc"></scripting-part></div><div class="operator" id="elemental difference (field)" scripting_name="elemental_difference"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental difference (field)</h1><op-description description="Transform ElementalNodal or Nodal field into Elemental field. Each elemental value is the maximum difference between the computed result for all nodes in this element. Result is computed on a given element scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="should_average" n="2" doc="each nodal value is divided by the number of elements linked to this node (default is true for discrete quantities)" types="bool" optional="true"></pin-def><pin-def name="mesh_scoping" n="3" doc="average only on these entities" types="scoping" optional="false"></pin-def><pin-def name="through_layers" n="10" doc="the max elemental difference is taken through the different shell layers if true (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_difference" cat="averaging" plugin="core" cpp-name="elemental_difference"></scripting-part></div><div class="operator" id="elemental difference (fields container)" scripting_name="elemental_difference_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental difference (fields container)</h1><op-description description="Transform ElementalNodal or Nodal field into Elemental field. Each elemental value is the maximum difference between the unaveraged or averaged (depending on the input fields) computed result for all nodes in this element. Result is computed on a given element scoping. If the input fields are mixed shell/solid and the shells layers are not asked to be collapsed, then the fields are splitted by element shape and the output fields container has elshape label."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these elements, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><pin-def name="collapse_shell_layers" n="10" doc="the max elemental difference is taken through the different shell layers if true (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_difference_fc" cat="averaging" plugin="core" cpp-name="elemental_difference_fc"></scripting-part></div><div class="operator" id="nodal fraction (fields container)" scripting_name="nodal_fraction_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: nodal fraction (fields container)</h1><op-description description="Transform ElementalNodal fields into Nodal fields. Each nodal value is the fraction between the nodal difference and the nodal average. Result is computed on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these nodes, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><pin-def name="denominator" n="6" doc="if a fields container is set in this pin, it is used as the denominator of the fraction instead of elemental_nodal_To_nodal_fc" types="fields_container" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_fraction_fc" cat="averaging" plugin="core" cpp-name="nodal_fraction_fc"></scripting-part></div><div class="operator" id="cyclic expansion" scripting_name="cyclic_expansion"plugin="core"cat="result"><h1 class="op-des-h1">result: cyclic expansion</h1><op-description description="Expand cyclic results from a fieldsContainer for given sets, sectors and scoping (optionals).
"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="field container with the base and duplicate sectors" types="fields_container" optional="false"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_expansion" cat="result" plugin="core" cpp-name="cyclic_expansion"></scripting-part></div><div class="operator" id="to nodal (field)" scripting_name="to_nodal"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: to nodal (field)</h1><op-description description="Transform input field into Nodal field using an averaging process, result is computed on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="to_nodal" cat="averaging" plugin="core" cpp-name="to_nodal"></scripting-part></div><div class="operator" id="to cylindrical coordinates (fields container)" scripting_name="to_cylindrical_cs_fc"plugin="core"cat="geo"><h1 class="op-des-h1">geo: to cylindrical coordinates (fields container)</h1><op-description description="Transform all the fields of a fields container (not defined with a cynlindrical coordinate system) to its corresponding values into the specified cylindrical coordinate system (corresponding to the field position). If no coordinate system is set in the coordinate_system pin, field is rotated on each node following the local polar coordinate system."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field fields_container" optional="false"></pin-def><pin-def name="coordinate_system" n="1" doc="3-3 rotation matrix and origin coordinates must be set here to define a coordinate system." types="field" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="to_cylindrical_cs_fc" cat="geo" plugin="core" cpp-name="transform_cylindrical_cs_fc"></scripting-part></div><div class="operator" id="eigen values (field)" scripting_name="eigen_values"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: eigen values (field)</h1><op-description description="Computes the element-wise eigen values of a tensor field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="eigen_values" cat="invariant" plugin="core" cpp-name="eig_values"></scripting-part></div><div class="operator" id="to nodal (fields container)" scripting_name="to_nodal_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: to nodal (fields container)</h1><op-description description="Transform input fields into Nodal fields using an averaging process, result is computed on a given node scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="mesh_scoping" n="3" doc="" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="to_nodal_fc" cat="averaging" plugin="core" cpp-name="to_nodal_fc"></scripting-part></div><div class="operator" id="extend to mid nodes (field)" scripting_name="extend_to_mid_nodes"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: extend to mid nodes (field)</h1><op-description description="Extends ElementalNodal field defined on corner nodes to a ElementalNodal field defined also on the mid nodes."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="extend_to_mid_nodes" cat="averaging" plugin="core" cpp-name="extend_to_mid_nodes"></scripting-part></div><div class="operator" id="elemental mean (field)" scripting_name="elemental_mean"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental mean (field)</h1><op-description description="Computes the average of a multi-entity fields, (ElementalNodal -> Elemental), (NodalElemental -> Nodal)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="collapse_shell_layers" n="1" doc="if true shell layers are averaged as well (default is false)" types="bool" optional="true"></pin-def><pin-def name="force_averaging" n="2" doc="if true you average, if false you just sum" types="bool" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these elements, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_mean" cat="averaging" plugin="core" cpp-name="entity_average"></scripting-part></div><div class="operator" id="elemental mean (fields container)" scripting_name="elemental_mean_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: elemental mean (fields container)</h1><op-description description="Computes the average of a multi-entity container of fields, (ElementalNodal -> Elemental), (NodalElemental -> Nodal). If the input fields are mixed shell/solid and collapseShellLayers is not asked, then the fields are splitted by element shape and the output fields container has elshape label."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="collapse_shell_layers" n="1" doc="if true shell layers are averaged as well (default is false)" types="bool" optional="true"></pin-def><pin-def name="force_averaging" n="2" doc="if true you average, if false you just sum" types="bool" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these elements, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><pin-def name="abstract_meshed_region" n="4" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elemental_mean_fc" cat="averaging" plugin="core" cpp-name="entity_average_fc"></scripting-part></div><div class="operator" id="nodal to elemental (field)" scripting_name="nodal_to_elemental"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: nodal to elemental (field)</h1><op-description description="Transform Nodal field to Elemental field, compute result on a given element scoping."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><pin-def name="collapse_shell_layers" n="10" doc="if true shell layers are averaged as well (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_to_elemental" cat="averaging" plugin="core" cpp-name="nodal_to_elemental"></scripting-part></div><div class="operator" id="nodal to elemental (fields container)" scripting_name="nodal_to_elemental_fc"plugin="core"cat="averaging"><h1 class="op-des-h1">averaging: nodal to elemental (fields container)</h1><op-description description="Transform Nodal fields into Elemental fields using an averaging process, result is computed on a given elements scoping. If the input fields are mixed shell/solid and the shells layers are not asked to be collapsed, then the fields are splitted by element shape and the output fields container has elshape label."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="the mesh region in this pin is used to perform the averaging, if there is no field's support it is used" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="scoping" n="3" doc="average only on these elements, if it is scoping container, the label must correspond to the one of the fields container" types="scoping" optional="true"></pin-def><pin-def name="collapse_shell_layers" n="10" doc="if true shell layers are averaged as well (default is false)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_to_elemental_fc" cat="averaging" plugin="core" cpp-name="nodal_to_elemental_fc"></scripting-part></div><div class="operator" id="von mises eqv (field)" scripting_name="von_mises_eqv"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: von mises eqv (field)</h1><op-description description="Computes the element-wise Von-Mises criteria on a tensor field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="von_mises_eqv" cat="invariant" plugin="core" cpp-name="eqv"></scripting-part></div><div class="operator" id="scalar invariants (field)" scripting_name="invariants"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: scalar invariants (field)</h1><op-description description="Computes the element-wise invariants of a tensor field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field_int" n="0" doc="stress intensity field" types="field" optional="false"></pin-def><pin-def name="field_eqv" n="1" doc="stress equivalent intensity" types="field" optional="false"></pin-def><pin-def name="field_max_shear" n="2" doc="max shear stress field" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="invariants" cat="invariant" plugin="core" cpp-name="invariants_deriv"></scripting-part></div><div class="operator" id="principal invariants (fields container)" scripting_name="principal_invariants_fc"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: principal invariants (fields container)</h1><op-description description="Computes the element-wise eigen values of all the tensor fields of a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_eig_1" n="0" doc="first eigen value fields" types="fields_container" optional="false"></pin-def><pin-def name="fields_eig_2" n="1" doc="second eigen value fields" types="fields_container" optional="false"></pin-def><pin-def name="fields_eig_3" n="2" doc="third eigen value fields" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="principal_invariants_fc" cat="invariant" plugin="core" cpp-name="invariants_fc"></scripting-part></div><div class="operator" id="von mises eqv (fields container)" scripting_name="von_mises_eqv_fc"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: von mises eqv (fields container)</h1><op-description description="Computes the element-wise Von-Mises criteria on all the tensor fields of a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="von_mises_eqv_fc" cat="invariant" plugin="core" cpp-name="eqv_fc"></scripting-part></div><div class="operator" id="scalar invariants (fields container)" scripting_name="invariants_fc"plugin="core"cat="invariant"><h1 class="op-des-h1">invariant: scalar invariants (fields container)</h1><op-description description="Computes the element-wise invariants of all the tensor fields of a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_int" n="0" doc="stress intensity field" types="fields_container" optional="false"></pin-def><pin-def name="fields_eqv" n="1" doc="stress equivalent intensity" types="fields_container" optional="false"></pin-def><pin-def name="fields_max_shear" n="2" doc="max shear stress field" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="invariants_fc" cat="invariant" plugin="core" cpp-name="invariants_deriv_fc"></scripting-part></div><div class="operator" id="rotate (fields container)" scripting_name="rotate_fc"plugin="core"cat="geo"><h1 class="op-des-h1">geo: rotate (fields container)</h1><op-description description="Apply a transformation (rotation) matrix on all the fields of a fields container."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="coordinate_system" n="1" doc="3-3 rotation matrix" types="field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="rotate_fc" cat="geo" plugin="core" cpp-name="rotate_fc"></scripting-part></div><div class="operator" id="normals provider nl (nodes or elements)" scripting_name="normals_provider_nl"plugin="core"cat="geo"><h1 class="op-des-h1">geo: normals provider nl (nodes or elements)</h1><op-description description="Compute the normals on nodes/elements based on integration points(more accurate for non-linear elements), on a skin mesh"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="skin or shell mesh region" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="normals_provider_nl" cat="geo" plugin="core" cpp-name="normals_provider_nl"></scripting-part></div><div class="operator" id="elements volumes over time" scripting_name="elements_volumes_over_time"plugin="core"cat="geo"><h1 class="op-des-h1">geo: elements volumes over time</h1><op-description description="Calculation of the volume of each element over time of a mesh for each specified time step."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="scoping" n="1" doc="" types="scoping" optional="true"></pin-def><pin-def name="displacement" n="2" doc="Displacement field's container. Must contain the mesh if mesh not specified in input." types="fields_container" optional="true"></pin-def><pin-def name="mesh" n="7" doc="Mesh must be defined if the displacement field's container does not contain it, or if there is no displacement." types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elements_volumes_over_time" cat="geo" plugin="core" cpp-name="volumes_provider"></scripting-part></div><div class="operator" id="elements facets surfaces over time" scripting_name="elements_facets_surfaces_over_time"plugin="core"cat="geo"><h1 class="op-des-h1">geo: elements facets surfaces over time</h1><op-description description="Calculation of the surface of each element's facet over time of a mesh for each specified time step. Moreover, it gives as output a new mesh made with only surface elements."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="scoping" n="1" doc="" types="scoping" optional="true"></pin-def><pin-def name="displacement" n="2" doc="Displacement field's container." types="fields_container" optional="true"></pin-def><pin-def name="mesh" n="7" doc="Mesh must be defined if the displacement field's container does not contain it, or if there is no displacement." types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="Surfaces field." types="fields_container" optional="false"></pin-def><pin-def name="mesh" n="1" doc="Mesh made of surface elements only." types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elements_facets_surfaces_over_time" cat="geo" plugin="core" cpp-name="surfaces_provider"></scripting-part></div><div class="operator" id="equivalent radiated power" scripting_name="equivalent_radiated_power"plugin="core"cat="result"><h1 class="op-des-h1">result: equivalent radiated power</h1><op-description description="Compute the Equivalent Radiated Power (ERP)"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="abstract_meshed_region" n="1" doc="the mesh region in this pin have to be boundary or skin mesh" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="int32" n="2" doc="load step number, if it's specified, the ERP is computed only on the substeps of this step" types="int32" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="equivalent_radiated_power" cat="result" plugin="core" cpp-name="ERP"></scripting-part></div><div class="operator" id="from mesh" scripting_name="from_mesh"plugin="core"cat="scoping"><h1 class="op-des-h1">scoping: from mesh</h1><op-description description="Provides the entire mesh scoping based on the requested location"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="requested_location" n="1" doc="if nothing the operator returns the nodes scoping, possible locations are: Nodal or Elemental" types="string" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="scoping" n="0" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="from_mesh" cat="scoping" plugin="core" cpp-name="MeshScopingProvider"></scripting-part></div><div class="operator" id="from scoping" scripting_name="from_scoping"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: from scoping</h1><op-description description="Extracts a meshed region from an other meshed region base on a scoping"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="scoping" n="1" doc="if nodal scoping, then the scoping is transposed respecting the inclusive pin" types="scoping" optional="false"></pin-def><pin-def name="inclusive" n="2" doc="if inclusive == 1 then all the elements adjacent to the nodes ids in input are added, if inclusive == 0, only the elements which have all their nodes in the scoping are included" types="int32" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="from_scoping" cat="mesh" plugin="core" cpp-name="mesh::by_scoping"></scripting-part></div><div class="operator" id="split field wrt mesh regions" scripting_name="split_fields"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: split field wrt mesh regions</h1><op-description description="Split the input field or fields container based on the input mesh regions "></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field_or_fields_container" n="0" doc="" types="field fields_container" optional="false"></pin-def><pin-def name="mesh_controller" n="1" doc="body meshes in the mesh controller cannot be mixed shell/solid" types="class dataProcessing::CMeshController" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="split_fields" cat="mesh" plugin="core" cpp-name="split_fields"></scripting-part></div><div class="operator" id="split mesh wrt property" scripting_name="split_mesh"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: split mesh wrt property</h1><op-description description="Split the input mesh into several meshes based on a given property (material property be default)"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh_scoping" n="1" doc="Scoping" types="scoping" optional="true"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="property" n="13" doc="" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh_controller" n="0" doc="" types="class dataProcessing::CMeshController" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="split_mesh" cat="mesh" plugin="core" cpp-name="split_mesh"></scripting-part></div><div class="operator" id="torque" scripting_name="torque"plugin="core"cat="result"><h1 class="op-des-h1">result: torque</h1><op-description description="Compute torque of a force based on a 3D point.
"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="fields_container" types="fields_container" optional="false"></pin-def><pin-def name="vector_of_double" n="1" doc="vector_of_double" types="vector<double>" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="torque" cat="result" plugin="core" cpp-name="torque"></scripting-part></div><div class="operator" id="cyclic mesh expansion" scripting_name="cyclic_mesh_expansion"plugin="core"cat="result"><h1 class="op-des-h1">result: cyclic mesh expansion</h1><op-description description="Read the cyclic support."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="sectors_to_expand" n="0" doc="vector sectors to expand (start at 0)." types="vector<int32>" optional="true"></pin-def><pin-def name="sector_meshed_region" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="meshed_region" n="0" doc="expanded meshed region." types="abstract_meshed_region" optional="false"></pin-def><pin-def name="cyclic_support" n="1" doc="input cyclic support modified in place containing the new expanded meshed region." types="cyclic_support" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_mesh_expansion" cat="result" plugin="core" cpp-name="cyclic_expansion_mesh"></scripting-part></div><div class="operator" id="cyclic analytic disp max" scripting_name="cyclic_analytic_usum_max"plugin="core"cat="result"><h1 class="op-des-h1">result: cyclic analytic disp max</h1><op-description description="Compute the maximum of the total deformation that can be expected on 360 degrees"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="field container with the base and duplicate sectors" types="fields_container" optional="false"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_analytic_usum_max" cat="result" plugin="core" cpp-name="cyclic_analytic_usum_max"></scripting-part></div><div class="operator" id="cyclic analytic stress eqv max" scripting_name="cyclic_analytic_seqv_max"plugin="core"cat="result"><h1 class="op-des-h1">result: cyclic analytic stress eqv max</h1><op-description description="Compute the maximum of the Von Mises equivalent stress that can be expected on 360 degrees"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="field container with the base and duplicate sectors" types="fields_container" optional="false"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_analytic_seqv_max" cat="result" plugin="core" cpp-name="cyclic_analytic_stress_eqv_max"></scripting-part></div><div class="operator" id="remove rigid body motion (fields container)" scripting_name="remove_rigid_body_motion_fc"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: remove rigid body motion (fields container)</h1><op-description description="Removes rigid body mode from a total displacement field by minimization. Use a reference point in order to substract its displacement to the result displacement field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="field or fields container with only one field is expected" types="fields_container" optional="false"></pin-def><pin-def name="reference_node_id" n="1" doc="Id of the reference entity (node)." types="int32" optional="true"></pin-def><pin-def name="mesh" n="7" doc="default is the mesh in the support" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="remove_rigid_body_motion_fc" cat="result" plugin="mapdl" cpp-name="ExtractRigidBodyMotion_fc"></scripting-part></div><div class="operator" id="recombine cyclic harmonic indeces" scripting_name="recombine_harmonic_indeces_cyclic"plugin="core"cat="result"><h1 class="op-des-h1">result: recombine cyclic harmonic indeces</h1><op-description description="Add the fields corresponding to different load steps with the same frequencies to compute the response."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="recombine_harmonic_indeces_cyclic" cat="result" plugin="core" cpp-name="recombine_harmonic_indeces_cyclic"></scripting-part></div><div class="operator" id="on coordinates" scripting_name="on_coordinates"plugin="core"cat="mapping"><h1 class="op-des-h1">mapping: on coordinates</h1><op-description description="Evaluates a result on specified coordinates (interpolates results inside elements with shape functions)."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="coordinates" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="create_support" n="2" doc="if this pin is set to true, then, a support associated to the fields consisting of points is created" types="bool" optional="true"></pin-def><pin-def name="mapping_on_scoping" n="3" doc="if this pin is set to true, then the mapping between the coordinates and the fields is created only on the first field scoping" types="bool" optional="true"></pin-def><pin-def name="mesh" n="7" doc="if the first field in input has no mesh in support, then the mesh in this pin is expected (default is false)" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="on_coordinates" cat="mapping" plugin="core" cpp-name="mapping"></scripting-part></div><div class="operator" id="solid to skin" scripting_name="solid_to_skin"plugin="core"cat="mapping"><h1 class="op-des-h1">mapping: solid to skin</h1><op-description description="Maps a field defined on solid elements to a field defined on skin elements."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="skin mesh region expected" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="solid_to_skin" cat="mapping" plugin="core" cpp-name="solid_to_skin"></scripting-part></div><div class="operator" id="elements volume" scripting_name="elements_volume"plugin="core"cat="geo"><h1 class="op-des-h1">geo: elements volume</h1><op-description description="Compute the volume of each element of a mesh, using default shape functions."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elements_volume" cat="geo" plugin="core" cpp-name="element::volume"></scripting-part></div><div class="operator" id="element nodal contribution" scripting_name="element_nodal_contribution"plugin="core"cat="geo"><h1 class="op-des-h1">geo: element nodal contribution</h1><op-description description="Compute the fraction of volume attributed to each node of each element."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="scoping" n="1" doc="Integrate the input field over a specific scoping." types="scoping" optional="true"></pin-def><pin-def name="volume_fraction" n="2" doc="if true, returns influence volume, if false, return influence volume fraction (i.e. integrated value of shape function for each node)." types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="element_nodal_contribution" cat="geo" plugin="core" cpp-name="element::nodal_contribution"></scripting-part></div><div class="operator" id="nodal averaged thermal swelling strains" scripting_name="nodal_averaged_thermal_swelling_strains"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged thermal swelling strains</h1><op-description description="Read nodal averaged thermal swelling strains as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_thermal_swelling_strains" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NTH_SWL"></scripting-part></div><div class="operator" id="add rigid body motion (field)" scripting_name="add_rigid_body_motion"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: add rigid body motion (field)</h1><op-description description="Adds a given rigid translation, center and rotation from a displacement field. The rotation is given in terms of rotations angles. Note that the displacement field has to be in the global coordinate sytem"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="displacement_field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="translation_field" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="rotation_field" n="2" doc="" types="field" optional="false"></pin-def><pin-def name="center_field" n="3" doc="" types="field" optional="false"></pin-def><pin-def name="mesh" n="7" doc="default is the mesh in the support" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="add_rigid_body_motion" cat="result" plugin="mapdl" cpp-name="RigidBodyAddition"></scripting-part></div><div class="operator" id="nodal averaged stresses" scripting_name="nodal_averaged_stresses"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged stresses</h1><op-description description="Read nodal averaged stresses as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_stresses" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NS"></scripting-part></div><div class="operator" id="nodal averaged plastic strains" scripting_name="nodal_averaged_plastic_strains"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged plastic strains</h1><op-description description="Read nodal averaged plastic strains as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_plastic_strains" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NPPL"></scripting-part></div><div class="operator" id="nodal averaged creep strains" scripting_name="nodal_averaged_creep_strains"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged creep strains</h1><op-description description="Read nodal averaged creep strains as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_creep_strains" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NCR"></scripting-part></div><div class="operator" id="nodal averaged equivalent elastic strain" scripting_name="nodal_averaged_equivalent_elastic_strain"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged equivalent elastic strain</h1><op-description description="Read nodal averaged equivalent elastic strain as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_equivalent_elastic_strain" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NPEL_EQV"></scripting-part></div><div class="operator" id="nodal averaged equivalent creep strain" scripting_name="nodal_averaged_equivalent_creep_strain"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nodal averaged equivalent creep strain</h1><op-description description="Read nodal averaged equivalent creep strain as averaged nodal result from rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="nodal_averaged_equivalent_creep_strain" cat="result" plugin="mapdl" cpp-name="mapdl::rst::NCR_EQV"></scripting-part></div><div class="operator" id="euler nodes" scripting_name="euler_nodes"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: euler nodes</h1><op-description description="read a field made of 3 coordinates and 3 Euler angles (6 dofs) by node from the rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="streams_container" n="3" doc="" types="streams_container stream class dataProcessing::CRstFileWrapper" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><pin-def name="coord_and_euler" n="6" doc="if true, then the field has ncomp=6 with 3 oords and 3 euler angles, else there is only the euler angles (default is true)" types="bool" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="euler_nodes" cat="result" plugin="mapdl" cpp-name="mapdl::rst::coords_and_euler_nodes"></scripting-part></div><div class="operator" id="nmisc" scripting_name="mapdl.nmisc"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: nmisc</h1><op-description description="Read NMISC results from the rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mapdl.nmisc" cat="result" plugin="mapdl" cpp-name="mapdl::nmisc"></scripting-part></div><div class="operator" id="enf solution to global cs" scripting_name="enf_rotation_by_euler_nodes"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: enf solution to global cs</h1><op-description description="read Euler angles on elements from the rst file and rotate the fields in the fieldsContainer."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="2" doc="" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container stream class dataProcessing::CRstFileWrapper" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="enf_rotation_by_euler_nodes" cat="result" plugin="mapdl" cpp-name="ENF_rotation_by_euler_nodes"></scripting-part></div><div class="operator" id="cms matrices provider" scripting_name="cms_matrices_provider"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cms matrices provider</h1><op-description description="Read reducted matrices for cms elements. Extract stiffness, damping, mass matrices and load vector from a subfile."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="data_sources" n="4" doc="Data_sources (must contain at list one subfile)." types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="Fields container containing in this order : stiffness, damping, mass matrices, and then load vector." types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cms_matrices_provider" cat="result" plugin="mapdl" cpp-name="cms_matrices_provider"></scripting-part></div><div class="operator" id="skin" scripting_name="skin"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: skin</h1><op-description description="Extracts a skin of the mesh (2D elements) in a new meshed region"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scoping" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="skin meshed region with facets and facets_to_ele property fields" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="nodes_mesh_scoping" n="1" doc="" types="scoping" optional="false"></pin-def><pin-def name="map_new_elements_to_old" n="2" doc="" types="umap<int32,int32>" optional="false"></pin-def><pin-def name="property_field_new_elements_to_old" n="3" doc="" types="property_field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="skin" cat="mesh" plugin="core" cpp-name="meshed_skin_sector"></scripting-part></div><div class="operator" id="smisc" scripting_name="mapdl.smisc"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: smisc</h1><op-description description="Read SMISC results from the rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="mesh" n="7" doc="" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mapdl.smisc" cat="result" plugin="mapdl" cpp-name="mapdl::smisc"></scripting-part></div><div class="operator" id="elastic strain solution to global cs" scripting_name="elastic_strain_rotation_by_euler_nodes"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: elastic strain solution to global cs</h1><op-description description="read Euler angles on elements from the rst file and rotate the fields in the fieldsContainer."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="2" doc="" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container stream class dataProcessing::CRstFileWrapper" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="elastic_strain_rotation_by_euler_nodes" cat="result" plugin="mapdl" cpp-name="mapdl::rst::EPEL_rotation_by_euler_nodes"></scripting-part></div><div class="operator" id="plastic strain to global cs" scripting_name="plastic_strain_rotation_by_euler_nodes"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: plastic strain to global cs</h1><op-description description="read Euler angles on elements from the rst file and rotate the fields in the fieldsContainer."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="2" doc="" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="" types="streams_container stream class dataProcessing::CRstFileWrapper" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="" types="data_sources" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="plastic_strain_rotation_by_euler_nodes" cat="result" plugin="mapdl" cpp-name="mapdl::rst::EPPL_rotation_by_euler_nodes"></scripting-part></div><div class="operator" id="prns to field" scripting_name="mapdl.prns_to_field"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: prns to field</h1><op-description description="Read the presol of nodal field generated file from mapdl."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="filepath" n="0" doc="filepath" types="string" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mapdl.prns_to_field" cat="result" plugin="mapdl" cpp-name="PRNS_Reader"></scripting-part></div><div class="operator" id="mesh cutter" scripting_name="mesh_cut"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: mesh cutter</h1><op-description description="Extracts a skin of the mesh in triangles (2D elements) in a new meshed region"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><pin-def name="iso_value" n="1" doc="iso value" types="double" optional="false"></pin-def><pin-def name="closed_surface" n="3" doc="1: closed surface, 0:iso surface" types="double" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="2" doc="" types="meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="mesh_cut" cat="mesh" plugin="core" cpp-name="mesh_cut"></scripting-part></div><div class="operator" id="remove rigid body motion (field)" scripting_name="remove_rigid_body_motion"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: remove rigid body motion (field)</h1><op-description description="Removes rigid body mode from a total displacement field by minimization. Use a reference point in order to substract its displacement to the result displacement field."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="field fields_container" optional="false"></pin-def><pin-def name="reference_node_id" n="1" doc="Id of the reference entity (node)." types="int32" optional="true"></pin-def><pin-def name="mesh" n="7" doc="default is the mesh in the support" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="remove_rigid_body_motion" cat="result" plugin="mapdl" cpp-name="ExtractRigidBodyMotion"></scripting-part></div><div class="operator" id="add rigid body motion (fields container)" scripting_name="add_rigid_body_motion_fc"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: add rigid body motion (fields container)</h1><op-description description="Adds a given rigid translation, center and rotation from a displacement field. The rotation is given in terms of rotations angles. Note that the displacement field has to be in the global coordinate sytem"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><pin-def name="translation_field" n="1" doc="" types="field" optional="false"></pin-def><pin-def name="rotation_field" n="2" doc="" types="field" optional="false"></pin-def><pin-def name="center_field" n="3" doc="" types="field" optional="false"></pin-def><pin-def name="mesh" n="7" doc="default is the mesh in the support" types="abstract_meshed_region" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="fields_container" n="0" doc="" types="fields_container" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="add_rigid_body_motion_fc" cat="result" plugin="mapdl" cpp-name="RigidBodyAddition_fc"></scripting-part></div><div class="operator" id="cyclic expanded displacement" scripting_name="cyclic_expanded_displacement"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cyclic expanded displacement</h1><op-description description="Read displacements from an rst file and expand it with cyclic symmetry."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="sector_mesh" n="7" doc="mesh of the base sector (can be a skin)." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="location needed in output" types="string" optional="true"></pin-def><pin-def name="modal_damping_coefs" n="10" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="global_damping_coefs" n="11" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="freq" n="12" doc="" types="double" optional="false"></pin-def><pin-def name="read_cyclic" n="14" doc="if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)" types="enum dataProcessing::ECyclicReading int32" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="mesh expanded." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="vector<int32> scoping scopings_container" optional="true"></pin-def><pin-def name="phi" n="19" doc="angle phi (default value 0.0)" types="double" optional="true"></pin-def><pin-def name="filter_degenerated_elements" n="20" doc="if it's set to true, results are filtered to handle degenerated elements (default is true)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="static_matrix" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><pin-def name="expanded_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="inertia_matrix" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="remote_point_id" n="3" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_expanded_displacement" cat="result" plugin="mapdl" cpp-name="mapdl::rst::U_cyclic"></scripting-part></div><div class="operator" id="cyclic expanded stress" scripting_name="cyclic_expanded_stress"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cyclic expanded stress</h1><op-description description="Read mapdl::rst::S from an rst file and expand it with cyclic symmetry."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="sector_mesh" n="7" doc="mesh of the base sector (can be a skin)." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="location needed in output" types="string" optional="true"></pin-def><pin-def name="modal_damping_coefs" n="10" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="global_damping_coefs" n="11" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="freq" n="12" doc="" types="double" optional="false"></pin-def><pin-def name="read_cyclic" n="14" doc="if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)" types="enum dataProcessing::ECyclicReading int32" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="mesh expanded." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="vector<int32> scoping scopings_container" optional="true"></pin-def><pin-def name="phi" n="19" doc="phi angle (default value 0.0)" types="double" optional="true"></pin-def><pin-def name="filter_degenerated_elements" n="20" doc="if it's set to true, results are filtered to handle degenerated elements (default is true)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="static_matrix" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><pin-def name="expanded_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="inertia_matrix" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="remote_point_id" n="3" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_expanded_stress" cat="result" plugin="mapdl" cpp-name="mapdl::rst::S_cyclic"></scripting-part></div><div class="operator" id="cyclic volume" scripting_name="cyclic_volume"plugin="mapdl"cat="result"><h1 class="op-des-h1">result: cyclic volume</h1><op-description description="Read mapdl::rst::ENG_VOL from an rst file."></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="time_scoping" n="0" doc="" types="scoping vector<int32>" optional="true"></pin-def><pin-def name="mesh_scoping" n="1" doc="" types="scopings_container scoping vector<int32>" optional="true"></pin-def><pin-def name="fields_container" n="2" doc="FieldsContainer already allocated modified inplace" types="fields_container" optional="true"></pin-def><pin-def name="streams_container" n="3" doc="Streams containing the result file." types="streams_container stream" optional="true"></pin-def><pin-def name="data_sources" n="4" doc="data sources containing the result file." types="data_sources" optional="false"></pin-def><pin-def name="bool_rotate_to_global" n="5" doc="if true the field is roated to global coordinate system (default true)" types="bool" optional="true"></pin-def><pin-def name="sector_mesh" n="7" doc="mesh of the base sector (can be a skin)." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="requested_location" n="9" doc="location needed in output" types="string" optional="true"></pin-def><pin-def name="modal_damping_coefs" n="10" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="global_damping_coefs" n="11" doc="" types="vector<double>" optional="false"></pin-def><pin-def name="freq" n="12" doc="" types="double" optional="false"></pin-def><pin-def name="read_cyclic" n="14" doc="if 0 cyclic symmetry is ignored, if 1 cyclic sector is read, if 2 cyclic expansion is done (default is 1)" types="enum dataProcessing::ECyclicReading int32" optional="true"></pin-def><pin-def name="expanded_meshed_region" n="15" doc="mesh expanded." types="abstract_meshed_region" optional="true"></pin-def><pin-def name="cyclic_support" n="16" doc="" types="cyclic_support" optional="true"></pin-def><pin-def name="sectors_to_expand" n="18" doc="sectors to expand (start at 0), for multistage: use scopings container with 'stage' label." types="vector<int32> scoping scopings_container" optional="true"></pin-def><pin-def name="phi" n="19" doc="phi angle (default value 0.0)" types="double" optional="true"></pin-def><pin-def name="filter_degenerated_elements" n="20" doc="if it's set to true, results are filtered to handle degenerated elements (default is true)" types="bool" optional="true"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="static_matrix" n="0" doc="FieldsContainer filled in" types="fields_container" optional="false"></pin-def><pin-def name="expanded_meshed_region" n="1" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="inertia_matrix" n="2" doc="" types="fields_container" optional="false"></pin-def><pin-def name="remote_point_id" n="3" doc="" types="int32" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="cyclic_volume" cat="result" plugin="mapdl" cpp-name="mapdl::rst::ENG_VOL_cyclic"></scripting-part></div><div class="operator" id="eigen vectors (on fields container)" scripting_name="eigen_vectors_fc"plugin="mapdl"cat="invariant"><h1 class="op-des-h1">invariant: eigen vectors (on fields container)</h1><op-description description="Computes the element-wise eigen vectors for each tensor in the field"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="field" n="0" doc="field or fields container with only one field is expected" types="fields_container field" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="field" n="0" doc="" types="field" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="eigen_vectors_fc" cat="invariant" plugin="mapdl" cpp-name="eig_vectors_fc"></scripting-part></div><div class="operator" id="external layer" scripting_name="external_layer"plugin="core"cat="mesh"><h1 class="op-des-h1">mesh: external layer</h1><op-description description="Extracts the external layer (thick skin) of the mesh (3D elements) in a new meshed region"></op-description><h2 class="op-des-h2">Inputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><h2 class="op-des-h2">Outputs</h2><pin-def name="mesh" n="0" doc="" types="abstract_meshed_region" optional="false"></pin-def><pin-def name="nodes_mesh_scoping" n="1" doc="" types="scoping" optional="false"></pin-def><pin-def name="elements_mesh_scoping" n="2" doc="" types="scoping" optional="false"></pin-def><h2 class="op-des-h2">Scripting</h2><scripting-part scripting_name="external_layer" cat="mesh" plugin="core" cpp-name="meshed_external_layer_sector"></scripting-part></div></div>
    <script type="text/javascript">
function myFunction() {
    var input, filter, ul, li, a, i;
    input = document.getElementById("mySearch");
    filter = input.value.toUpperCase();
    side_menu = document.getElementById("sidenav");
    divs = side_menu.getElementsByTagName("div");
    for (div = 0; div < divs.length; div++) {
        var bdeactivate = new Boolean("true");
        ul = divs[div].getElementsByTagName("ul");
        lis = ul[0].getElementsByTagName("li");
        for (i = 0; i < lis.length; i++) {
            a = lis[i].getElementsByTagName("a")[0];
            operator = document.getElementById(a.id.substr(5));
            if (a.innerHTML.toUpperCase().indexOf(filter) > -1 || a.getAttribute("cat").toUpperCase().indexOf(filter) > -1 || operator.getAttribute("scripting_name").toUpperCase().indexOf(filter) > -1) {
                lis[i].style.display = "";
                divs[div].style.display = "block";
                bdeactivate = false;
            } else {
                lis[i].style.display = "none";
            }
        }

        var prev = divs[div].previousSibling;
        if (bdeactivate == true) {
            prev.style.display = "none";
            divs[div].style.display = "none";
        }
        else {
            prev.style.display = "block";
            divs[div].style.display = "block";
        }
    }
    if (input.value.length == 0) {
        var coll = document.getElementsByClassName("collapsible");
        for (var i = 0; i < coll.length; i++) {

            var content = coll[i].nextElementSibling;
            if (content.style.display === "block") {
                content.style.display = "none";
            } else {
                content.style.display = "block";
            }
        }
    }


};

function changeDisplay(caller) {
    if (caller.id == "disp_allOperators") {
        disp = document.getElementById("displayer");
        li = disp.getElementsByTagName("li");

        var text = "";
        for (i = 0; i < li.length; i++) {
            input = document.getElementById(li[i].children[0].id.substr(5));
            text += input.innerHTML;
            text += "<hr>";
        }
        disp.innerHTML = text;
    }
    else if (caller.id.substr(0, 5) == "disp_") {
        var display_id = caller.id.substr(5);

        var actualNode = document.getElementById(display_id);
        disp = document.getElementById("displayer");
        disp.innerHTML = actualNode.innerHTML;
        var sibling = document.getElementsByClassName("my-main-menu");
        for (var i = 0; i < sibling.length; i++) {
            sibling[i].classList.remove("active");
        }
        actualNode.classList.toggle("active");
        var buttonNode = document.getElementById(caller.id);
        buttonNode.classList.toggle("active");
        if (buttonNode.parentNode != null)
        {
            if (buttonNode.parentNode.parentNode != null) {
                if (buttonNode.parentNode.parentNode.parentNode != null && buttonNode.parentNode.parentNode.parentNode.tagName === "A") {
                    buttonNode.parentNode.parentNode.parentNode.classList.toggle("active");
                    buttonNode.parentNode.parentNode.parentNode["childclicked"] = true;
                }
            }
        }

    }
};


function changeDisplayMouseOver(caller) {
    var thisNode = document.getElementById(caller.id);
    thisNode.classList.toggle("active");
    var nextNode = thisNode.childNodes[0].nextSibling;
    var display_id = caller.id.substr(5);
    if (nextNode.className === "content-list-topnav") {
        nextNode.classList.toggle("active");

       
            nextNode.style.display = "block";
    }
}

function changeDisplayMouseOut(caller) {
    
    var thisNode = document.getElementById(caller.id);
    var nextNode = thisNode.childNodes[0].nextSibling;
    var display_id = caller.id.substr(5);
    nextNode.classList.remove("active");

    if (nextNode.style.display === "block") {
        nextNode.style.display = "none";
    }
    var childIsActive = thisNode.childclicked == true;
    if (childIsActive === false)
        thisNode.classList.remove("active");
}

function changeDisplayScript(caller) {
    var className = caller.className;
    var other = caller.parentNode.parentNode.parentNode.getElementsByClassName(className);
    for (var i = 0; i < other.length; i++)
        other[i].classList.remove("active");
    caller.classList.toggle("active");
    var id = caller.id;
    var content_name = "content" + id.substr(6);
    var content = caller.parentNode.parentNode.parentNode;
    content =findChildById(content,content_name);
    if (content.style.display === "block") {

        content.style.display = "none";

    } else {

        content.style.display = "block";

    }

   // display to none for siblings
    var li = caller.parentNode;
    var sibling = li.nextElementSibling;

    while (sibling) {
        content_name = "content" + sibling.getElementsByTagName("a")[0].id.substr(6);
        document.getElementById(content_name).style.display = "none";
        sibling = sibling.nextElementSibling;
    }

    li = caller.parentNode;
    var sibling = li.previousSibling;

    while (sibling) {
        content_name = "content" + sibling.getElementsByTagName("a")[0].id.substr(6);
        document.getElementById(content_name).style.display = "none";
        sibling = sibling.previousSibling;
    }
};
function changeOperatorDisplay(caller) {
    input = document.getElementById(caller.id.substr(5));
    disp = document.getElementById("displayer");
    disp.innerHTML = input.innerHTML;
    var othera = document.getElementsByTagName("a");
    for (i = 0; i < othera.length; i++) {
        if (othera[i].id.substr(0, 5) == "disp_") {
            othera[i].classList.remove("active");
        }
    }
}

function findChildById(element, childID) {
    var retElement = null;
    var lstChildren = element.childNodes;

    for (var i = 0; i < lstChildren.length; i++) {
        if (lstChildren[i].id == childID) {
            retElement = lstChildren[i];
            break;
        }
    }

    return retElement;
}

function collapsibleTreatment() {
    var coll = document.getElementsByClassName("collapsible");
    var i;

    for (i = 0; i < coll.length; i++) {
        coll[i].addEventListener("click", function () {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.display === "block") {
                content.style.display = "none";
            } else {
                content.style.display = "block";
            }
        });
    }
}

function fillOperatorList() {
    operators = document.getElementById("operator_list");
    side_menu = document.getElementById("sidenav");
    var ordered_op_list = [];
    var ordered_cat_list = [];
    for (i = 0; i < operators.children.length; i++) {
        op = operators.children[i];
        if (op.className == "operator") {
            ordered_op_list.push(op.id);
            var cat_name = op.getAttribute("cat");
            if (!cat_name) {
                cat_name = "other";
            }
            if (ordered_cat_list.length > 0) {
                var found_cat = ordered_cat_list.find(function (cat) { return cat == cat_name; });
                if (!found_cat) {
                    ordered_cat_list.push(cat_name);
                }
            }
            else {
                ordered_cat_list.push(cat_name);
            }
        }
    }
    ordered_cat_list.sort();
    for (var i = 0; i < ordered_cat_list.length; i++) {
        var new_sub_list = document.createElement("button");
        new_sub_list.type = "button";
        new_sub_list.className = "collapsible";
        new_sub_list.innerHTML = ordered_cat_list[i];

        side_menu.appendChild(new_sub_list);
        var new_div = document.createElement("div");
        new_div.className = "content";

        side_menu.appendChild(new_div);

        new_ul = document.createElement("ul");
        new_ul.id = ordered_cat_list[i];
        new_div.appendChild(new_ul);
    }
    ordered_op_list.sort();

    for (i = 0; i < ordered_op_list.length; i++) {
        op = document.getElementById(ordered_op_list[i]);
        if (op.className == "operator") {
            var cat_name = op.getAttribute("cat");
            if (!cat_name) {
                cat_name = "other";
            }
            var new_ul = document.getElementById(cat_name);
            var new_node = document.createElement("li");
            new_ul.appendChild(new_node);
            var a_node = document.createElement("a");
            new_node.appendChild(a_node);
            var text = op.id;
            var parenth = op.id.search("[(]");
            if (parenth != -1) {
                var close = op.id.search("[)]");
                text = op.id.substr(0, parenth);
                text += "<span style=\"color:#C6C2C1;\">" + op.id.substr(parenth, close - parenth + 1) + "</span>";
                text += op.id.substr(close + 1, op.id.length - close);
            }

            a_node.innerHTML = text;
            a_node.id = "disp_" + op.id;
            a_node.className = "sidenav-op";
            a_node.setAttribute("cat", cat_name);
            a_node.onclick = function () { changeOperatorDisplay(this); this.classList.toggle("active"); };

        }
    }

    tmp = {};
    tmp.id = "disp_mainText";
    changeDisplay(tmp);

};

function minVal(val1, val2) {
    if (val1 < val2) {
        return val1;
    }
    else {
        return val2;
    }
}

function colorScriptParts(code) {
    var codeOut = "";
    //var split_ns = code.split("::");
    //for (var isplit = 0; isplit < split_ns.length; isplit++) {
    //    var split = split_ns[isplit];
    //    codeOut += split;
    //    if (split != split_ns[split_ns.length - 1]) {
    //        codeOut += ".";
    //    }
    //}


    //code = codeOut;
    //codeOut = "";
    var split_inputs = code.split("inputs.");
    for (var isplit = 0; isplit < split_inputs.length; isplit++) {
        var split = split_inputs[isplit];
        var split_points = split.split("<br>");
        var inputs_name_index = split.length;
        if (split == split_inputs[0]) {

            if (isplit != split_inputs.length - 1) {
                inputs_name_index = inputs_name_index - split_points[split_points.length - 1].length;
            }
            codeOut += split.substr(0, inputs_name_index) + "<pin-data>" + split.substr(inputs_name_index, split.length - inputs_name_index) + "</pin-data>";
        }
        else {
            var index = split.search(new RegExp("[.]"));
            if (isplit != split_inputs.length - 1) {
                inputs_name_index = inputs_name_index - split_points[split_points.length - 1].length;
            }
            codeOut += "inputs.<pin-data>" + split.substr(0, index) + "</pin-data>" + split.substr(index, inputs_name_index - index);
            codeOut += "<pin-data>" + split.substr(inputs_name_index, split.length - inputs_name_index) + "</pin-data>";
        }
    }


    // code = codeOut;
    // codeOut = "";
    // var split_outputs = code.split("outputs.");
    // for (var isplit = 0; isplit < split_outputs.length; isplit++) {
    //     var split = split_outputs[isplit];
    //     var split_points = split.split("=");
    //     var split_parenth = split.split("(");
    //     var inputs_name_index = split.length;
    //     if (split == split_outputs[0]) {
    //         if (isplit != split_outputs.length - 1) {
    //             inputs_name_index = inputs_name_index - minVal(split_points[split_points.length - 1].length, split_parenth[split_parenth.length - 1].length);
    //         }
    //         codeOut += split.substr(0, inputs_name_index) + "<pin-data>" + split.substr(inputs_name_index, split.length - inputs_name_index) + "</pin-data>";
    //     }
    //     else {
    //         var index = minVal(split.search(new RegExp("[.]")), split.search(new RegExp("[)]")));
    //         var indexParent=split.search(new RegExp("[(]"));
    //         if (index > 0 && indexParent>0)
    //             index = minVal(index, indexParent);
    //         else if (indexParent > 0)
    //             index = indexParent;
    //         if (isplit != split_outputs.length - 1) {
    //             inputs_name_index = inputs_name_index - minVal(split_points[split_points.length - 1].length, split_parenth[split_parenth.length - 1].length);
    //         }
    //         codeOut += "outputs.<pin-data>" + split.substr(0, index) + "</pin-data>" + split.substr(index, inputs_name_index - index);
    //         codeOut += "<pin-data>" + split.substr(inputs_name_index, split.length - inputs_name_index) + "</pin-data>";
    //     }
    // }

    // code = codeOut;
    // var index_equal = code.search(new RegExp("="));
    // if (index_equal != -1) {
    //     codeOut = "";
    //     var last_index = 0;
    //     while (index_equal != -1) {

    //         var substring = code.substr(last_index, index_equal - last_index);
    //         var index_line = substring.search("\n");
    //         if (index_line != -1) {
    //             var new_index_line = substring.search(new RegExp("\n"));
    //             index_line = last_index;
    //             while (new_index_line != -1) {
    //                 index_line = new_index_line + index_line + 4;
    //                 var new_substring = code.substr(index_line, index_equal - index_line);
    //                 new_index_line = new_substring.search(new RegExp("\n"));
    //             }
    //             codeOut += code.substr(last_index, index_line - last_index);
    //             codeOut += "<pin-data>" + code.substr(index_line, index_equal - index_line) + "</pin-data>";
    //             codeOut += "=";

    //         }
    //         else if (substring.search(new RegExp("<br>")) != -1) {

    //             var new_index_line = substring.search(new RegExp("<br>"));
    //             index_line = last_index;
    //             while (new_index_line != -1) {
    //                 index_line = new_index_line + index_line + 4;
    //                 var new_substring = code.substr(index_line, index_equal - index_line);
    //                 new_index_line = new_substring.search(new RegExp("<br>"));
    //             }
    //             codeOut += code.substr(last_index, index_line - last_index);
    //             codeOut += "<pin-data>" + code.substr(index_line, index_equal - index_line) + "</pin-data>";
    //             codeOut += "=";
    //         }
    //         else {
    //             codeOut += "<pin-data>" + substring + "</pin-data>";
    //             codeOut += "=";
    //         }
    //         last_index = index_equal + 1;
    //         index_equal = code.substr(last_index, code.length - last_index).search(new RegExp("="));
    //         if (index_equal != -1) {
    //             index_equal = index_equal + last_index;
    //         }
    //         else {
    //             codeOut += code.substr(last_index, code.length - last_index);
    //         }
    //     }
    // }
    // code = codeOut;
    
    var index_parenth = code.search(new RegExp("[(]"));
    if (index_parenth != -1) {
        codeOut = "";
        var last_index = 0;
        while (index_parenth != -1) {
            var index_close = code.substr(index_parenth, code.length - index_parenth).search(new RegExp("[)]"));
            if (index_close != -1) {
                codeOut += code.substr(last_index, index_parenth - last_index + 1);
                codeOut += "<user-data>" + code.substr(index_parenth + 1, index_close - 1) + "</user-data>";
            }
            var substring = code.substr(index_close + index_parenth, code.length - index_close);

            last_index = index_close + index_parenth;
            index_parenth = substring.search(new RegExp("[(]"));
            if (index_parenth != -1) {
                index_parenth += last_index;
            }
            else {
                codeOut += code.substr(last_index, code.length);
            }

        }
    }

    code = codeOut;
    codeOut = "";
    var split_outputs = code.split("#");
    for (var isplit = 0; isplit < split_outputs.length; isplit++) {
        var split = split_outputs[isplit];
        if (split == split_outputs[0]) {
            codeOut += split;
        }
        else {
            var index_line = split.search("\n");
            if (index_line != -1) {
                // codeOut += "#";
                codeOut += "<commented-data>" + '#' + split.substr(0, index_line) + "</commented-data>";
                codeOut += split.substr(last_index, split.length - index_line);

            }
            else if (split.search(new RegExp("<br>")) != -1) {
                var index_line = split.search("<br>");
                if (index_line != -1) {
                    // codeOut += "#";
                    codeOut += "<commented-data>" + '#' + split.substr(0, index_line) + "</commented-data>";
                    codeOut += split.substr(index_line, split.length - index_line);

                }
            }
        }
    }

    return codeOut;



}

function automaticCodeGenerationIPython(cat_name, scripting_name, input_def, output_def)
{
    var code = "op = dpf.operators." + cat_name + "." + scripting_name + "\()  # operator instantiation" + "<br>";
   
    while (input_def && input_def.tagName != 'H2') {
        var name = input_def.getAttribute("name");
        var optional = input_def.getAttribute("optional");
        code += "op.inputs." + name + ".Connect(" + "my_" + name + ")";
        if (optional == "true") {
            code += "  # optional";
        }
        code += "<br>";

        input_def = input_def.nextElementSibling;
    }

        
    while (output_def && output_def.tagName != 'H2') {
        var name = output_def.getAttribute("name");
        var optional = output_def.getAttribute("optional");
        code += "my_" + name + " = op.outputs." + name + ".GetData()" + "<br>";
        output_def = output_def.nextElementSibling;
    }

    code = colorScriptParts(code);
    return code;
}


function automaticCodeGenerationCPython(ccp_name, input_def, output_def) {
    var code = "op = dpf.Operator(\'" + ccp_name+ "\')  # operator instantiation" + "<br>";

    while (input_def && input_def.tagName != 'H2') {
        var name = input_def.getAttribute("name");
        var optional = input_def.getAttribute("optional");
        code += "op.inputs." + name + ".connect(" + "my_" + name + ")";
        if (optional == "true") {
            code += "  # optional";
        }
        code += "<br>";

        input_def = input_def.nextElementSibling;
    }


    while (output_def && output_def.tagName != 'H2') {
        var name = output_def.getAttribute("name");
        var optional = output_def.getAttribute("optional");
        code += "my_" + name + " = op.outputs." + name + "\()" + "<br>";
        output_def = output_def.nextElementSibling;
    }

    code = colorScriptParts(code);
    return code;
}

function createScriptingFigure(parent, dict_menu_code, caption_name)
{
    var figure = document.createElement("figure");
    figure.id = "fig_" + dict_menu_code[0].id;
    parent.appendChild(figure);

    if (caption_name != null) {
        var figurecapt = document.createElement("figcaption");
        figurecapt.innerHTML = caption_name;
        figure.appendChild(figurecapt);
    }

    
    if (dict_menu_code.length>1) {

        var div = document.createElement("ul");
        div.className = "horizontal";
        figure.appendChild(div);

        for (var i = 0; i < dict_menu_code.length;i++){
            var li = document.createElement("li");
            div.appendChild(li);
            var a = document.createElement("a");
            a.className = "my-script-menu";
            a.innerHTML = dict_menu_code[i].title;
            a.id = "script_"+dict_menu_code[i].id;
            li.appendChild(a);


            var new_div = document.createElement("div");
            new_div.className = "content";
            new_div.id = "content_" + dict_menu_code[i].id;
            figure.appendChild(new_div);
            var pre = document.createElement("pre");
            pre.setAttribute("aria-labelledby", "scripting");
            new_div.appendChild(pre);
            var  codeblock = document.createElement("code");
            codeblock.innerHTML = dict_menu_code[i].code;
            codeblock.style.display = "block";
            pre.appendChild(codeblock);


            a.onclick = function () { changeDisplayScript(this) };
            if (dict_menu_code[i].active === true) {
                a.classList.toggle("active");
                new_div.style.display = "block";
            }
      }


    }
    else {

        var pre = document.createElement("pre");
        pre.setAttribute("aria-labelledby", "scripting");
        figure.appendChild(pre);

        var codeblock = document.createElement("code");
        codeblock.innerHTML = dict_menu_code[0].code;
        pre.appendChild(codeblock);
        //text += "<pre aria-labelledby=\"scripting\"><code>";
        //text += code;
        //text += "</code></pre>"
    }
    //text += "</figure>";
    //this.innerHTML = text;
}

class PinDefinition extends HTMLElement {
    constructor() {
        super();
        var name = this.getAttribute("name");
        var num = this.getAttribute("n");
        var doc = this.getAttribute("doc");
        var optional = this.getAttribute("optional");
        var types = this.getAttribute("types");

        var text = "<table class=\"pin-box\"><tbody><tr>";

        if (optional == "true") {
            text += "<td><pin-number-optional n=\"" + num + "\"></pin-number-optional></td>";
        }
        else {
            text += "<td><pin-number n=\"" + num + "\"></pin-number></td>";
        }

        if (name) {
            text += "<td><pin-name name=\"" + name + "\"></pin-name></td>";
        }

        if (types) {
            var type_list = types.split(" ");
            var types_string = "(";
            if (type_list.length >= 1) {
                types_string += type_list[0];
            }
            for (var i = 1 ; i < type_list.length; i++) {
                types_string += " | " + type_list[i];
            }
            types_string += ")";
            text += "<td><req-type typeName=\"" + types_string + "\"></req-type></td>";
        }

        if (doc) {
            text += "<td><pin-doc text=\": " + doc + "\"  ></pin-doc></td>";
        }

        text += "</tr></tbody></table>";
        this.innerHTML = text;
    }

};


class Scripting extends HTMLElement {
    constructor() {
        super();
        this.innerHTML = "";

        var scripting_name = this.getAttribute("scripting_name");
        var parent = this.parentNode;
        var cpp_name = this.getAttribute("cpp-name");
        var cat_name = this.getAttribute("cat");
        if (!cat_name) {
            cat_name = "other";
        }
        var header2 = parent.getElementsByTagName('h2');

        var list_scripting = document.createElement("ul");
        //list of info 
        {
            
            list_scripting.className = "list_scripting";
            this.appendChild(list_scripting);



            var item = document.createElement("li");
            item.innerHTML = "<span style=\"font-weight: bold;\">category: " + "</span>" + cat_name;
            list_scripting.appendChild(item);

            item = document.createElement("li");
            item.innerHTML = "<span style=\"font-weight: bold;\">plugin: " + "</span>" + this.getAttribute("plugin");
            list_scripting.appendChild(item);

            item = document.createElement("li");
            item.innerHTML = "<span style=\"font-weight: bold;\">scripting name: " + "</span>" + scripting_name;
            list_scripting.appendChild(item);

            item = document.createElement("li");
            item.innerHTML = "<span style=\"font-weight: bold;\">full name: " + "</span>" + cat_name + "." + scripting_name;
            list_scripting.appendChild(item);

            item = document.createElement("li");
            item.innerHTML = "<span style=\"font-weight: bold;\">internal name: " + "</span>" + cpp_name;
            list_scripting.appendChild(item);
        }

        //figure for scripting 
        {
            var input_def;
            var output_def;

            for (var i = 0; i < header2.length ; i++) {
                if (header2[i].innerHTML == "Inputs") {
                    input_def = header2[i].nextElementSibling;
                }
                else if (header2[i].innerHTML == "Outputs") {
                    var output_def = header2[i].nextElementSibling;
                }
            }
            var ipythoncode = automaticCodeGenerationIPython(cat_name, scripting_name, input_def, output_def);
            var cpythoncode = automaticCodeGenerationCPython(cpp_name, input_def, output_def);

            var codes= [{
                //     code: ipythoncode,
                //     title: "IPython",
                //     active: true,
                //     id: "ipython" + scripting_name
                // }, {
                    code: cpythoncode,
                    title: "CPython",
                    active: false,
                    id: "cpython" + scripting_name
                }];
           
            createScriptingFigure(list_scripting, codes, "Example Usage in Python");

        }
    
    }

};

class OperatorDescription extends HTMLElement {

    constructor() {
        super();
        var des = this.getAttribute("description");

        this.innerHTML = "<figure class=\"figure-op-des\"> <figcaption > Description  </figcaption>";
        this.innerHTML += "<pre class=\"figure-op-des-text\"><p>" + des + "</p></pre></figure>";

    }

};

class DataTypesFigure extends HTMLElement {

    constructor() {
        super();
        var fig = this.innerHTML;
        this.innerHTML = "";
        var fig_name = this.id;

        var des_name = "des_" + fig_name.substr(4);

        var node = document.getElementById(des_name);
        var new_fig = document.createElement("figure");
        new_fig.innerHTML = fig;
        node.appendChild(new_fig);
        new_fig.className = "entity-drawing";
        
    }

};

class APIsScript extends HTMLElement {

    constructor() {
        super();
        
        var ipythoncode =null;
        if (this.hasAttribute("ipython")) {
            ipythoncode = colorScriptParts(this.getAttribute("ipython"));
        }
        var cpythoncode =null;
        if (this.hasAttribute("cpython")) {
            cpythoncode = colorScriptParts(this.getAttribute("cpython"));
        }
        var fig_name = this.id;
        var des_name = "des_" + fig_name.substr(7);
        var node = document.getElementById(des_name);
        var script_exists = document.getElementById("fig_ipython" + fig_name.substr(7));
        if (script_exists!=null) {
            script_exists.remove();
        }
        this.innerHTML = "";
        var codes = null;
        if (cpythoncode != null) {
            codes = [{
                code: ipythoncode,
                title: "IPython",
                active: true,
                id: "ipython" + fig_name.substr(7)
            }, {
                code: cpythoncode,
                title: "CPython",
                active: false,
                id: "cpython" + fig_name.substr(7)
            }];
        }
        else
            codes = [{
                code: ipythoncode,
                title: "IPython",
                active: true,
                id: "ipython" + fig_name.substr(7)
            }];
        createScriptingFigure(node, codes, "Example of usage in python");
    
    }

};

class NoCaptionScript extends HTMLElement {

    constructor() {
        super();
        var pythoncode = null;
        if (this.hasAttribute("python")) {
            pythoncode = colorScriptParts(this.getAttribute("python"));
            this.removeAttribute("python");
        }
        this.innerHTML = "";
        var fig_name = this.id;
        var des_name = "des_" + fig_name.substr(7);

        if (pythoncode != null) {
            var node = document.getElementById(des_name);

            var ipythondict = [
              {
                  code: pythoncode,
                  title: null,
                  active: true,
                  id: "python" + fig_name
              }
            ];


            createScriptingFigure(node, ipythondict, null);
            ////figure for scripting 

            //    var fig = document.createElement("figure");
            //    fig.className = "api-scripting";

            //    node.appendChild(fig);


            //    var pre = document.createElement("pre");
            //    pre.setAttribute("aria-labelledby", "scripting");
            //    fig.appendChild(pre);

            //    var codeblock = document.createElement("code");
            //    codeblock.innerHTML = pythoncode;
            //    pre.appendChild(codeblock);

            //    //codeblock.innerHTML = code;

    

        }
    }

};
class OperatorTag extends HTMLElement {
    constructor() {
        super();
    }
};

class WorkflowTag extends HTMLElement {
    constructor() {
        super();

        var name = this.getAttribute("id");
        var des = this.getAttribute("description");
        var ipythoncode = colorScriptParts(this.getAttribute("ipython"));
        var workflowcode =null;
        if (this.getAttribute("workflow_code")!=null)
            workflowcode = colorScriptParts(this.getAttribute("workflow_code"));
        var cpythoncode = null;
        if (this.getAttribute("cpython") != null)
            cpythoncode = colorScriptParts(this.getAttribute("cpython"));
        this.innerHTML = "";
        var h2 = document.createElement("h2");
        h2.className = "h2-main";
        h2.innerHTML = name;
        this.appendChild(h2);

        var main = document.createElement("p");
        main.className = "p-main";
        main.innerHTML = des;
        this.appendChild(main);

        var codes =null;
        if (workflowcode != null && cpythoncode!=null) {
            codes = [{
                code: ipythoncode,
                title: "IPython",
                active: true,
                id: "ipython" + name
            }, {
                code: workflowcode,
                title: "Script result workflow",
                active: false,
                id: "scriptres" + name
            }, {
                code: cpythoncode,
                title: "CPython",
                active: false,
                id: "cpython" + name
            }];
        }
        else
            codes = [{
                code: code,
                title: "IPython",
                active: true,
                id: "ipython" + name
            }];
        createScriptingFigure(this, codes, "Python script");

        //var figure = document.createElement("figure");
        //figure.style="margin-left:30px;";
        //this.appendChild(figure);

        //var figurecapt = document.createElement("figcaption");
        //figurecapt.innerHTML= "Python script";
        //figure.appendChild(figurecapt);

        ////var text = "<h2 class=\"h2-main\">" + name + "</h2>";
        ////text += "<p class=\"p-main\">" + des + "</p>";
        ////text += "<figure style=\"margin-left:30px;\"> <figcaption>Python script</figcaption>";
        //if (workflowcode != null) {

        //    var script_display_name = "displayer_script" + name;
        //    var div = document.createElement("ul");
        //    div.className = "horizontal";

        //    figure.appendChild(div);

        //    var li2 = document.createElement("li");
        //    div.appendChild(li2);
        //    var a2 = document.createElement("a");
        //    a2.className = "my-script-menu";
        //    a2.innerHTML = "IPython";

        //    li2.appendChild(a2);


        //    new_div = document.createElement("div");
        //    new_div.className = "content";
        //    figure.appendChild(new_div);
        //    pre = document.createElement("pre");
        //    pre.setAttribute("aria-labelledby", "scripting");
        //    new_div.appendChild(pre);
        //    codeblock = document.createElement("code");
        //    codeblock.innerHTML = code;
        //    codeblock.style.display = "block";
        //    pre.appendChild(codeblock);


        //    a2.onclick = function () { changeDisplayScript(this) };

        //    a2.classList.toggle("active");
        //    new_div.style.display = "block";

        //    var li = document.createElement("li");
        //    div.appendChild(li);
        //    var a = document.createElement("a");
        //    a.className = "my-script-menu";
        //    a.innerHTML = "Script result workflow";
            
        //    li.appendChild(a);

        //    var new_div = document.createElement("div");
        //    new_div.className = "content";
        //    figure.appendChild(new_div);
        //    pre = document.createElement("pre");
        //    pre.setAttribute("aria-labelledby", "scripting");
        //    new_div.appendChild(pre);
        //    codeblock = document.createElement("code");
        //    codeblock.innerHTML = workflowcode;
        //    pre.appendChild(codeblock);
        //    a.onclick = function () { changeDisplayScript(this) };

            
        //}
        //else {

        //    var pre = document.createElement("pre");
        //    pre.setAttribute("aria-labelledby", "scripting");
        //    figure.appendChild(pre);

        //    var codeblock = document.createElement("code");
        //    codeblock.innerHTML = code;
        //    pre.appendChild(codeblock);
        //    //text += "<pre aria-labelledby=\"scripting\"><code>";
        //    //text += code;
        //    //text += "</code></pre>"
        //}
        ////text += "</figure>";
        ////this.innerHTML = text;
    }
};


class PinNumber extends HTMLElement {
    constructor() {
        super();

        var text = "<div class=\"tooltip\">" + " pin " + this.getAttribute("n");

        text += "<span class=\"tooltiptext\">";
        text += "requested";
        text += "</span>";
        text += "</div>";
        this.innerHTML = text;
    }
};

class PinName extends HTMLElement {
    constructor() {
        super();
        var text = "<div class=\"tooltip-lower\">" + this.getAttribute("name");

        text += "<span class=\"tooltiptext\">";
        text += "name";
        text += "</span>";
        text += "</div>";
        this.innerHTML = text;
    }
};

class PinDoc extends HTMLElement {
    constructor() {
        super();
        this.innerHTML = this.getAttribute("text");
    }
};

class PinNumberOptional extends HTMLElement {
    constructor() {
        super();

        var text = "<div class=\"tooltip\">" + " pin " + this.getAttribute("n");

        text += "<span class=\"tooltiptext\">";
        text += "optional";
        text += "</span>";
        text += "</div>";
        this.innerHTML = text;
    }
};


class Type extends HTMLElement {
    constructor() {
        super();
        var typeName = this.getAttribute("typeName");
        this.innerHTML = typeName;
        var text = "<div class=\"tooltip-lower\">" + typeName;
        text += "<span class=\"tooltiptext\">";
        text += "expected type in this pin";
        text += "</span>";
        text += "</div>";
        this.innerHTML = text;
    }
};

class ScriptingVariable extends HTMLElement {
    constructor() {
        super();
        this.innerHTML = "<span style=\"color: #4070a0;\">" + this.innerHTML + "</span>";
    }
};

class ScriptingPinMethod extends HTMLElement {
    constructor() {
        super();
        this.innerHTML = "<span style=\"color: black;\">" + this.innerHTML + "</span>";
    }
};

class ScriptingComments extends HTMLElement {
    constructor() {
        super();
        this.innerHTML = "<span style=\"color: #8f5902; font-style: italic;\">" + this.innerHTML + "</span>";
    }
};



customElements.define('op-tag', OperatorTag);
customElements.define('req-type', Type);
customElements.define('pin-number', PinNumber);
customElements.define('pin-name', PinName);
customElements.define('pin-doc', PinDoc);
customElements.define('pin-number-optional', PinNumberOptional);
customElements.define('pin-def', PinDefinition);
customElements.define('scripting-part', Scripting);
customElements.define('op-description', OperatorDescription);
customElements.define('figure-types', DataTypesFigure);
customElements.define('workflow-example', WorkflowTag);
customElements.define('user-data', ScriptingVariable);
customElements.define('pin-data', ScriptingPinMethod);
customElements.define('commented-data', ScriptingComments);
customElements.define('apis-scripts', APIsScript);

customElements.define('simple-scripts', NoCaptionScript);</script>

</body>
</html>

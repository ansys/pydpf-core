
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples\08-averaging\01-average_across_bodies.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_08-averaging_01-average_across_bodies.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_08-averaging_01-average_across_bodies.py:


.. _ref_average_across_bodies:

Average across bodies
~~~~~~~~~~~~~~~~~~~~~
This example shows how to activate and deactivate the DPF option for averaging
across bodies. When a multi-body simulation calculates ``ElementalNodal`` fields,
like stresses or strains, you can either activate or deactivate the averaging
of theses fields across the different bodies when they share common nodes. This
likely changes the end results that are shown after postprocessing of the simulation.

.. GENERATED FROM PYTHON SOURCE LINES 14-15

Perform the required imports.

.. GENERATED FROM PYTHON SOURCE LINES 15-20

.. code-block:: default


    from ansys.dpf import core as dpf
    from ansys.dpf.core import operators as ops
    from ansys.dpf.core import examples








.. GENERATED FROM PYTHON SOURCE LINES 21-22

Load the simulation results from an RST file and create a model of it.

.. GENERATED FROM PYTHON SOURCE LINES 22-27

.. code-block:: default


    analysis = examples.download_piston_rod()
    model = dpf.Model(analysis)
    print(model)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF Model
    ------------------------------
    Static analysis
    Unit system: MKS: m, kg, N, s, V, A, degC
    Physics Type: Mechanical
    Available results:
         -  displacement: Nodal Displacement
         -  reaction_force: Nodal Force   
         -  stress: ElementalNodal Stress 
         -  elemental_volume: Elemental Volume
         -  stiffness_matrix_energy: Elemental Energy-stiffness matrix
         -  artificial_hourglass_energy: Elemental Hourglass Energy
         -  thermal_dissipation_energy: Elemental thermal dissipation energy
         -  kinetic_energy: Elemental Kinetic Energy
         -  co_energy: Elemental co-energy
         -  incremental_energy: Elemental incremental energy
         -  elastic_strain: ElementalNodal Strain
         -  structural_temperature: ElementalNodal Temperature
    ------------------------------
    DPF  Meshed Region: 
      33337 nodes 
      18235 elements 
      Unit: m 
      With solid (3D) elements
    ------------------------------
    DPF  Time/Freq Support: 
      Number of sets: 3 
    Cumulative     Time (s)       LoadStep       Substep         
    1              1.000000       1              1               
    2              2.000000       2              1               
    3              3.000000       3              1               





.. GENERATED FROM PYTHON SOURCE LINES 28-31

To take a look at the system to see how bodies are connected to each other,
extract the mesh of the model and then divide it into different meshes
using the ``split_mesh`` operator.

.. GENERATED FROM PYTHON SOURCE LINES 31-38

.. code-block:: default


    mesh = model.metadata.meshed_region
    split_mesh_op = ops.mesh.split_mesh(mesh=mesh, property="mat")
    meshes = split_mesh_op.outputs.meshes()

    meshes.plot(text="Body meshes")




.. image-sg:: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_001.png
   :alt: 01 average across bodies
   :srcset: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 39-42

As you can see in the preceding image, even though the piston rod is one single part,
it is composed of two different bodies. Additionally, you can see that the region
where the two bodies are bonded together contains nodes that are common between them.

.. GENERATED FROM PYTHON SOURCE LINES 44-50

Averaging across bodies with DPF
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To take a look at how the option for averaging across bodies alters the results
of the simulation, define two workflows. The first workflow does averaging across
bodies, while the second workflow does not. The variable of interest is the stress
in the Z direction, which is obtained using the "stress_Z" operator.

.. GENERATED FROM PYTHON SOURCE LINES 52-81

.. graphviz::

  digraph foo {
      graph [pad="0", nodesep="0.3", ranksep="0.3"]
      node [shape=box, style=filled, fillcolor="#ffcc0", margin="0"];
      rankdir=LR;
      splines=line;
      node [fixedsize=true,width=2.5]
      stress01 [label="stress_Z"];
      stress02 [label="stress_Z"];
      scp01 [label="split_on_property_type"];
      subgraph cluster_1 {
          ds01 [label="data_src", shape=box, style=filled, fillcolor=cadetblue2];
          ds01 -> scp01 [style=dashed];
          scp01 -> stress01;
          label="Averaging across bodies = Off";
          style=filled;
          fillcolor=lightgrey;
      }
      subgraph cluster_2 {
          ds02 [label="data_src", shape=box, style=filled, fillcolor=cadetblue2];
          inv02 [style=invisible]
          ds02 -> stress02 [style=dashed];
          stress02 -> inv02 [style=invis]
          label="Averaging across bodies = On";
          style=filled;
          fillcolor=lightgrey;
      }
  }

.. GENERATED FROM PYTHON SOURCE LINES 84-88

Averaging across bodies activated
---------------------------------
The extraction of the stresses in the Z direction applies averaging
across bodies by default. Thus, you can use a simple workflow.

.. GENERATED FROM PYTHON SOURCE LINES 88-119

.. code-block:: default



    def average_across_bodies(analysis):
        # Extract the stresses in the Z direction (with the average
        # across bodies property activated) and plot them.

        # Create a model from the simulation results.
        model = dpf.Model(analysis)
        mesh = model.metadata.meshed_region

        # Set the time set of interest to the last time set.
        time_set = 3

        # Extract the stresses in the Z direction. By default, DPF already applies
        # averaging across bodies when extracting the stresses.
        stress_op = ops.result.stress_Z()
        stress_op.inputs.connect(model)
        stress_op.inputs.time_scoping.connect(time_set)
        stress_op.inputs.requested_location.connect(dpf.locations.nodal)
        stresses = stress_op.outputs.fields_container()

        # Find the maximum stress value.
        min_max = dpf.operators.min_max.min_max_fc()
        min_max.inputs.fields_container.connect(stresses)
        max_val = min_max.outputs.field_max()

        mesh.plot(stresses, text="Averaged across bodies")

        return max(max_val.data)









.. GENERATED FROM PYTHON SOURCE LINES 120-126

Averaging across bodies deactivated
-----------------------------------
The workflow is more complicated for extracting the stresses without
averaging across the bodies of the simulated part. Instead of presenting
the workflow as a function, it is broken into various parts with explanations
of what is being done.

.. GENERATED FROM PYTHON SOURCE LINES 128-130

Create a model from the simulation results and extract its mesh and
step information.

.. GENERATED FROM PYTHON SOURCE LINES 130-135

.. code-block:: default

    model = dpf.Model(analysis)
    mesh = model.metadata.meshed_region
    time_freq = model.metadata.time_freq_support
    time_sets = time_freq.time_frequencies.data.tolist()








.. GENERATED FROM PYTHON SOURCE LINES 136-139

Split the meshes of the two bodies so that separate scopings can be
created for each one of them. The `'mat'`` label is used to split the mesh
by bodies.

.. GENERATED FROM PYTHON SOURCE LINES 139-142

.. code-block:: default

    mesh_scop_op = ops.scoping.split_on_property_type(mesh=mesh, label1="mat")
    mesh_scop_cont = mesh_scop_op.outputs.mesh_scoping()








.. GENERATED FROM PYTHON SOURCE LINES 143-145

Given that there are three different time steps, create a scopings container
that contains the meshes of each of these time steps.

.. GENERATED FROM PYTHON SOURCE LINES 145-158

.. code-block:: default


    scop_cont = dpf.ScopingsContainer()
    scop_cont.add_label("body")
    scop_cont.add_label("time")
    for tset in time_sets:
        body = 1
        for mesh_scop in mesh_scop_cont:
            scop_cont.add_scoping(
                scoping=mesh_scop, label_space={"body": body, "time": int(tset)}
            )
            body += 1
    print(scop_cont)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF Scopings Container with
            6 scoping(s)
            defined on labels ['body', 'time'] 






.. GENERATED FROM PYTHON SOURCE LINES 159-163

The scopings container has six different scopings, one for each body over
each of the three time steps.

Set the time set of interest to the last time set.

.. GENERATED FROM PYTHON SOURCE LINES 163-165

.. code-block:: default

    time_set = 3








.. GENERATED FROM PYTHON SOURCE LINES 166-170

To retrieve the Z stresses without averaging across the two bodies, you must
pass a scopings container that contains their respective meshes as a parameter
to the ``stress_Z`` operator. To do this, create a scopings container that contains
the meshes of the two bodies in the desired time step.

.. GENERATED FROM PYTHON SOURCE LINES 170-179

.. code-block:: default


    scop_list = scop_cont.get_scopings(label_space={"time": time_set})
    scopings = dpf.ScopingsContainer()
    scopings.add_label("body")
    body = 1
    for scop in scop_list:
        scopings.add_scoping(label_space={"body": body}, scoping=scop)
        body += 1
    print(scopings)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF Scopings Container with
            2 scoping(s)
            defined on labels ['body'] 






.. GENERATED FROM PYTHON SOURCE LINES 180-181

This contain has only two scopings, one for each body in the last time step.

.. GENERATED FROM PYTHON SOURCE LINES 183-184

Extract the stresses in the Z direction.

.. GENERATED FROM PYTHON SOURCE LINES 184-194

.. code-block:: default


    stress_op = ops.result.stress_Z()
    stress_op.inputs.connect(model)
    stress_op.inputs.time_scoping.connect(time_set)
    stress_op.inputs.mesh_scoping.connect(
        scopings
    )  # This option deactivates averaging across bodies.
    stress_op.inputs.requested_location.connect(dpf.locations.nodal)
    stresses = stress_op.outputs.fields_container()
    print(stresses)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    DPF stress(s)Fields Container
      with 2 field(s)
      defined on labels: body time 

      with:
      - field 0 {body:  1, time:  3} with Nodal location, 1 components and 17281 entities.
      - field 1 {body:  2, time:  3} with Nodal location, 1 components and 17610 entities.





.. GENERATED FROM PYTHON SOURCE LINES 195-196

Find the maximum value of the stress field for comparison purposes.

.. GENERATED FROM PYTHON SOURCE LINES 196-200

.. code-block:: default


    min_max = dpf.operators.min_max.min_max_fc()
    min_max.inputs.fields_container.connect(stresses)
    max_val = min_max.outputs.field_max()







.. GENERATED FROM PYTHON SOURCE LINES 201-202

Define the preceding workflow as a function:

.. GENERATED FROM PYTHON SOURCE LINES 202-254

.. code-block:: default



    def not_average_across_bodies(analysis):
        # This function extracts the stresses in the Z direction (with the average
        # across bodies option deactivated) and plot them.

        model = dpf.Model(analysis)
        mesh = model.metadata.meshed_region

        time_freq = model.metadata.time_freq_support
        time_sets = time_freq.time_frequencies.data.tolist()

        mesh_scop_op = ops.scoping.split_on_property_type(mesh=mesh, label1="mat")
        mesh_scop_cont = mesh_scop_op.outputs.mesh_scoping()

        scop_cont = dpf.ScopingsContainer()
        scop_cont.add_label("body")
        scop_cont.add_label("time")
        for tset in time_sets:
            body = 1
            for mesh_scop in mesh_scop_cont:
                scop_cont.add_scoping(
                    scoping=mesh_scop, label_space={"body": body, "time": int(tset)}
                )
                body += 1

        time_set = 3

        scop_list = scop_cont.get_scopings(label_space={"time": time_set})
        scopings = dpf.ScopingsContainer()
        scopings.add_label("body")
        body = 1
        for scop in scop_list:
            scopings.add_scoping(label_space={"body": body}, scoping=scop)
            body += 1

        stress_op = ops.result.stress_Z()
        stress_op.inputs.connect(model)
        stress_op.inputs.time_scoping.connect(time_set)
        stress_op.inputs.mesh_scoping.connect(scopings)
        stress_op.inputs.requested_location.connect(dpf.locations.nodal)
        stresses = stress_op.outputs.fields_container()

        min_max = dpf.operators.min_max.min_max_fc()
        min_max.inputs.fields_container.connect(stresses)
        max_val = min_max.outputs.field_max()

        meshes.plot(stresses, text="Not averaged across bodies")

        return max(max_val.data)









.. GENERATED FROM PYTHON SOURCE LINES 255-260

Plot and compare the results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Plot and compare the results. The first plot shows the stress distribution
when averaging across bodies is activated. The second plot shows the stress
distribution when averaging across bodies is deactivated.

.. GENERATED FROM PYTHON SOURCE LINES 260-264

.. code-block:: default


    max_avg_on = average_across_bodies(analysis)
    max_avg_off = not_average_across_bodies(analysis)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_002.png
          :alt: 01 average across bodies
          :srcset: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_002.png
          :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_003.png
          :alt: 01 average across bodies
          :srcset: /examples/08-averaging/images/sphx_glr_01-average_across_bodies_003.png
          :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 265-280

.. code-block:: default

    diff = abs(max_avg_on - max_avg_off) / max_avg_off * 100
    print(
        "Max stress when averaging across bodies is activated: {:.2f} Pa".format(max_avg_on)
    )
    print(
        "Max stress when averaging across bodies is deactivated: {:.2f} Pa".format(
            max_avg_off
        )
    )
    print(
        "The maximum stress value when averaging across bodies is ACTIVATED \
    is {:.2f}% LOWER than when it is DEACTIVATED".format(
            diff
        )
    )




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Max stress when averaging across bodies is activated: 6958243299.56 Pa
    Max stress when averaging across bodies is deactivated: 6988756864.00 Pa
    The maximum stress value when averaging across bodies is ACTIVATED is 0.44% LOWER than when it is DEACTIVATED





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  5.816 seconds)


.. _sphx_glr_download_examples_08-averaging_01-average_across_bodies.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 01-average_across_bodies.py <01-average_across_bodies.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 01-average_across_bodies.ipynb <01-average_across_bodies.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
